#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Autonomous LLM4AD task: optimization_qap_construct
Generated by convert_llm4ad_benchmark.py

This is a fully self-contained task module that doesn't depend on the original LLM4AD codebase.
"""

# Embedded evaluation code (benchmark)
# Module Name: QAPEvaluation
# Last Revision: 2025/2/16
# Description: Evaluates the Quadratic Assignment Problem (QAP).
#       The QAP involves assigning a set of facilities to a set of locations in such a way that the total cost of interactions between facilities is minimized.
#       This module is part of the LLM4AD project (https://github.com/Optima-CityU/llm4ad).
#
# Parameters:
#   - timeout_seconds: Maximum allowed time (in seconds) for the evaluation process: int (default: 20).
#   - n_facilities: Number of facilities to assign: int (default: 50).
#   - n_instance: Number of problem instances to generate: int (default: 10).
# 
# References:
#   - Fei Liu, Rui Zhang, Zhuoliang Xie, Rui Sun, Kai Li, Xi Lin, Zhenkun Wang, 
#       Zhichao Lu, and Qingfu Zhang, "LLM4AD: A Platform for Algorithm Design 
#       with Large Language Model," arXiv preprint arXiv:2412.17287 (2024).
#
# ------------------------------- Copyright --------------------------------
# Copyright (c) 2025 Optima Group.
# 
# Permission is granted to use the LLM4AD platform for research purposes. 
# All publications, software, or other works that utilize this platform 
# or any part of its codebase must acknowledge the use of "LLM4AD" and 
# cite the following reference:
# 
# Fei Liu, Rui Zhang, Zhuoliang Xie, Rui Sun, Kai Li, Xi Lin, Zhenkun Wang, 
# Zhichao Lu, and Qingfu Zhang, "LLM4AD: A Platform for Algorithm Design 
# with Large Language Model," arXiv preprint arXiv:2412.17287 (2024).
# 
# For inquiries regarding commercial use or licensing, please contact 
# http://www.llm4ad.com/contact.html
# --------------------------------------------------------------------------

from __future__ import annotations
import numpy as np
from typing import Callable, Any, List, Tuple
import matplotlib.pyplot as plt

from llm4ad_loader import Evaluation
import os, sys
sys.path.insert(0, os.path.dirname(__file__))
from get_instance import GetData
# from llm4ad.task.optimization.qap_construct.get_instance import GetData  # Converted from LLM4AD import
# from llm4ad.task.optimization.qap_construct.template import template_program, task_description  # Template values embedded below

# Embedded template values
template_program = 'import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    """\n    A heuristic for the Quadratic Assignment Problem.\n\n    Args:\n        current_assignment: Current assignment of facilities to locations (-1 means unassigned).\n        flow_matrix: Flow matrix between facilities.\n        distance_matrix: Distance matrix between locations.\n\n    Returns:\n        Updated assignment of facilities to locations.\n    """\n    n_facilities = len(current_assignment)\n    \n    # Find the first unassigned facility and the first available location\n    for facility in range(n_facilities):\n        if current_assignment[facility] == -1:\n            # Find the first available location\n            for location in range(n_facilities):\n                if location not in current_assignment:\n                    current_assignment[facility] = location\n                    break\n            break\n    \n    return current_assignment'
task_description = "'"


__all__ = ['QAPEvaluation']


class QAPEvaluation(Evaluation):
    """Evaluator for the Quadratic Assignment Problem."""

    def __init__(self,
                 timeout_seconds=20,
                 n_facilities=50,
                 n_instance=16,
                 **kwargs):
        """
        Initializes the QAP evaluator.
        """
        super().__init__(
            template_program=template_program,
            task_description=task_description,
            use_numba_accelerate=False,
            timeout_seconds=timeout_seconds
        )

        self.n_instance = n_instance
        self.n_facilities = n_facilities
        self.data_generator = GetData(self.n_instance, self.n_facilities)
        self._datasets = self.data_generator.generate_instances()

    def evaluate_program(self, program_str: str, callable_func: Callable) -> Any | None:
        """
        Evaluates the program (constructive heuristic) for the QAP.

        Args:
            program_str: Program string (not used here, but kept for compatibility).
            callable_func: The constructive heuristic function to evaluate.

        Returns:
            The average total cost across all instances.
        """
        return self.evaluate_qap(callable_func)

    def plot_solution(self, flow_matrix: np.ndarray, distance_matrix: np.ndarray, assignment: List[int]):
        """
        Plot the solution of the Quadratic Assignment Problem.

        Args:
            flow_matrix: Flow matrix between facilities.
            distance_matrix: Distance matrix between locations.
            assignment: Assignment of facilities to locations.
        """
        n_facilities = len(assignment)

        # Generate random coordinates for locations (for visualization purposes)
        np.random.seed(42)  # For reproducibility
        locations = np.random.rand(n_facilities, 2) * 10  # Scale coordinates for better visualization

        # Plot locations
        plt.figure(figsize=(8, 6))
        for loc_id, (x, y) in enumerate(locations):
            plt.scatter(x, y, color='blue', s=200, label='Locations' if loc_id == 0 else "", zorder=1)
            plt.text(x, y, f'L{loc_id + 1}', fontsize=12, ha='right', va='bottom', zorder=1)

        # Plot facilities and connections based on flow
        for facility_id, loc_id in enumerate(assignment):
            x, y = locations[loc_id]
            plt.scatter(x, y, color='red', s=100, marker='s', label='Facilities' if facility_id == 0 else "", zorder=2)
            plt.text(x, y, f'F{facility_id + 1}', fontsize=12, ha='left', va='top', zorder=2)

        # Draw lines between facilities based on flow
        for i in range(n_facilities):
            for j in range(i + 1, n_facilities):
                if flow_matrix[i, j] > 0:
                    loc_i = assignment[i]
                    loc_j = assignment[j]
                    plt.plot(
                        [locations[loc_i, 0], locations[loc_j, 0]],
                        [locations[loc_i, 1], locations[loc_j, 1]],
                        color='gray', linewidth=flow_matrix[i, j] / 10, alpha=0.5, zorder=0
                    )

        plt.title('QAP Solution: Facilities Assigned to Locations')
        plt.xlabel('X Coordinate')
        plt.ylabel('Y Coordinate')
        plt.legend()
        plt.grid(True)
        plt.show()

    def qap_evaluate(self, current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray, eva: Callable) -> List[int]:
        """
        Evaluate the next assignment for the Quadratic Assignment Problem using a constructive heuristic.

        Args:
            current_assignment: Current assignment of facilities to locations.
            flow_matrix: Flow matrix between facilities.
            distance_matrix: Distance matrix between locations.
            eva: The constructive heuristic function to select the next assignment.

        Returns:
            Updated assignment of facilities to locations.
        """
        # Use the heuristic to select the next assignment

        n_facilities = flow_matrix.shape[0]
        for _ in range(n_facilities):
            next_assignment = eva(current_assignment, flow_matrix, distance_matrix)

        return next_assignment

    def evaluate_qap(self, eva: Callable) -> float:
        """
        Evaluate the constructive heuristic for the Quadratic Assignment Problem.

        Args:
            instance_data: List of tuples containing the flow and distance matrices.
            n_ins: Number of instances to evaluate.
            eva: The constructive heuristic function to evaluate.

        Returns:
            The average total cost across all instances.
        """
        total_cost = 0

        for instance in self._datasets[:self.n_instance]:
            flow_matrix, distance_matrix = instance
            n_facilities = flow_matrix.shape[0]
            current_assignment = [-1] * n_facilities  # Initialize with no assignments
            current_assignment = self.qap_evaluate(current_assignment, flow_matrix, distance_matrix, eva)

            # Check if current_assignment is a feasible solution
            if -1 in current_assignment:
                raise ValueError("Feasibility check failed: Not all facilities are allocated.")
            if any(not (0 <= x < n_facilities) for x in current_assignment):
                raise ValueError("Feasibility check failed: Assignment values are out of range.")
            if len(set(current_assignment)) != n_facilities:
                raise ValueError("Feasibility check failed: Duplicate assignment values found.")

            # Calculate the total cost of the assignment
            cost = 0
            for i in range(n_facilities):
                for j in range(n_facilities):
                    cost += flow_matrix[i, j] * distance_matrix[current_assignment[i], current_assignment[j]]
            total_cost += cost

        average_cost = total_cost / self.n_instance
        return -average_cost  # We want to minimize the total cost


if __name__ == '__main__':

    def select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:
        """
        A greedy heuristic for the Quadratic Assignment Problem.

        Args:
            current_assignment: Current assignment of facilities to locations (-1 means unassigned).
            flow_matrix: Flow matrix between facilities.
            distance_matrix: Distance matrix between locations.

        Returns:
            Updated assignment of facilities to locations.
        """
        n_facilities = len(current_assignment)

        # Find the first unassigned facility and the first available location
        for facility in range(n_facilities):
            if current_assignment[facility] == -1:
                # Find the first available location
                for location in range(n_facilities):
                    if location not in current_assignment:
                        current_assignment[facility] = location
                        break
                break

        return current_assignment


    bp1d = QAPEvaluation()
    ave_bins = bp1d.evaluate_program('_', select_next_assignment)
    print(ave_bins)

# Task configuration for benchmark task
ENTRY_NAME = 'select_next_assignment'
FUNCTION_SIGNATURE = 'def select_next_assignment(...):'
IMPORT_HEADER = 'import numpy as np\nimport math'
TASK_DESCRIPTION = "'"
OBJECTIVE_TEXT = "You are optimizing the implementation of `select_next_assignment` for the LLM4AD task.\\n\\nTask description:\\n'\\n\\nYour goal is to return a correct and efficient function whose score (computed by the task evaluator) is as high as possible."
TEMPLATE_FUNCTION = 'import numpy as np\n\ndef select_next_assignment(current_assignment: List[int], flow_matrix: np.ndarray, distance_matrix: np.ndarray) -> List[int]:\n    """\n    A heuristic for the Quadratic Assignment Problem.\n\n    Args:\n        current_assignment: Current assignment of facilities to locations (-1 means unassigned).\n        flow_matrix: Flow matrix between facilities.\n        distance_matrix: Distance matrix between locations.\n\n    Returns:\n        Updated assignment of facilities to locations.\n    """\n    n_facilities = len(current_assignment)\n    \n    # Find the first unassigned facility and the first available location\n    for facility in range(n_facilities):\n        if current_assignment[facility] == -1:\n            # Find the first available location\n            for location in range(n_facilities):\n                if location not in current_assignment:\n                    current_assignment[facility] = location\n                    break\n            break\n    \n    return current_assignment'
EVAL_CLASS_NAME = 'QAPEvaluation'
EVAL_KWARGS = {'timeout_seconds': 30}

def build_trace_problem(**override_eval_kwargs) -> dict:
    """Build a Trace-ready problem using embedded benchmark evaluator."""
    
    # Create evaluator instance with embedded class
    eval_kwargs_final = EVAL_KWARGS.copy()
    eval_kwargs_final.update(override_eval_kwargs)
    
    evaluator = globals()[EVAL_CLASS_NAME](**eval_kwargs_final)
    
    from llm4ad_loader import AutonomousEvaluatorGuide
    from opto import trace
    
    # Create parameter
    initial_code = TEMPLATE_FUNCTION.strip()
    param = trace.node(initial_code, name='__code', 
                      description=f'The code should start with: {FUNCTION_SIGNATURE}', 
                      trainable=True)
    
    # Create guide using benchmark embedded evaluator
    guide = AutonomousEvaluatorGuide(evaluator, ENTRY_NAME, IMPORT_HEADER, 
                                   timeout=eval_kwargs_final.get('timeout_seconds', 30))
    
    # Create dataset
    train_dataset = dict(
        inputs=[TASK_DESCRIPTION],
        infos=[{'imports': IMPORT_HEADER, 'entry': ENTRY_NAME}]
    )
    
    # Optimizer kwargs
    optimizer_kwargs = dict(
        objective=OBJECTIVE_TEXT,
        memory_size=10
    )
    
    return dict(
        param=param,
        guide=guide,
        train_dataset=train_dataset,
        optimizer_kwargs=optimizer_kwargs,
        metadata=dict(
            entry=ENTRY_NAME,
            function_signature=FUNCTION_SIGNATURE,
            eval_class=EVAL_CLASS_NAME,
            benchmark=True,
        )
    )
