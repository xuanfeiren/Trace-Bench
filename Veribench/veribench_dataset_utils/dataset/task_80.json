{
  "task_id": 80,
  "python_code": "# File: humaneval_34_unique.py\n# HumanEval problem HumanEval/34\n\ndef unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))\n\n# Test function\n\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n\n\n# Run tests\nif __name__ == \"__main__\":\n    check(unique)\n    print(\"All tests passed!\")",
  "gold_reference_lean4_code": "/-!\n# VeriBench – Unique Elements\n\nFile order:\n\n1. Implementation\n2. Unit tests (positive, edge, positive/negative test suite)\n3. Pre‑condition prop\n4. Exhaustive property prop and their theorems\n5. Post‑condition prop (same order as property props)\n6. Correctness theorem `Pre → Post`\n7. Imperative i. implementation, ii. tests (positive, edge, positive/negative\ntest suite), and iii. equivalence theorem.\n\nAll real proofs are left as `sorry` for the learner/model/agent.\n\n# Implementation\n\n## Unique Elements\n\nReturns a sorted list of unique elements from the input list.-/\n\nnamespace UniqueElements\n\n/--\n**Implementation of `unique`.**\n\n`unique l` returns a sorted list of unique elements from the input list.\n\nGiven a list of natural numbers, returns a new list containing all unique elements\nfrom the input list, sorted in ascending order.\n\n## Examples\n\n#eval unique [5, 3, 5, 2, 3, 3, 9, 0, 123]  -- expected: [0, 2, 3, 5, 9, 123]\n#eval unique [1, 1, 1]  -- expected: [1]\n#eval unique []  -- expected: []\n-/\ndef unique (l : List Nat) : List Nat :=\n  (l.eraseDups.toArray.qsort (· ≤ ·)).toList\n\n/-!\n# Tests\n-/\n\n/-- expected: [0, 2, 3, 5, 9, 123] -/\nexample : unique [5, 3, 5, 2, 3, 3, 9, 0, 123] = [0, 2, 3, 5, 9, 123] := by native_decide\n#eval unique [5, 3, 5, 2, 3, 3, 9, 0, 123] -- expected: [0, 2, 3, 5, 9, 123]\n\n/-- expected: [1] -/\nexample : unique [1, 1, 1] = [1] := by native_decide\n#eval unique [1, 1, 1] -- expected: [1]\n\n/-!\n# Tests: Edge Cases\n-/\n\n/-- expected: [] -/\nexample : unique [] = [] := by native_decide\n#eval unique [] -- expected: []\n\n/-- expected: [1, 2, 3] -/\nexample : unique [1, 2, 3] = [1, 2, 3] := by native_decide\n#eval unique [1, 2, 3] -- expected: [1, 2, 3]\n\n/-!\n# Positive / Negative Test‑Suite\n-/\n\n/-- positive test: removes duplicates and sorts -/\nexample : unique [3, 2, 1, 2, 3] = [1, 2, 3] := by native_decide\n#eval unique [3, 2, 1, 2, 3] -- expected: [1, 2, 3]\n\n/-- positive test: single element -/\nexample : unique [42] = [42] := by native_decide\n#eval unique [42] -- expected: [42]\n\n/-- negative test: result is not the same as original when duplicates exist -/\nexample : ¬ (unique [1, 1, 2, 2] = [1, 1, 2, 2]) := by native_decide\n\n/-- negative test: different inputs give different results -/\nexample : unique [1, 2, 3] = unique [3, 2, 1, 1] := by native_decide\n\n/-!\n# Pre‑Condition\n-/\n\n/-- **Pre‑condition.** Any list of natural numbers is valid input. -/\ndef Pre (_ : List Nat) : Prop := True\n\n/-!\n# Property Theorems\n-/\n\n/-- **No duplicates property**: Result has no duplicate elements. -/\ndef no_duplicates_prop (l : List Nat) : Prop := (unique l).Nodup\n\n/-- **No duplicates theorem**: Result has no duplicate elements. -/\n@[simp] theorem no_duplicates_thm (l : List Nat) : no_duplicates_prop l := sorry\n\n/-- **Sorted property**: Result is sorted in ascending order. -/\ndef sorted_prop (l : List Nat) : Prop :=\n  let result := unique l\n  ∀ i j : Nat, i < j → j < result.length → result[i]! ≤ result[j]!\n\n/-- **Sorted theorem**: Result is sorted in ascending order. -/\n@[simp] theorem sorted_thm (l : List Nat) : sorted_prop l := sorry\n\n/-- **Membership property**: All result elements were in the original list. -/\ndef membership_prop (l : List Nat) : Prop := ∀ x ∈ unique l, x ∈ l\n\n/-- **Membership theorem**: All result elements were in the original list. -/\n@[simp] theorem membership_thm (l : List Nat) : membership_prop l := sorry\n\n/-- **Completeness property**: All original elements appear in result (no loss). -/\ndef completeness_prop (l : List Nat) : Prop := ∀ x ∈ l, x ∈ unique l\n\n/-- **Completeness theorem**: All original elements appear in result (no loss). -/\n@[simp] theorem completeness_thm (l : List Nat) : completeness_prop l := sorry\n\n/-!\n# Post‑Condition  (conjunction of all desired properties)\n-/\n\n/-- **Post‑condition**: conjunction of all desired properties for unique. -/\ndef Post_prop (l : List Nat) : Prop :=\n  (no_duplicates_prop l) ∧                               -- no duplicates property\n  (sorted_prop l) ∧                                      -- sorted property\n  (membership_prop l) ∧                                  -- membership property\n  (completeness_prop l)                                  -- completeness property\n\n/-!\n# Correctness Theorem\n-/\n\n/-- **Correctness theorem**: the pre‑condition implies the post‑condition. -/\ntheorem correctness_thm (l : List Nat) (hPre : Pre l) : Post_prop l := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\n`uniqueImp l` computes the same result using imperative style with mutable arrays.\n-/\ndef uniqueImp (l : List Nat) : List Nat :=\n  Id.run do\n    let mut result : Array Nat := #[]\n    let mut seen : Array Bool := Array.mkArray (l.max?.getD 0 + 1) false\n\n    -- Mark seen elements\n    for x in l do\n      if x < seen.size then\n        seen := seen.set! x true\n\n    -- Collect unique elements\n    for i in [:seen.size] do\n      if seen[i]! then\n        result := result.push i\n\n    return result.toList\n\n/-!\n# Imperative Tests\n-/\n\n/-- expected: [0, 2, 3, 5, 9, 123] -/\nexample : uniqueImp [5, 3, 5, 2, 3, 3, 9, 0, 123] = [0, 2, 3, 5, 9, 123] := by native_decide\n#eval uniqueImp [5, 3, 5, 2, 3, 3, 9, 0, 123] -- expected: [0, 2, 3, 5, 9, 123]\n\n/-!\n# Imperative Tests: Edge Cases\n-/\n\n/-- expected: [1] -/\nexample : uniqueImp [1, 1, 1] = [1] := by native_decide\n#eval uniqueImp [1, 1, 1] -- expected: [1]\n\n/-!\n# Positive / Negative Test‑Suite\n-/\n\n/-- positive test: handles empty list -/\nexample : uniqueImp [] = [] := by native_decide\n#eval uniqueImp [] -- expected: []\n\n/-- negative test: not the same as original when duplicates exist -/\nexample : ¬ (uniqueImp [1, 1, 2, 2] = [1, 1, 2, 2]) := by native_decide\n\n/-- **Equivalence theorem**: functional and imperative implementations coincide. -/\ntheorem unique_equivalence_thm (l : List Nat) :\n  unique l = uniqueImp l := sorry\n\nend UniqueElements\n"
}