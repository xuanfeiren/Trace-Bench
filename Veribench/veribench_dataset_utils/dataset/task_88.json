{
  "task_id": 88,
  "python_code": "# File: humaneval_41_car_race_collision.py\n# HumanEval problem HumanEval/41\n\ndef car_race_collision(n: int):\n    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n    \"\"\"\n    return n**2\n\n# Test function\n\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n\n\n# Run tests\nif __name__ == \"__main__\":\n    check(car_race_collision)\n    print(\"All tests passed!\")",
  "gold_reference_lean4_code": "/-!\n# VeriBench – Car Race Collision\n\nFile order:\n\n1. Implementation\n2. Unit tests (positive, edge, positive/negative test suite)\n3. Pre‑condition prop\n4. Exhaustive property prop and their theorems\n5. Post‑condition prop (same order as property props)\n6. Correctness theorem `Pre → Post`\n7. Imperative i. implementation, ii. tests (positive, edge, positive/negative\ntest suite), and iii. equivalence theorem.\n\nAll real proofs are left as `sorry` for the learner/model/agent.\n\n# Implementation\n\n## Car Race Collision\n\nImplements `carRaceCollision` which counts the number of collisions between two sets of cars\nmoving in opposite directions on an infinite straight road.-/\n\nnamespace CarRaceCollision\n\n/--\n**Implementation of `carRaceCollision`.**\n\n`carRaceCollision n` returns the number of collisions between n cars moving left-to-right\nand n cars moving right-to-left, where each car collides with every car\nfrom the opposite direction.\n\nThe number of collisions is n² since each car from the left-to-right set collides with\nevery car from the right-to-left set.\n\n## Examples\n\n#eval carRaceCollision 2  -- expected: 4\n#eval carRaceCollision 3  -- expected: 9\n#eval carRaceCollision 4  -- expected: 16\n-/\ndef carRaceCollision (n : Nat) : Nat :=\n  n * n\n\n/-!\n# Tests\n-/\n\n/-- expected: 4 -/\nexample : carRaceCollision 2 = 4 := by native_decide\n#eval carRaceCollision 2 -- expected: 4\n\n/-- expected: 9 -/\nexample : carRaceCollision 3 = 9 := by native_decide\n#eval carRaceCollision 3 -- expected: 9\n\n/-!\n# Tests: Edge Cases\n-/\n\n/-- expected: 0 -/\nexample : carRaceCollision 0 = 0 := by native_decide\n#eval carRaceCollision 0 -- expected: 0\n\n/-- expected: 1 -/\nexample : carRaceCollision 1 = 1 := by native_decide\n#eval carRaceCollision 1 -- expected: 1\n\n/-!\n# Positive / Negative Test‑Suite\n-/\n\n/-- positive test: larger case -/\nexample : carRaceCollision 4 = 16 := by native_decide\n#eval carRaceCollision 4 -- expected: 16\n\n/-- positive test: monotonicity -/\nexample : carRaceCollision 2 < carRaceCollision 3 := by native_decide\n\n/-- negative test: not linear growth -/\nexample : ¬ (carRaceCollision 3 = 3 * carRaceCollision 1) := by native_decide\n\n/-- negative test: different inputs give different results -/\nexample : carRaceCollision 2 ≠ carRaceCollision 3 := by native_decide\n\n/-!\n# Pre‑Condition\n-/\n\n/-- **Pre‑condition.** Any natural number is valid input. -/\ndef Pre (_ : Nat) : Prop := True\n\n/-!\n# Property Theorems\n-/\n\n/-- **Zero case property**: Zero cars means zero collisions. -/\ndef zero_case_prop : Prop := carRaceCollision 0 = 0\n\n/-- **Zero case theorem**: Zero cars means zero collisions. -/\n@[simp] theorem zero_case_thm : zero_case_prop := sorry\n\n/-- **One case property**: One car in each direction means one collision. -/\ndef one_case_prop : Prop := carRaceCollision 1 = 1\n\n/-- **One case theorem**: One car in each direction means one collision. -/\n@[simp] theorem one_case_thm : one_case_prop := sorry\n\n/-- **Square formula property**: Number of collisions equals n². -/\ndef square_formula_prop (n : Nat) : Prop := carRaceCollision n = n * n\n\n/-- **Square formula theorem**: Number of collisions equals n². -/\n@[simp] theorem square_formula_thm (n : Nat) : square_formula_prop n := sorry\n\n/-- **Monotonicity property**: More cars means more or equal collisions. -/\ndef monotonicity_prop (n m : Nat) : Prop := n ≤ m → carRaceCollision n ≤ carRaceCollision m\n\n/-- **Monotonicity theorem**: More cars means more or equal collisions. -/\n@[simp] theorem monotonicity_thm (n m : Nat) : monotonicity_prop n m := sorry\n\n/-!\n# Post‑Condition  (conjunction of all desired properties)\n-/\n\n/-- **Post‑condition**: conjunction of all desired properties for carRaceCollision. -/\ndef Post_prop (n : Nat) : Prop :=\n  (zero_case_prop) ∧                                     -- zero case property\n  (one_case_prop) ∧                                      -- one case property\n  (square_formula_prop n) ∧                              -- square formula property\n  (∀ m, monotonicity_prop n m)                           -- monotonicity property\n\n/-!\n# Correctness Theorem\n-/\n\n/-- **Correctness theorem**: the pre‑condition implies the post‑condition. -/\ntheorem correctness_thm (n : Nat) (hPre : Pre n) : Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\n`carRaceCollisionImp n` computes the same result using imperative style with a single loop.\nEach car from the left-to-right set collides with every car from the right-to-left set,\nso we can simply add n to the total n times.\n-/\ndef carRaceCollisionImp (n : Nat) : Nat :=\n  Id.run do\n    let mut total := 0\n    for _ in [:n] do\n      total := total + n\n    return total\n\n/-!\n# Imperative Tests\n-/\n\n/-- expected: 4 -/\nexample : carRaceCollisionImp 2 = 4 := by native_decide\n#eval carRaceCollisionImp 2 -- expected: 4\n\n/-!\n# Imperative Tests: Edge Cases\n-/\n\n/-- expected: 9 -/\nexample : carRaceCollisionImp 3 = 9 := by native_decide\n#eval carRaceCollisionImp 3 -- expected: 9\n\n/-!\n# Positive / Negative Test‑Suite\n-/\n\n/-- positive test: zero case -/\nexample : carRaceCollisionImp 0 = 0 := by native_decide\n#eval carRaceCollisionImp 0 -- expected: 0\n\n/-- negative test: not linear -/\nexample : ¬ (carRaceCollisionImp 4 = 4) := by native_decide\n\n/-- **Equivalence theorem**: functional and imperative implementations coincide. -/\ntheorem carRaceCollision_equivalence_thm (n : Nat) :\n  carRaceCollision n = carRaceCollisionImp n := sorry\n\nend CarRaceCollision\n"
}