{
  "task_id": 75,
  "python_code": "# File: humaneval_30_get_positive.py\n# HumanEval problem HumanEval/30\n\ndef get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return [e for e in l if e > 0]\n\n# Test function\n\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n\n\n# Run tests\nif __name__ == \"__main__\":\n    check(get_positive)\n    print(\"All tests passed!\")",
  "gold_reference_lean4_code": "/-!\n\n# VeriBench – Get Positive\n\nFile order:\n\n1. Implementation\n2. Unit tests (positive, edge, positive/negative test suite)\n3. Pre‑condition prop\n4. Exhaustive property prop and their theorems\n5. Post‑condition prop (same order as property props)\n6. Correctness theorem `Pre → Post`\n7. Imperative i. implementation, ii. tests (positive, edge, positive/negative\ntest suite), and iii. equivalence theorem.\n\nAll real proofs are left as `sorry` for the learner/model/agent.\n\n# Implementation\n\n## Get Positive\n\nImplements `get_positive`, which filters a list to return only positive integers.-/\n\nnamespace PositiveFilter\n\n/--\n**Implementation of `get_positive`.**\n\nTakes a list of integers and returns a new list containing only the positive\nnumbers (greater than 0). If the input list is empty, returns an empty list.\nThe order of elements is preserved.\n\n## Examples\n\n#eval get_positive [-1, 2, -4, 5, 6] -- expected: [2, 5, 6]\n#eval get_positive [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10] -- expected: [5, 3, 2, 3, 9, 123, 1]\n-/\ndef get_positive (l : List Int) : List Int :=\n  l.filter (λ x => x > 0)\n\n/-!\n# Tests\n-/\n\n/-- expected: [2, 5, 6] -/\nexample : get_positive [-1, 2, -4, 5, 6] = [2, 5, 6] := by sorry\n#eval get_positive [-1, 2, -4, 5, 6]\n\n/-- expected: [5, 3, 2, 3, 9, 123, 1] -/\nexample : get_positive [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10] = [5, 3, 2, 3, 9, 123, 1] := by sorry\n#eval get_positive [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]\n\n/-!\n# Tests: Edge Cases\n-/\n\n/-- expected: [4, 5, 6] -/\nexample : get_positive [-1, -2, 4, 5, 6] = [4, 5, 6] := by sorry\n#eval get_positive [-1, -2, 4, 5, 6]\n\n/-- expected: [] -/\nexample : get_positive [-1, -2] = [] := by sorry\n#eval get_positive [-1, -2]\n\n/-!\n# Positive / Negative Test‑Suite\n-/\n\n/-- positive: empty list -/\nexample : get_positive [] = [] := by sorry\n#eval get_positive [] -- expected: []\n\n/-- positive: mixed with zero -/\nexample : get_positive [0, 1, -1, 2, -2] = [1, 2] := by sorry\n#eval get_positive [0, 1, -1, 2, -2] -- expected: [1, 2]\n\n/-- negative: zero is not positive -/\nexample : ¬ (get_positive [0, -1] = [0]) := by sorry\n#eval (decide (get_positive [0, -1] = [0])) -- expected: false\n\n/-- negative: negative numbers are filtered out -/\nexample : ¬ (get_positive [-1, 2, -3] = [-1, 2, -3]) := by sorry\n#eval (decide (get_positive [-1, 2, -3] = [-1, 2, -3])) -- expected: false\n\n/-!\n# Pre‑Condition\n-/\n\n/-- **Pre‑condition.** Any list of integers is valid input. -/\ndef Pre (l : List Int) : Prop := True\n\n/-!\n# Property Theorems\n-/\n\n/-- **Empty list property**: Empty list returns empty list. -/\ndef empty_list_prop : Prop := get_positive [] = []\n\n/-- **Empty list theorem**: Empty list returns empty list. -/\n@[simp] theorem empty_list_thm : empty_list_prop := sorry\n\n/-- **Positive only property**: All elements in result are positive. -/\ndef positive_only_prop (l : List Int) : Prop :=\n  ∀ x ∈ get_positive l, x > 0\n\n/-- **Positive only theorem**: All elements in result are positive. -/\n@[simp] theorem positive_only_thm (l : List Int) : positive_only_prop l := sorry\n\n/-- **Subset property**: Result is a subset of input. -/\ndef subset_prop (l : List Int) : Prop :=\n  ∀ x ∈ get_positive l, x ∈ l\n\n/-- **Subset theorem**: Result is a subset of input. -/\n@[simp] theorem subset_thm (l : List Int) : subset_prop l := sorry\n\n/-- **Order preservation property**: Order of positive elements is preserved. -/\ndef order_preservation_prop (l : List Int) : Prop :=\n  ∀ x y, x ∈ get_positive l → y ∈ get_positive l →\n    l.idxOf x < l.idxOf y →\n    (get_positive l).idxOf x < (get_positive l).idxOf y\n\n/-- **Order preservation theorem**: Order of positive elements is preserved. -/\n@[simp] theorem order_preservation_thm (l : List Int) : order_preservation_prop l := sorry\n\n/-- **Completeness property**: All positive elements from input are included. -/\ndef completeness_prop (l : List Int) : Prop :=\n  ∀ x ∈ l, x > 0 → x ∈ get_positive l\n\n/-- **Completeness theorem**: All positive elements from input are included. -/\n@[simp] theorem completeness_thm (l : List Int) : completeness_prop l := sorry\n\n/-!\n# Post‑Condition  (conjunction of all desired properties)\n-/\n\n/-- **Post‑condition**: conjunction of all desired properties for get_positive. -/\ndef Post_prop (l : List Int) : Prop :=\n  (empty_list_prop) ∧                                    -- empty_list_prop\n  (positive_only_prop l) ∧                               -- positive_only_prop\n  (subset_prop l) ∧                                      -- subset_prop\n  (order_preservation_prop l) ∧                          -- order_preservation_prop\n  (completeness_prop l)                                  -- completeness_prop\n\n/-!\n# Correctness Theorem\n-/\n\n/-- **Correctness theorem**: the pre‑condition implies the post‑condition. -/\ntheorem correctness_thm (l : List Int) (hPre : Pre l) : Post_prop l := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\n`get_positiveImp l` computes the same result using imperative style with explicit loops.\n-/\ndef get_positiveImp (l : List Int) : List Int :=\n  Id.run do\n    let mut result : List Int := []\n    for x in l do\n      if x > 0 then\n        result := result ++ [x]\n    return result\n\n/-!\n# Imperative Tests\n-/\n\n/-- expected: [2, 5, 6] -/\nexample : get_positiveImp [-1, 2, -4, 5, 6] = [2, 5, 6] := by sorry\n#eval get_positiveImp [-1, 2, -4, 5, 6]\n\n/-!\n# Imperative Tests: Edge Cases\n-/\n\n/-- expected: [] -/\nexample : get_positiveImp [] = [] := by sorry\n#eval get_positiveImp []\n\n/-- expected: [1, 2] -/\nexample : get_positiveImp [0, 1, -1, 2, -2] = [1, 2] := by sorry\n#eval get_positiveImp [0, 1, -1, 2, -2]\n\n/-!\n# Positive / Negative Test‑Suite\n-/\n\n/-- positive: all positive numbers -/\nexample : get_positiveImp [1, 2, 3, 4] = [1, 2, 3, 4] := by sorry\n#eval get_positiveImp [1, 2, 3, 4] -- expected: [1, 2, 3, 4]\n\n/-- negative: doesn't include zero or negative -/\nexample : ¬ (get_positiveImp [-1, 0, 1] = [-1, 0, 1]) := by sorry\n#eval (decide (get_positiveImp [-1, 0, 1] = [-1, 0, 1])) -- expected: false\n\n/-- **Equivalence theorem**: functional and imperative implementations coincide. -/\ntheorem get_positive_equivalence_thm (l : List Int) :\n  get_positive l = get_positiveImp l := sorry\n\nend PositiveFilter\n"
}