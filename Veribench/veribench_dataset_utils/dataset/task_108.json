{
  "task_id": 108,
  "python_code": "from typing import Callable, Iterable, List, Optional, TypeVar\n\nT = TypeVar(\"T\")\nK = TypeVar(\"K\")\n\n\ndef bisect_left(a: List[T], x: K, lo: int = 0, hi: Optional[int] = None, *, key: Optional[Callable[[T], K]] = None) -> int:\n    \"\"\"\n    Return the index where to insert item x in list a, assuming a is sorted.\n\n    The return value i is such that all e in a[:i] have e < x, and all e in\n    a[i:] have e >= x.  So if x already appears in the list, a.insert(i, x) will\n    insert just before the leftmost x already there.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n\n    A custom key function can be supplied to customize the sort order.\n\n    >>> bisect_left([1,2,4,4,10], 4)\n    2\n    >>> bisect_left([\"A\",\"bb\",\"CC\",\"ddd\"], 2, key=len)\n    1\n    \"\"\"\n    if lo < 0:\n        raise ValueError(\"lo must be non-negative\")\n    if hi is None:\n        hi = len(a)\n    # Note, the comparison uses \"<\" to match list.sort() / heapq semantics.\n    if key is None:\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if a[mid] < x:            # compare in element space\n                lo = mid + 1\n            else:\n                hi = mid\n    else:\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if key(a[mid]) < x:       # compare in key space\n                lo = mid + 1\n            else:\n                hi = mid\n    return lo\n\n\ndef insort_left(a: List[T], x: T, lo: int = 0, hi: Optional[int] = None, *, key: Optional[Callable[[T], K]] = None) -> None:\n    \"\"\"\n    Insert item x in list a, and keep it sorted assuming a is sorted.\n\n    If x is already in a, insert it to the left of the leftmost x.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n\n    A custom key function can be supplied to customize the sort order.\n\n    >>> lst = [1,2,4,4,10]\n    >>> insort_left(lst, 4); lst\n    [1, 2, 4, 4, 4, 10]\n    >>> lst2 = [\"A\",\"bb\",\"CC\",\"ddd\"]\n    >>> insort_left(lst2, \"cC\", key=str.lower); lst2\n    ['A', 'bb', 'cC', 'CC', 'ddd']\n    \"\"\"\n    if key is None:\n        idx = bisect_left(a, x, lo, hi)\n    else:\n        idx = bisect_left(a, key(x), lo, hi, key=key)\n    a.insert(idx, x)\n\n\n# -- Tests --\nfrom typing import Callable\n\n\ndef check_bisect(candidate: Callable[[List[T], K, int, Optional[int]], int]) -> bool:\n    # Basic\n    assert candidate([1, 2, 4, 4, 10], 4, 0, None) == 2\n    assert candidate([1, 2, 4, 4, 10], 0, 0, None) == 0\n    assert candidate([1, 2, 4, 4, 10], 99, 0, None) == 5\n\n    # With key=len on strings, compare in key space\n    key = len\n    def cand_with_key(a: List[str], k: int) -> int:\n        return bisect_left(a, k, 0, None, key=key)\n\n    # lengths are [1, 2, 2, 3]\n    assert cand_with_key([\"A\",\"bb\",\"CC\",\"ddd\"], 1) == 0  # first index with len >= 1\n    assert cand_with_key([\"A\",\"bb\",\"CC\",\"ddd\"], 2) == 1  # first index with len >= 2\n    assert cand_with_key([\"A\",\"bb\",\"CC\",\"ddd\"], 3) == 3  # first index with len >= 3\n\n    return True\n\n\ndef check_insort() -> bool:\n    lst = [1, 2, 4, 4, 10]\n    insort_left(lst, 4)\n    assert lst == [1, 2, 4, 4, 4, 10]\n\n    lst2 = [\"A\",\"bb\",\"CC\",\"ddd\"]\n    insort_left(lst2, \"cC\", key=str.lower)\n    assert lst2 == [\"A\",\"bb\",\"cC\",\"CC\",\"ddd\"]\n    return True\n\n\nif __name__ == \"__main__\":\n    assert check_bisect(lambda a, x, lo, hi: bisect_left(a, x, lo, hi))\n    assert check_insort()",
  "gold_reference_lean4_code": "import Std\n\n/-!\n# VeriBench – Left-Biased Insertion Index (Insort-focused)\n\n1. Implementation\n2. Unit tests (positive, edge, keyed)\n3. Pre-condition\n4. Property theorems\n5. Post-condition (same order as theorems)\n6. Correctness theorem `Pre → Post`\n7. Insertion properties\n\nAll real proofs are left as `sorry`.\n-/\n\nnamespace Bisect\n\ndef bisect_left\n    {α γ}\n    (a   : Array α)\n    (x   : γ)\n    (lo  : Nat := 0)\n    (hi? : Option Nat := none)\n    (key?: Option (α → γ) := none)\n    [LT γ] [DecidableRel (· < · : γ → γ → Prop)]\n    [Coe α γ] [Inhabited α] :\n    Nat := Id.run do\n  let hi := hi?.getD a.size\n  match key? with\n  | none =>\n    let mut loM := lo\n    let mut hiM := hi\n    while loM < hiM do\n      let mid := (loM + hiM) / 2\n      let y : γ := (↑(a[mid]!) : γ)\n      if y < x then\n        loM := mid + 1\n      else\n        hiM := mid\n    return loM\n  | some key =>\n    let mut loM := lo\n    let mut hiM := hi\n    while loM < hiM do\n      let mid := (loM + hiM) / 2\n      let y := key (a[mid]!)\n      if y < x then\n        loM := mid + 1\n      else\n        hiM := mid\n    return loM\n\n\ndef insort_left\n    {α γ}\n    (a   : Array α)\n    (x   : α)\n    (lo  : Nat := 0)\n    (hi? : Option Nat := none)\n    (key?: Option (α → γ) := none)\n    [LT γ] [DecidableRel (· < · : γ → γ → Prop)]\n    [Coe α γ] [Inhabited α] :\n    Array α := Id.run do\n  let idx :=\n    match key? with\n    | none      => bisect_left a ((↑x : γ)) lo hi? (key? := none)\n    | some key  => bisect_left a (key x)    lo hi? (key? := some key)\n  let left  := a.extract 0 idx\n  let right := a.extract idx a.size\n  return left ++ #[x] ++ right\n\n\n\n/-!\n# Tests\n-/\n\n-- Scoped coercions so tests compile\nlocal instance : Coe Nat Nat        where coe := id\nlocal instance : Coe String String  where coe := id\n-- Use string length as the “key space” when needed\nlocal instance : Coe String Nat     where coe := fun s => s.length\n\n/-- expected: 2 -/\nexample : bisect_left (#[(1:Nat),2,4,4,10]) (4) = 2 := by native_decide\n#eval bisect_left (#[(1:Nat),2,4,4,10]) (4)  -- expected: 2\n\n/-- expected: 0 -/\nexample : bisect_left (#[(1:Nat),2,4,4,10]) (0) = 0 := by native_decide\n#eval bisect_left (#[(1:Nat),2,4,4,10]) (0)  -- expected: 0\n\n/-- expected: 5 -/\nexample : bisect_left (#[(1:Nat),2,4,4,10]) (99) = 5 := by native_decide\n#eval bisect_left (#[(1:Nat),2,4,4,10]) (99) -- expected: 5\n\n/-! Keyed (string length): lengths `[1,2,2,3]` → x=1→0, x=2→1, x=3→3. -/\n\n/-- expected: 0 -/\nexample :\n  bisect_left #[\"A\",\"bb\",\"CC\",\"ddd\"] (1) (key? := some (·.length)) = 0 := by\n  native_decide\n#eval bisect_left #[\"A\",\"bb\",\"CC\",\"ddd\"] (1) (key? := some (·.length))  -- expected: 0\n\n/-- expected: 1 -/\nexample :\n  bisect_left #[\"A\",\"bb\",\"CC\",\"ddd\"] (2) (key? := some (·.length)) = 1 := by\n  native_decide\n#eval bisect_left #[\"A\",\"bb\",\"CC\",\"ddd\"] (2) (key? := some (·.length))  -- expected: 1\n\n/-- expected: 3 -/\nexample :\n  bisect_left #[\"A\",\"bb\",\"CC\",\"ddd\"] (3) (key? := some (·.length)) = 3 := by\n  native_decide\n#eval bisect_left #[\"A\",\"bb\",\"CC\",\"ddd\"] (3) (key? := some (·.length))  -- expected: 3\n\n/-- expected: #[1,2,4,4,4,10] -/\nexample :\n  insort_left (γ := Nat) (#[(1:Nat),2,4,4,10]) 4\n    = #[(1:Nat),2,4,4,4,10] := by\n  native_decide\n#eval insort_left (γ := Nat) (#[(1:Nat),2,4,4,10]) 4  -- expected: #[1,2,4,4,4,10]\n\n/-- expected: #[\"A\",\"bb\",\"cC\",\"CC\",\"ddd\"] -/\nexample :\n  insort_left #[\"A\",\"bb\",\"CC\",\"ddd\"] \"cC\" (key? := some (fun s => s.toLower))\n    = #[\"A\",\"bb\",\"cC\",\"CC\",\"ddd\"] := by\n  native_decide\n#eval insort_left #[\"A\",\"bb\",\"CC\",\"ddd\"] \"cC\" (key? := some (fun s => s.toLower))\n-- expected: #[\"A\",\"bb\",\"cC\",\"CC\",\"ddd\"]\n\n\n\n/-!\n# Pre-Condition (slice sortedness)\n-/\n\n/-- Default projection when no key is provided. -/\ndef defaultProjL {α : Type u} {γ : Type v} [Coe α γ] : α → γ :=\n  fun a => (↑a : γ)\n\n/-- Project into key space (uses `key` if provided, else coercion). -/\ndef ProjL {α : Type u} {γ : Type v} (key? : Option (α → γ)) [Coe α γ] : α → γ :=\n  key?.elim defaultProjL id\n\n/-- `SortedSliceL a lo hi proj` means `a[lo:hi]` is nondecreasing under `proj`. -/\ndef SortedSliceL {α : Type u} {γ : Type v}\n    (a : Array α) (lo hi : Nat) (proj : α → γ)\n    [LE γ] [DecidableRel (· ≤ · : γ → γ → Prop)] [Inhabited α] : Prop :=\n  ∀ i j, lo ≤ i → i ≤ j → j < hi → proj (a[i]!) ≤ proj (a[j]!)\n\n/-- Bounds + sortedness precondition for `insort_left` on `a[lo:hi]`. -/\ndef PreL {α : Type u} {γ : Type v}\n    (a : Array α) (lo hi : Nat) (key? : Option (α → γ))\n    [LE γ] [DecidableRel (· ≤ · : γ → γ → Prop)] [Coe α γ] [Inhabited α] : Prop :=\n  lo ≤ hi ∧ hi ≤ a.size ∧ SortedSliceL a lo hi (ProjL key?)\n\n\n\n/-!\n# Insertion Theorems (only for `insort_left`)\n-/\n\n/-- **Splice shape**: `insort_left` equals `left.push x ++ right` at the bisect index. -/\ntheorem insort_splice_shape_left\n    {α γ} [LT γ] [DecidableRel (· < · : γ → γ → Prop)]\n    [Coe α γ] [Inhabited α]\n    (a : Array α) (xα : α) (lo : Nat) (hi? : Option Nat) (key? : Option (α → γ)) :\n  let idx :=\n    match key? with\n    | none     => bisect_left a ((↑xα : γ)) lo hi? (key? := none)\n    | some key => bisect_left a (key xα)       lo hi? (key? := some key)\n  insort_left a xα lo hi? key? =\n    (a.extract 0 idx).push xα ++ a.extract idx a.size := by\n  intro idx\n  simp [insort_left, idx]\n  rfl\n\n/-- **Sortedness preserved on the slice (left)**:\nIf `a[lo:hi]` was sorted in key space, inserting at the bisect index keeps it sorted. -/\ntheorem insort_preserves_sorted_slice_left\n    {α γ}\n    [LT γ] [DecidableRel (· < · : γ → γ → Prop)]\n    [LE γ] [DecidableRel (· ≤ · : γ → γ → Prop)]\n    [Coe α γ] [Inhabited α]\n    (a : Array α) (xα : α) (lo : Nat) (hi? : Option Nat) (key? : Option (α → γ))\n    (hpre : PreL a lo (hi?.getD a.size) key?) :\n    let proj := ProjL key?\n    let x  := match key? with | none => (↑xα : γ) | some key => key xα\n    let i  := bisect_left a x lo hi? key?\n    let a' := insort_left a xα lo hi? key?;\n    SortedSliceL a' lo (i+1) proj ∧\n    SortedSliceL a' (i+1) (hi?.getD a.size + 1) proj := by\n  intro; intro; intro; intro; sorry\n\n/-- **Insert partition (left)**:\nAfter `insort_left`, elements before `i` are `< x` and elements at/after `i+1` are `≥ x`. -/\ntheorem insort_partition_after_insert_left\n    {α γ}\n    [LT γ] [DecidableRel (· < · : γ → γ → Prop)]\n    [LE γ] [DecidableRel (· ≤ · : γ → γ → Prop)]\n    [Coe α γ] [Inhabited α]\n    (a : Array α) (xα : α) (lo : Nat) (hi? : Option Nat) (key? : Option (α → γ))\n    (hpre : PreL a lo (hi?.getD a.size) key?) :\n    let proj := ProjL key?\n    let x := match key? with | none => (↑xα : γ) | some key => key xα\n    let i := bisect_left a x lo hi? key?\n    let a' := insort_left a xα lo hi? key?;\n    (∀ j, lo ≤ j → j < i → proj (a'[j]!) < x) ∧\n    (∀ j, i+1 ≤ j → j < a'.size → x ≤ proj (a'[j]!)) := by\n  sorry\n\nend Bisect\n"
}