{
  "task_id": 110,
  "python_code": "# -- Implementation --\n# source: https://github.com/python/cpython/blob/3.13/Lib/heapq.py\n\n\ndef _siftdown(heap, startpos, pos):\n    newitem = heap[pos]\n    # Follow the path to the root, moving parents down until finding a place\n    # newitem fits.\n    while pos > startpos:\n        parentpos = (pos - 1) >> 1\n        parent = heap[parentpos]\n        if newitem < parent:\n            heap[pos] = parent\n            pos = parentpos\n            continue\n        break\n    heap[pos] = newitem\n\n\ndef _siftup(heap, pos):\n    endpos = len(heap)\n    startpos = pos\n    newitem = heap[pos]\n    # Bubble up the smaller child until hitting a leaf.\n    childpos = 2 * pos + 1  # leftmost child position\n    while childpos < endpos:\n        # Set childpos to index of smaller child.\n        rightpos = childpos + 1\n        if rightpos < endpos and not heap[childpos] < heap[rightpos]:\n            childpos = rightpos\n        # Move the smaller child up.\n        heap[pos] = heap[childpos]\n        pos = childpos\n        childpos = 2 * pos + 1\n    # The leaf at pos is empty now.  Put newitem there, and bubble it up\n    # to its final resting place (by sifting its parents down).\n    heap[pos] = newitem\n    _siftdown(heap, startpos, pos)\n\n\ndef heappop(heap):\n    \"\"\"Pop the smallest item off the heap, maintaining the heap invariant.\"\"\"\n    lastelt = heap.pop()  # raises appropriate IndexError if heap is empty\n    if heap:\n        returnitem = heap[0]\n        heap[0] = lastelt\n        _siftup(heap, 0)\n        return returnitem\n    return lastelt\n\n\n# -- Tests --\nfrom typing import Callable\nimport random\n\n\ndef _check_invariant(heap):\n    # Check the min-heap invariant: for every node, its value <= each child's value.\n    for pos, item in enumerate(heap):\n        if pos:  # pos 0 has no parent\n            parentpos = (pos - 1) >> 1\n            assert heap[parentpos] <= item, (\n                f\"heap invariant violated at pos={pos}: \"\n                f\"parent {heap[parentpos]} > child {item}\"\n            )\n\n\ndef check(candidate: Callable[[list], int]) -> bool:\n    # Basic unit tests\n    h = [3, 1, 2]\n    import heapq as py_heapq\n\n    py_heapq.heapify(h)\n    _check_invariant(h)\n    popped = candidate(h)\n    _check_invariant(h)\n    assert popped == 1, f\"expected pop == 1 but got {popped}\"\n\n    # Edge unit test: pop single-element heap\n    h = [5]\n    popped = candidate(h)\n    assert popped == 5 and h == [], (\n        f\"expected pop 5 and empty heap but got {popped}, {h}\"\n    )\n\n    # Property check: push 256 random numbers and then pop them all in sorted order\n    data = [random.random() for _ in range(256)]\n    h = []\n    for x in data:\n        py_heapq.heappush(h, x)\n        _check_invariant(h)\n    results = []\n    while h:\n        results.append(candidate(h))\n        _check_invariant(h)\n    assert results == sorted(data), \"heappop did not return sorted sequence\"\n\n    # Error behavior: pop from empty list should raise IndexError\n    try:\n        candidate([])\n        assert False, \"heappop([]) should raise IndexError\"\n    except IndexError:\n        pass\n\n    # Passing None should raise (TypeError or AttributeError)\n    try:\n        candidate(None)  # type: ignore[arg-type]\n        assert False, \"heappop(None) should raise\"\n    except (AttributeError, TypeError):\n        pass\n\n    return True\n\n\nif __name__ == \"__main__\":\n    assert check(heappop), f\"Failed: {__file__}\"",
  "gold_reference_lean4_code": "/-!\n# VeriBench – Heappop (min-heap)\n\nFile order:\n\n1. Implementation (`_siftdown`, `_siftup`, `heappop`)\n2. Unit tests (basic, edge)\n3. Pre-condition\n4. Property propositions\n5. Post-condition (same order as properties)\n6. Correctness theorem `Pre → Post`\n\nAll nontrivial proofs are left as `sorry` for the learner/model/agent.\n-/\n\nnamespace HeapPop\n\n/--\n`_siftdown`\n\nGiven:\n* `heap` : a min-heap at all indices ≥ `startpos` except possibly at `pos`\n* `startpos` : root of the sifted subtree (usually `0`)\n* `pos` : index of a leaf whose value may violate the heap invariant\n\nRestores the heap invariant by moving parents down until a slot for `newitem`\nis found, then writes `newitem` once.\n-/\ndef _siftdown (heap : Array Int) (startpos pos : Nat) : Array Int :=\n  let newitem := heap[pos]!\n  let rec loop (h : Array Int) (pos : Nat) : Array Int :=\n    if pos > startpos then\n      let parentpos := (pos - 1) >>> 1\n      let parent := h[parentpos]!\n      if newitem < parent then\n        let h' := h.set! pos parent\n        loop h' parentpos\n      else\n        h.set! pos newitem\n    else\n      h.set! pos newitem\n  loop heap pos\n\n/--\n`_siftup`\n\nBubbles the smaller child up until reaching a leaf, then places `newitem`\nand calls `_siftdown` to give it a final resting place.\n-/\npartial def _siftup (heap : Array Int) (pos : Nat) : Array Int :=\n  let endpos := heap.size\n  let startpos := pos\n  let newitem := heap[pos]!\n  -- Bubble down by moving the smaller child up.\n  let rec loop (h : Array Int) (pos : Nat) : Array Int :=\n    let childpos := (2 * pos) + 1  -- leftmost child\n    if childpos < endpos then\n      let rightpos := childpos + 1\n      -- choose the smaller child\n      let childpos' :=\n        if rightpos < endpos ∧ ¬ (h[childpos]! < h[rightpos]!) then rightpos else childpos\n      -- move smaller child up\n      let h' := h.set! pos h[childpos']!\n      loop h' childpos'\n    else\n      -- leaf: put newitem, then sift it down to final place\n      let h' := h.set! pos newitem\n      _siftdown h' startpos pos\n  loop heap pos\n\n/--\n`heappop`\nPop the smallest item and maintain the heap invariant.\nReturns the popped item and the resulting heap.\n-/\ndef heappop (heap : Array Int) : Int × Array Int :=\n  let n := heap.size\n  -- indexing will panic if empty (like raising IndexError)\n  let lastelt := heap[n - 1]!\n  let heap1   := heap.extract 0 (n - 1)   -- remove last element\n  if heap1.size > 0 then\n    let returnitem := heap1[0]!\n    let heap2 := heap1.set! 0 lastelt\n    let heap3 := _siftup heap2 0\n    (returnitem, heap3)\n  else\n    (lastelt, heap1)\n\n/-!\n# Tests\n-/\n\n/-- Boolean heap invariant checker: for every child, parent ≤ child. -/\ndef checkInvariant (h : Array Int) : Bool :=\n  let n := h.size\n  let rec go (i : Nat) : Bool :=\n    if i ≥ n then true\n    else if i = 0 then go (i+1)\n    else\n      let parent := (i - 1) >>> 1\n      if h[parent]! ≤ h[i]! then go (i+1) else false\n  go 0\n\n/-- expected: popping from heap [1,3,2] returns 1 and keeps invariant -/\nexample :\n  let r := heappop (#[(1 : Int), 3, 2])\n  r.fst = 1 ∧ checkInvariant r.snd\n:= by native_decide\n#eval (let r := heappop (#[(1 : Int), 3, 2]); (r.fst, checkInvariant r.snd))  -- expected: (1, true)\n\n/-- expected: popping single-element heap returns the element and empty heap -/\nexample :\n  let r := heappop (#[(5 : Int)])\n  r.fst = 5 ∧ r.snd.isEmpty\n:= by native_decide\n#eval (let r := heappop (#[(5 : Int)]); (r.fst, r.snd.isEmpty))  -- expected: (5, true)\n\n/-!\n# Pre-Condition\n-/\n\n/-- **Pre-condition.** The input `heap` is a non-empty min-heap. -/\ndef Pre (heap : Array Int) : Prop :=\n  checkInvariant heap = true ∧ heap.size > 0\n\n/-!\n# Property Theorems\n-/\n\n/-- **Invariant property**: result heap after `heappop` is a min-heap. -/\ndef prop_invariant (heap : Array Int) : Prop :=\n  let (_, h') := heappop heap\n  checkInvariant h' = true\n\n/-- **Invariant theorem**: `heappop` preserves the heap invariant (for non-empty heap input). -/\n@[simp] theorem invariant_thm (heap : Array Int) (hPre : Pre heap) :\n  prop_invariant heap := by\n  sorry\n\n/-- **Size property**: size decreases by one. -/\ndef prop_size (heap : Array Int) : Prop :=\n  let (_, h') := heappop heap\n  h'.size = heap.size - 1\n\n/-- **Size theorem**: `heappop` reduces the size by one. -/\n@[simp] theorem size_thm (heap : Array Int) (hPre : Pre heap) :\n  prop_size heap := by\n  sorry\n\n/-- **Multiset property**: contents are preserved up to permutation with the popped head. -/\ndef prop_multiset (heap : Array Int) : Prop :=\n  let (x, h') := heappop heap\n  List.Perm heap.toList (x :: h'.toList)\n\n/-- **Multiset theorem**: `heappop` preserves contents up to permutation. -/\n@[simp] theorem multiset_thm (heap : Array Int) (hPre : Pre heap) :\n  prop_multiset heap := by\n  -- proof left to the learner/agent\n  sorry\n\n/-!\n# Post-Condition\n-/\n\n/-- **Post-condition** for `heappop`. -/\ndef Post_prop (heap : Array Int) : Prop :=\n  prop_invariant heap ∧\n  prop_size heap ∧\n  prop_multiset heap\n\n/-!\n# Correctness Theorem\n-/\n\n/-- **Correctness theorem**: the pre-condition implies the post-condition. -/\ntheorem correctness_thm (heap : Array Int) (hPre : Pre heap) :\n  Post_prop heap := by\n  exact And.intro\n    (invariant_thm heap hPre)\n    (And.intro (size_thm heap hPre) (multiset_thm heap hPre))\n\nend HeapPop\n"
}