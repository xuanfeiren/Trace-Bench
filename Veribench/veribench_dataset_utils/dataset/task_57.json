{
  "task_id": 57,
  "python_code": "# File: humaneval_14_all_prefixes.py\n# HumanEval problem HumanEval/14\n\nfrom typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n\n# Test function\n\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n\n\n# Run tests\nif __name__ == \"__main__\":\n    check(all_prefixes)\n    print(\"All tests passed!\")",
  "gold_reference_lean4_code": "/-!\n\n# VeriBench – All Prefixes\n\nFile order:\n\n1. Implementation\n2. Unit tests (positive, edge, positive/negative test suite)\n3. Pre‑condition prop\n4. Exhaustive property prop and their theorems\n5. Post‑condition prop (same order as property props)\n6. Correctness theorem `Pre → Post`\n7. Imperative i. implementation, ii. tests (positive, edge, positive/negative\ntest suite), and iii. equivalence theorem.\n\nAll real proofs are left as `sorry` for the learner/model/agent.\n\n# Implementation\n\n## All Prefixes\n\nImplements `all_prefixes`, which generates all prefixes of a string.-/\n\nnamespace AllPrefixes\n\n/--\n**Implementation of `all_prefixes`.**\n\nReturns a list of all prefixes from shortest to longest of the input string.\nThe prefixes are ordered from shortest to longest, and include the full string\nas the last element.\n\n## Examples\n\n#eval all_prefixes \"abc\" -- expected: [\"a\", \"ab\", \"abc\"]\n#eval all_prefixes \"\" -- expected: []\n#eval all_prefixes \"WWW\" -- expected: [\"W\", \"WW\", \"WWW\"]\n-/\ndef all_prefixes (s : String) : List String :=\n  let rec build_prefixes (n : Nat) (fuel : Nat) : List String :=\n    match fuel with\n    | 0 => []\n    | fuel'+1 =>\n      if n > s.length then []\n      else (s.take n) :: build_prefixes (n+1) fuel'\n  build_prefixes 1 (s.length)\n\n/-!\n# Tests\n-/\n\n/-- expected: [\"a\", \"ab\", \"abc\"] -/\nexample : all_prefixes \"abc\" = [\"a\", \"ab\", \"abc\"] := by sorry\n#eval all_prefixes \"abc\"\n\n/-- expected: [] -/\nexample : all_prefixes \"\" = [] := by sorry\n#eval all_prefixes \"\"\n\n/-!\n# Tests: Edge Cases\n-/\n\n/-- expected: [\"W\", \"WW\", \"WWW\"] -/\nexample : all_prefixes \"WWW\" = [\"W\", \"WW\", \"WWW\"] := by sorry\n#eval all_prefixes \"WWW\"\n\n/-- expected: [\"a\"] -/\nexample : all_prefixes \"a\" = [\"a\"] := by sorry\n#eval all_prefixes \"a\"\n\n/-!\n# Positive / Negative Test‑Suite\n-/\n\n/-- positive: two characters -/\nexample : all_prefixes \"xy\" = [\"x\", \"xy\"] := by sorry\n#eval all_prefixes \"xy\" -- expected: [\"x\", \"xy\"]\n\n/-- positive: longer string -/\nexample : all_prefixes \"Hello\" = [\"H\", \"He\", \"Hel\", \"Hell\", \"Hello\"] := by sorry\n#eval all_prefixes \"Hello\" -- expected: [\"H\", \"He\", \"Hel\", \"Hell\", \"Hello\"]\n\n/-- negative: empty string doesn't produce single character -/\nexample : ¬ (all_prefixes \"\" = [\"a\"]) := by sorry\n#eval (decide (all_prefixes \"\" = [\"a\"])) -- expected: false\n\n/-- negative: doesn't include suffixes -/\nexample : ¬ (all_prefixes \"abc\" = [\"a\", \"ab\", \"abc\", \"bc\", \"c\"]) := by sorry\n#eval (decide (all_prefixes \"abc\" = [\"a\", \"ab\", \"abc\", \"bc\", \"c\"])) -- expected: false\n\n/-!\n# Pre‑Condition\n-/\n\n/-- **Pre‑condition.** Any string is valid input. -/\ndef Pre (s : String) : Prop := True\n\n/-!\n# Property Theorems\n-/\n\n/-- **Empty string property**: Empty string returns empty list. -/\ndef empty_string_prop : Prop := all_prefixes \"\" = []\n\n/-- **Empty string theorem**: Empty string returns empty list. -/\n@[simp] theorem empty_string_thm : empty_string_prop := sorry\n\n/-- **Single character property**: Single character returns list with that character. -/\ndef single_char_prop (c : Char) : Prop := all_prefixes (String.mk [c]) = [String.mk [c]]\n\n/-- **Single character theorem**: Single character returns list with that character. -/\n@[simp] theorem single_char_thm (c : Char) : single_char_prop c := sorry\n\n/-- **Length bound property**: Number of prefixes is at most string length. -/\ndef length_bound_prop (s : String) : Prop := (all_prefixes s).length ≤ s.length\n\n/-- **Length bound theorem**: Number of prefixes is at most string length. -/\n@[simp] theorem length_bound_thm (s : String) : length_bound_prop s := sorry\n\n/-- **Prefix validity property**: All returned strings are actual prefixes. -/\ndef prefix_validity_prop (s : String) : Prop :=\n  ∀ p ∈ all_prefixes s, ∃ n, s.take n = p\n\n/-- **Prefix validity theorem**: All returned strings are actual prefixes. -/\n@[simp] theorem prefix_validity_thm (s : String) : prefix_validity_prop s := sorry\n\n/-- **Ordering property**: Prefixes are ordered by increasing length. -/\ndef ordering_prop (s : String) : Prop :=\n  ∀ i j, i < j → j < (all_prefixes s).length →\n  (all_prefixes s)[i]!.length < (all_prefixes s)[j]!.length\n\n/-- **Ordering theorem**: Prefixes are ordered by increasing length. -/\n@[simp] theorem ordering_thm (s : String) : ordering_prop s := sorry\n\n/-!\n# Post‑Condition  (conjunction of all desired properties)\n-/\n\n/-- **Post‑condition**: conjunction of all desired properties for all_prefixes. -/\ndef Post_prop (s : String) : Prop :=\n  (empty_string_prop) ∧                                  -- empty_string_prop\n  (∀ c, single_char_prop c) ∧                            -- single_char_prop\n  (length_bound_prop s) ∧                                -- length_bound_prop\n  (prefix_validity_prop s) ∧                             -- prefix_validity_prop\n  (ordering_prop s)                                      -- ordering_prop\n\n/-!\n# Correctness Theorem\n-/\n\n/-- **Correctness theorem**: the pre‑condition implies the post‑condition. -/\ntheorem correctness_thm (s : String) (hPre : Pre s) : Post_prop s := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\n`all_prefixesImp s` computes the same result using imperative style with explicit loops.\n\nGenerates all prefixes of a string using an imperative\napproach with explicit loops.\n-/\ndef all_prefixesImp (s : String) : List String :=\n  Id.run do\n    let mut result := []\n    for i in [1:s.length + 1] do\n      result := result ++ [s.take i]\n    return result\n\n/-!\n# Imperative Tests\n-/\n\n/-- expected: [\"a\", \"ab\", \"abc\"] -/\nexample : all_prefixesImp \"abc\" = [\"a\", \"ab\", \"abc\"] := by sorry\n#eval all_prefixesImp \"abc\"\n\n/-!\n# Imperative Tests: Edge Cases\n-/\n\n/-- expected: [] -/\nexample : all_prefixesImp \"\" = [] := by sorry\n#eval all_prefixesImp \"\"\n\n/-- expected: [\"W\", \"WW\", \"WWW\"] -/\nexample : all_prefixesImp \"WWW\" = [\"W\", \"WW\", \"WWW\"] := by sorry\n#eval all_prefixesImp \"WWW\"\n\n/-!\n# Positive / Negative Test‑Suite\n-/\n\n/-- positive: numbers -/\nexample : all_prefixesImp \"123\" = [\"1\", \"12\", \"123\"] := by sorry\n#eval all_prefixesImp \"123\" -- expected: [\"1\", \"12\", \"123\"]\n\n/-- negative: doesn't produce empty prefix for non-empty string -/\nexample : ¬ (all_prefixesImp \"a\" = [\"\", \"a\"]) := by sorry\n#eval (decide (all_prefixesImp \"a\" = [\"\", \"a\"])) -- expected: false\n\n/-- **Equivalence theorem**: functional and imperative implementations coincide. -/\ntheorem all_prefixes_equivalence_thm (s : String) :\n  all_prefixes s = all_prefixesImp s := sorry\n\nend AllPrefixes\n"
}