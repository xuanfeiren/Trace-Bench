{
  "task_id": 90,
  "python_code": "# File: humaneval_43_pairs_sum_to_zero.py\n# HumanEval problem HumanEval/43\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n\n# Test function\n\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n\n\n# Run tests\nif __name__ == \"__main__\":\n    check(pairs_sum_to_zero)\n    print(\"All tests passed!\")",
  "gold_reference_lean4_code": "/-!\n# VeriBench – Pairs Sum to Zero\n\nFile order:\n\n1. Implementation\n2. Unit tests (positive, edge, positive/negative test suite)\n3. Pre‑condition prop\n4. Exhaustive property prop and their theorems\n5. Post‑condition prop (same order as property props)\n6. Correctness theorem `Pre → Post`\n7. Imperative i. implementation, ii. tests (positive, edge, positive/negative\ntest suite), and iii. equivalence theorem.\n\nAll real proofs are left as `sorry` for the learner/model/agent.\n\n# Implementation\n\n## Pairs Sum to Zero\n\nImplements `pairsSumToZero` which checks if there exist two distinct elements\nin a list that sum to zero.-/\n\nnamespace PairsSumToZero\n\n/--\n**Implementation of `pairsSumToZero`.**\n\n`pairsSumToZero l` returns `true` if there exist two distinct elements in the list that sum to zero,\nand `false` otherwise.\n\n## Examples\n\n#eval pairsSumToZero [1, 3, 5, 0]      -- expected: false\n#eval pairsSumToZero [2, 4, -5, 3, 5, 7] -- expected: true\n#eval pairsSumToZero [1]               -- expected: false\n-/\ndef pairsSumToZero (l : List Int) : Bool :=\n  let rec helper (i : Nat) (j : Nat) (measure : Nat) : Bool :=\n    if measure = 0 then false\n    else if j ≥ l.length then helper (i + 1) (i + 2) (measure - 1)\n    else if i ≥ l.length then false\n    else if l[i]! + l[j]! = 0 then true\n    else helper i (j + 1) (measure - 1)\n  helper 0 1 (l.length * l.length)\n\n/-!\n# Tests\n-/\n\n/-- expected: false -/\nexample : pairsSumToZero [1, 3, 5, 0] = false := by native_decide\n#eval pairsSumToZero [1, 3, 5, 0] -- expected: false\n\n/-- expected: true -/\nexample : pairsSumToZero [2, 4, -5, 3, 5, 7] = true := by native_decide\n#eval pairsSumToZero [2, 4, -5, 3, 5, 7] -- expected: true\n\n/-!\n# Tests: Edge Cases\n-/\n\n/-- expected: false -/\nexample : pairsSumToZero [1, 3, -2, 1] = false := by native_decide\n#eval pairsSumToZero [1, 3, -2, 1] -- expected: false\n\n/-- expected: false -/\nexample : pairsSumToZero [] = false := by native_decide\n#eval pairsSumToZero [] -- expected: false\n\n/-- expected: false -/\nexample : pairsSumToZero [1] = false := by native_decide\n#eval pairsSumToZero [1] -- expected: false\n\n/-!\n# Positive / Negative Test‑Suite\n-/\n\n/-- positive test: zeros sum to zero -/\nexample : pairsSumToZero [0, 0] = true := by native_decide\n#eval pairsSumToZero [0, 0] -- expected: true\n\n/-- positive test: opposites sum to zero -/\nexample : pairsSumToZero [3, -3, 1] = true := by native_decide\n#eval pairsSumToZero [3, -3, 1] -- expected: true\n\n/-- negative test: all positive -/\nexample : ¬ (pairsSumToZero [1, 2, 3, 4] = true) := by native_decide\n\n/-- negative test: all negative -/\nexample : ¬ (pairsSumToZero [-1, -2, -3] = true) := by native_decide\n\n/-!\n# Pre‑Condition\n-/\n\n/-- **Pre‑condition.** Any list of integers is valid input. -/\ndef Pre (_ : List Int) : Prop := True\n\n/-!\n# Property Theorems\n-/\n\n/-- **Empty list property**: An empty list has no pairs. -/\ndef empty_list_prop : Prop := pairsSumToZero [] = false\n\n/-- **Empty list theorem**: An empty list has no pairs. -/\n@[simp] theorem empty_list_thm : empty_list_prop := sorry\n\n/-- **Single element property**: A list with one element has no pairs. -/\ndef single_element_prop (x : Int) : Prop := pairsSumToZero [x] = false\n\n/-- **Single element theorem**: A list with one element has no pairs. -/\n@[simp] theorem single_element_thm (x : Int) : single_element_prop x := sorry\n\n/-- **All positive property**: If all elements are positive, no pair can sum to zero. -/\ndef all_positive_prop (l : List Int) : Prop :=\n  (∀ x ∈ l, x > 0) → pairsSumToZero l = false\n\n/-- **All positive theorem**: If all elements are positive, no pair can sum to zero. -/\n@[simp] theorem all_positive_thm (l : List Int) : all_positive_prop l := sorry\n\n/-- **All negative property**: If all elements are negative, no pair can sum to zero. -/\ndef all_negative_prop (l : List Int) : Prop :=\n  (∀ x ∈ l, x < 0) → pairsSumToZero l = false\n\n/-- **All negative theorem**: If all elements are negative, no pair can sum to zero. -/\n@[simp] theorem all_negative_thm (l : List Int) : all_negative_prop l := sorry\n\n/-!\n# Post‑Condition  (conjunction of all desired properties)\n-/\n\n/-- **Post‑condition**: conjunction of all desired properties for pairsSumToZero. -/\ndef Post_prop (l : List Int) : Prop :=\n  (empty_list_prop) ∧                                    -- empty list property\n  (∀ x, single_element_prop x) ∧                         -- single element property\n  (all_positive_prop l) ∧                                -- all positive property\n  (all_negative_prop l)                                  -- all negative property\n\n/-!\n# Correctness Theorem\n-/\n\n/-- **Correctness theorem**: the pre‑condition implies the post‑condition. -/\ntheorem correctness_thm (l : List Int) (hPre : Pre l) : Post_prop l := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\n`pairsSumToZeroImp l` computes the same result using imperative style with nested loops.\nThis version is more straightforward but less efficient than the functional version.\n-/\ndef pairsSumToZeroImp (l : List Int) : Bool :=\n  Id.run do\n    for i in [:l.length] do\n      for j in [:l.length] do\n        if i ≠ j ∧ l[i]! + l[j]! = 0 then\n          return true\n    return false\n\n/-!\n# Imperative Tests\n-/\n\n/-- expected: false -/\nexample : pairsSumToZeroImp [1, 3, 5, 0] = false := by native_decide\n#eval pairsSumToZeroImp [1, 3, 5, 0] -- expected: false\n\n/-!\n# Imperative Tests: Edge Cases\n-/\n\n/-- expected: true -/\nexample : pairsSumToZeroImp [2, 4, -5, 3, 5, 7] = true := by native_decide\n#eval pairsSumToZeroImp [2, 4, -5, 3, 5, 7] -- expected: true\n\n/-!\n# Positive / Negative Test‑Suite\n-/\n\n/-- positive test: empty list -/\nexample : pairsSumToZeroImp [] = false := by native_decide\n#eval pairsSumToZeroImp [] -- expected: false\n\n/-- negative test: single element -/\nexample : ¬ (pairsSumToZeroImp [42] = true) := by native_decide\n\n/-- **Equivalence theorem**: functional and imperative implementations coincide. -/\ntheorem pairsSumToZero_equivalence_thm (l : List Int) :\n  pairsSumToZero l = pairsSumToZeroImp l := sorry\n\nend PairsSumToZero\n"
}