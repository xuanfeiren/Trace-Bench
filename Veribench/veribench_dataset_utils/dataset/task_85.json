{
  "task_id": 85,
  "python_code": "# File: humaneval_39_prime_fib.py\n# HumanEval problem HumanEval/39\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n\n# Test function\n\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n\n\n# Run tests\nif __name__ == \"__main__\":\n    check(prime_fib)\n    print(\"All tests passed!\")",
  "gold_reference_lean4_code": "/-!\n# VeriBench – Prime Fibonacci Numbers\n\nFile order:\n\n1. Implementation\n2. Unit tests (positive, edge, positive/negative test suite)\n3. Pre‑condition prop\n4. Exhaustive property prop and their theorems\n5. Post‑condition prop (same order as property props)\n6. Correctness theorem `Pre → Post`\n7. Imperative i. implementation, ii. tests (positive, edge, positive/negative\ntest suite), and iii. equivalence theorem.\n\nAll real proofs are left as `sorry` for the learner/model/agent.\n\n# Implementation\n\n## Prime Fibonacci Numbers\n\nImplements a function to find the n-th number that is both a Fibonacci number and prime.-/\n\nnamespace PrimeFib\n\n/--\nChecks if a natural number is prime.\nA number is prime if it is greater than 1 and has no divisors other than 1 and itself.\n\n## Examples\n\n#eval isPrime 2  -- expected: true\n#eval isPrime 3  -- expected: true\n#eval isPrime 4  -- expected: false\n#eval isPrime 1  -- expected: false\n-/\ndef isPrime (n : Nat) : Bool :=\n  if n < 2 then false\n  else\n    let rec checkDivisors (k : Nat) (fuel : Nat) : Bool :=\n      if fuel = 0 then true\n      else if k * k > n then true\n      else if n % k = 0 then false\n      else checkDivisors (k + 1) (fuel - 1)\n    checkDivisors 2 n\n\n/--\nComputes the n-th Fibonacci number.\nF(0) = 0, F(1) = 1, F(n+2) = F(n+1) + F(n)\n\n## Examples\n\n#eval fib 0  -- expected: 0\n#eval fib 1  -- expected: 1\n#eval fib 2  -- expected: 1\n#eval fib 3  -- expected: 2\n-/\ndef fib : Nat → Nat\n  | 0 => 0\n  | 1 => 1\n  | n + 2 => fib (n + 1) + fib n\n\n/--\n**Implementation of `prime_fib`.**\n\n`prime_fib n` returns the n-th number that is both a Fibonacci number and prime.\nThe sequence starts with: 2, 3, 5, 13, 89, ...\n\n## Examples\n\n#eval prime_fib 1  -- expected: 2\n#eval prime_fib 2  -- expected: 3\n#eval prime_fib 3  -- expected: 5\n#eval prime_fib 4  -- expected: 13\n-/\ndef prime_fib (n : Nat) : Nat :=\n  let rec helper (count : Nat) (i : Nat) (n : Nat) (fuel : Nat) : Nat :=\n    if fuel = 0 then 0\n    else\n      let f := fib i\n      if isPrime f then\n        if count + 1 = n then f\n        else helper (count + 1) (i + 1) n (fuel - 1)\n      else\n        helper count (i + 1) n (fuel - 1)\n  helper 0 3 n 1000\n\n/-!\n# Tests\n-/\n\n/-- expected: 2 -/\nexample : prime_fib 1 = 2 := by sorry\n#eval prime_fib 1 -- expected: 2\n\n/-- expected: 3 -/\nexample : prime_fib 2 = 3 := by sorry\n#eval prime_fib 2 -- expected: 3\n\n/-!\n# Tests: Edge Cases\n-/\n\n/-- expected: 5 -/\nexample : prime_fib 3 = 5 := by sorry\n#eval prime_fib 3 -- expected: 5\n\n/-- expected: 13 -/\nexample : prime_fib 4 = 13 := by sorry\n#eval prime_fib 4 -- expected: 13\n\n/-- expected: 89 -/\nexample : prime_fib 5 = 89 := by sorry\n#eval prime_fib 5 -- expected: 89\n\n/-!\n# Positive / Negative Test‑Suite\n-/\n\n/-- positive test: sequence is increasing -/\nexample : prime_fib 1 < prime_fib 2 := by sorry\n#eval (prime_fib 1, prime_fib 2) -- expected: (2, 3)\n\n/-- positive test: all results are prime -/\nexample : isPrime (prime_fib 3) = true := by sorry\n#eval isPrime (prime_fib 3) -- expected: true\n\n/-- negative test: not all primes are in the sequence -/\nexample : ¬ (prime_fib 3 = 7) := by sorry\n\n/-- negative test: sequence is not dense -/\nexample : prime_fib 4 > prime_fib 3 + 1 := by sorry\n\n/-!\n# Pre‑Condition\n-/\n\n/-- **Pre‑condition.** Input must be positive. -/\ndef Pre (n : Nat) : Prop := n > 0\n\n/-!\n# Property Theorems\n-/\n\n/-- **Positivity property**: Result is always positive for positive input. -/\ndef positivity_prop (n : Nat) : Prop :=\n  n > 0 → prime_fib n > 0\n\n/-- **Positivity theorem**: Result is always positive for positive input. -/\n@[simp] theorem positivity_thm (n : Nat) : positivity_prop n := sorry\n\n/-- **Primality property**: Result is always prime. -/\ndef primality_prop (n : Nat) : Prop :=\n  n > 0 → isPrime (prime_fib n)\n\n/-- **Primality theorem**: Result is always prime. -/\n@[simp] theorem primality_thm (n : Nat) : primality_prop n := sorry\n\n/-- **Fibonacci property**: Result is a Fibonacci number. -/\ndef fibonacci_property_prop (n : Nat) : Prop :=\n  n > 0 → ∃ k, fib k = prime_fib n\n\n/-- **Fibonacci property theorem**: Result is a Fibonacci number. -/\n@[simp] theorem fibonacci_property_thm (n : Nat) : fibonacci_property_prop n := sorry\n\n/-- **Monotonicity property**: Sequence is strictly increasing. -/\ndef monotonicity_prop (n : Nat) : Prop :=\n  n > 0 → prime_fib n < prime_fib (n + 1)\n\n/-- **Monotonicity theorem**: Sequence is strictly increasing. -/\n@[simp] theorem monotonicity_thm (n : Nat) : monotonicity_prop n := sorry\n\n/-!\n# Post‑Condition  (conjunction of all desired properties)\n-/\n\n/-- **Post‑condition**: conjunction of all desired properties for prime_fib. -/\ndef Post_prop (n : Nat) : Prop :=\n  (positivity_prop n) ∧                                  -- positivity property\n  (primality_prop n) ∧                                   -- primality property\n  (fibonacci_property_prop n) ∧                          -- fibonacci property\n  (monotonicity_prop n)                                  -- monotonicity property\n\n/-!\n# Correctness Theorem\n-/\n\n/-- **Correctness theorem**: the pre‑condition implies the post‑condition. -/\ntheorem correctness_thm (n : Nat) (hPre : Pre n) : Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\n`prime_fibImp n` computes the same result using imperative style with a while loop.\n-/\ndef prime_fibImp (n : Nat) : Nat :=\n  Id.run do\n    let mut count := 0\n    let mut i := 3\n    while count < n do\n      let f := fib i\n      if isPrime f then\n        count := count + 1\n        if count = n then\n          return f\n      i := i + 1\n    return 0  -- Should never reach here for valid n\n\n/-!\n# Imperative Tests\n-/\n\n/-- expected: 2 -/\nexample : prime_fibImp 1 = 2 := by sorry\n#eval prime_fibImp 1 -- expected: 2\n\n/-!\n# Imperative Tests: Edge Cases\n-/\n\n/-- expected: 3 -/\nexample : prime_fibImp 2 = 3 := by sorry\n#eval prime_fibImp 2 -- expected: 3\n\n/-!\n# Positive / Negative Test‑Suite\n-/\n\n/-- positive test: matches functional version -/\nexample : prime_fibImp 3 = 5 := by sorry\n#eval prime_fibImp 3 -- expected: 5\n\n/-- negative test: not zero for valid input -/\nexample : ¬ (prime_fibImp 1 = 0) := by sorry\n\n/-- **Equivalence theorem**: functional and imperative implementations coincide. -/\ntheorem prime_fib_equivalence_thm (n : Nat) :\n  prime_fib n = prime_fibImp n := sorry\n\nend PrimeFib\n"
}