{
  "task_id": 91,
  "python_code": "# File: humaneval_44_change_base.py\n# HumanEval problem HumanEval/44\n\ndef change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n\n# Test function\n\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n\n\n# Run tests\nif __name__ == \"__main__\":\n    check(change_base)\n    print(\"All tests passed!\")",
  "gold_reference_lean4_code": "/-!\n# VeriBench – Change Base\n\nFile order:\n\n1. Implementation\n2. Unit tests (positive, edge, positive/negative test suite)\n3. Pre‑condition prop\n4. Exhaustive property prop and their theorems\n5. Post‑condition prop (same order as property props)\n6. Correctness theorem `Pre → Post`\n7. Imperative i. implementation, ii. tests (positive, edge, positive/negative\ntest suite), and iii. equivalence theorem.\n\nAll real proofs are left as `sorry` for the learner/model/agent.\n\n# Implementation\n\n## Change Base\n\nImplements `change_base` which converts a number from decimal (base 10) to another base.-/\n\nnamespace ChangeBase\n\n/--\n**Implementation of `change_base`.**\n\n`change_base x base` converts a natural number `x` from decimal (base 10) to a string representation\nin the specified `base`. The base must be at least 2.\n\n## Examples\n\n#eval change_base 8 3    -- expected: \"22\"\n#eval change_base 9 3    -- expected: \"100\"\n#eval change_base 234 2  -- expected: \"11101010\"\n-/\npartial def change_base (x base : Nat) : String :=\n  if x = 0 then\n    \"0\"\n  else if base ≤ 1 then\n    \"0\"\n  else\n    let rec aux (n : Nat) (acc : String) : String :=\n      if n = 0 then\n        acc\n      else\n        aux (n / base) (toString (n % base) ++ acc)\n    aux x \"\"\n\n/-!\n# Tests\n-/\n\n/-- expected: \"22\" -/\nexample : change_base 8 3 = \"22\" := by native_decide\n#eval change_base 8 3 -- expected: \"22\"\n\n/-- expected: \"100\" -/\nexample : change_base 9 3 = \"100\" := by native_decide\n#eval change_base 9 3 -- expected: \"100\"\n\n/-!\n# Tests: Edge Cases\n-/\n\n/-- expected: \"11101010\" -/\nexample : change_base 234 2 = \"11101010\" := by native_decide\n#eval change_base 234 2 -- expected: \"11101010\"\n\n/-- expected: \"0\" -/\nexample : change_base 0 2 = \"0\" := by native_decide\n#eval change_base 0 2 -- expected: \"0\"\n\n/-- expected: \"1\" -/\nexample : change_base 1 2 = \"1\" := by native_decide\n#eval change_base 1 2 -- expected: \"1\"\n\n/-!\n# Positive / Negative Test‑Suite\n-/\n\n/-- positive test: base 2 -/\nexample : change_base 2 2 = \"10\" := by native_decide\n#eval change_base 2 2 -- expected: \"10\"\n\n/-- positive test: larger base -/\nexample : change_base 15 16 = \"15\" := by native_decide\n#eval change_base 15 16 -- expected: \"15\"\n\n/-- negative test: different bases give different results -/\nexample : change_base 8 2 ≠ change_base 8 3 := by native_decide\n\n/-- negative test: not the identity for base 10 -/\nexample : ¬ (change_base 123 10 = \"123\") := by sorry\n\n/-!\n# Pre‑Condition\n-/\n\n/-- **Pre‑condition.** Base must be at least 2. -/\ndef Pre (x base : Nat) : Prop := base ≥ 2\n\n/-!\n# Property Theorems\n-/\n\n/-- **Zero property**: Converting zero to any base yields \"0\". -/\ndef zero_prop (b : Nat) : Prop := change_base 0 b = \"0\"\n\n/-- **Zero theorem**: Converting zero to any base yields \"0\". -/\n@[simp] theorem zero_thm (b : Nat) : zero_prop b := sorry\n\n/-- **One property**: Converting one to any base ≥ 2 yields \"1\". -/\ndef one_prop (b : Nat) : Prop := b > 1 → change_base 1 b = \"1\"\n\n/-- **One theorem**: Converting one to any base ≥ 2 yields \"1\". -/\n@[simp] theorem one_thm (b : Nat) : one_prop b := sorry\n\n/-- **Length property**: The length of the result is at least 1. -/\ndef length_prop (x b : Nat) : Prop := b > 1 → (change_base x b).length ≥ 1\n\n/-- **Length theorem**: The length of the result is at least 1. -/\n@[simp] theorem length_thm (x b : Nat) : length_prop x b := sorry\n\n/-- **Non-empty property**: Result is never empty. -/\ndef non_empty_prop (x b : Nat) : Prop := b ≥ 2 → change_base x b ≠ \"\"\n\n/-- **Non-empty theorem**: Result is never empty. -/\n@[simp] theorem non_empty_thm (x b : Nat) : non_empty_prop x b := sorry\n\n/-!\n# Post‑Condition  (conjunction of all desired properties)\n-/\n\n/-- **Post‑condition**: conjunction of all desired properties for change_base. -/\ndef Post_prop (x base : Nat) : Prop :=\n  (zero_prop base) ∧                                     -- zero property\n  (one_prop base) ∧                                      -- one property\n  (length_prop x base) ∧                                 -- length property\n  (non_empty_prop x base)                                -- non-empty property\n\n/-!\n# Correctness Theorem\n-/\n\n/-- **Correctness theorem**: the pre‑condition implies the post‑condition. -/\ntheorem correctness_thm (x base : Nat) (hPre : Pre x base) : Post_prop x base := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\n`change_baseImp x base` computes the same result using imperative style with a mutable string builder.\nThis version is more efficient as it avoids string concatenation.\n-/\ndef change_baseImp (x base : Nat) : String :=\n  Id.run do\n    if x = 0 then\n      return \"0\"\n    let mut n := x\n    let mut result : List Char := []\n    while n > 0 do\n      result := (Char.ofNat (n % base + '0'.toNat)) :: result\n      n := n / base\n    return String.mk result\n\n/-!\n# Imperative Tests\n-/\n\n/-- expected: \"22\" -/\nexample : change_baseImp 8 3 = \"22\" := by native_decide\n#eval change_baseImp 8 3 -- expected: \"22\"\n\n/-!\n# Imperative Tests: Edge Cases\n-/\n\n/-- expected: \"11101010\" -/\nexample : change_baseImp 234 2 = \"11101010\" := by native_decide\n#eval change_baseImp 234 2 -- expected: \"11101010\"\n\n/-!\n# Positive / Negative Test‑Suite\n-/\n\n/-- positive test: zero case -/\nexample : change_baseImp 0 2 = \"0\" := by native_decide\n#eval change_baseImp 0 2 -- expected: \"0\"\n\n/-- negative test: different from decimal -/\nexample : ¬ (change_baseImp 10 2 = \"10\") := by native_decide\n\n/-- **Equivalence theorem**: functional and imperative implementations coincide. -/\ntheorem change_base_equivalence_thm (x base : Nat) :\n  change_base x base = change_baseImp x base := sorry\n\nend ChangeBase\n"
}