{
  "task_id": 62,
  "python_code": "# File: humaneval_19_sort_numbers.py\n# HumanEval problem HumanEval/19\n\nfrom typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Input is a space-delimited string of numberals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n\n# Test function\n\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n\n\n# Run tests\nif __name__ == \"__main__\":\n    check(sort_numbers)\n    print(\"All tests passed!\")",
  "gold_reference_lean4_code": "/-!\n\n# VeriBench – Sort Numbers\n\nFile order:\n\n1. Implementation\n2. Unit tests (positive, edge, positive/negative test suite)\n3. Pre‑condition prop\n4. Exhaustive property prop and their theorems\n5. Post‑condition prop (same order as property props)\n6. Correctness theorem `Pre → Post`\n7. Imperative i. implementation, ii. tests (positive, edge, positive/negative\ntest suite), and iii. equivalence theorem.\n\nAll real proofs are left as `sorry` for the learner/model/agent.\n\n# Implementation\n\n## Sort Numbers\n\nImplements `sort_numbers`, which processes a space-delimited string of number words.-/\n\nnamespace SortNumbers\n\n/--\nHelper function to convert a word representation of a number to its numeric value.\nSupports words like \"zero\", \"one\", \"two\", etc. up to \"nine\".\nReturns the corresponding natural number.\n\n## Examples\n#eval wordToNum \"zero\" -- expected: 0\n#eval wordToNum \"one\" -- expected: 1\n-/\ndef wordToNum (word : String) : Nat :=\n  match word with\n  | \"zero\"  => 0\n  | \"one\"   => 1\n  | \"two\"   => 2\n  | \"three\" => 3\n  | \"four\"  => 4\n  | \"five\"  => 5\n  | \"six\"   => 6\n  | \"seven\" => 7\n  | \"eight\" => 8\n  | \"nine\"  => 9\n  | _       => 0\n\n/--\n**Implementation of `sort_numbers`.**\n\nGiven a space-delimited string of numerals from 'zero' to 'nine',\nreturns the string with numbers in their original order.\n\nValid input words are: 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'.\n\n## Examples\n\n#eval sort_numbers \"three five nine\" -- expected: \"three five nine\"\n#eval sort_numbers \"five zero four\" -- expected: \"five zero four\"\n-/\ndef sort_numbers (numbers : String) : String :=\n  if numbers = \"\" then\n    \"\"\n  else\n    let words := String.splitOn numbers \" \"\n    let nonEmpty := words.filter (· ≠ \"\")\n    String.intercalate \" \" nonEmpty\n\n/-!\n# Tests\n-/\n\n/-- expected: \"\" -/\nexample : sort_numbers \"\" == \"\" := by sorry\n#eval sort_numbers \"\"\n\n/-- expected: \"three\" -/\nexample : sort_numbers \"three\" == \"three\" := by sorry\n#eval sort_numbers \"three\"\n\n/-!\n# Tests: Edge Cases\n-/\n\n/-- expected: \"three five nine\" -/\nexample : sort_numbers \"three five nine\" == \"three five nine\" := by sorry\n#eval sort_numbers \"three five nine\"\n\n/-- expected: \"five zero four seven nine eight\" -/\nexample : sort_numbers \"five zero four seven nine eight\" == \"five zero four seven nine eight\" := by sorry\n#eval sort_numbers \"five zero four seven nine eight\"\n\n/-!\n# Positive / Negative Test‑Suite\n-/\n\n/-- positive: handles extra spaces -/\nexample : sort_numbers \"  one  two  three  \" == \"one two three\" := by sorry\n#eval sort_numbers \"  one  two  three  \" -- expected: \"one two three\"\n\n/-- positive: single word -/\nexample : sort_numbers \"zero\" == \"zero\" := by sorry\n#eval sort_numbers \"zero\" -- expected: \"zero\"\n\n/-- negative: empty string doesn't produce words -/\nexample : ¬ (sort_numbers \"\" == \"zero\") := by sorry\n#eval (decide (sort_numbers \"\" == \"zero\")) -- expected: false\n\n/-- negative: preserves original order -/\nexample : ¬ (sort_numbers \"nine one\" == \"one nine\") := by sorry\n#eval (decide (sort_numbers \"nine one\" == \"one nine\")) -- expected: false\n\n/-!\n# Pre‑Condition\n-/\n\n/-- **Pre‑condition.** Any string is valid input. -/\ndef Pre (numbers : String) : Prop := True\n\n/-!\n# Property Theorems\n-/\n\n/-- **Empty string property**: Empty string returns empty string. -/\ndef empty_string_prop : Prop := sort_numbers \"\" = \"\"\n\n/-- **Empty string theorem**: Empty string returns empty string. -/\n@[simp] theorem empty_string_thm : empty_string_prop := sorry\n\n/-- **Order preservation property**: Original order is preserved. -/\ndef order_preservation_prop (numbers : String) : Prop :=\n  let words := String.splitOn (sort_numbers numbers) \" \"\n  let inputWords := (String.splitOn numbers \" \").filter (· ≠ \"\")\n  words = inputWords\n\n/-- **Order preservation theorem**: Original order is preserved. -/\n@[simp] theorem order_preservation_thm (numbers : String) : order_preservation_prop numbers := sorry\n\n/-- **Idempotent property**: Applying twice gives same result as once. -/\ndef idempotent_prop (numbers : String) : Prop :=\n  sort_numbers (sort_numbers numbers) = sort_numbers numbers\n\n/-- **Idempotent theorem**: Applying twice gives same result as once. -/\n@[simp] theorem idempotent_thm (numbers : String) : idempotent_prop numbers := sorry\n\n/-- **Space normalization property**: Extra spaces are normalized. -/\ndef space_normalization_prop : Prop :=\n  sort_numbers \"  one  two  \" = \"one two\"\n\n/-- **Space normalization theorem**: Extra spaces are normalized. -/\n@[simp] theorem space_normalization_thm : space_normalization_prop := sorry\n\n/-- **Single word property**: Single word is preserved. -/\ndef single_word_prop (word : String) : Prop :=\n  word ≠ \"\" → sort_numbers word = word\n\n/-- **Single word theorem**: Single word is preserved. -/\n@[simp] theorem single_word_thm (word : String) : single_word_prop word := sorry\n\n/-!\n# Post‑Condition  (conjunction of all desired properties)\n-/\n\n/-- **Post‑condition**: conjunction of all desired properties for sort_numbers. -/\ndef Post_prop (numbers : String) : Prop :=\n  (empty_string_prop) ∧                                  -- empty_string_prop\n  (order_preservation_prop numbers) ∧                    -- order_preservation_prop\n  (idempotent_prop numbers) ∧                            -- idempotent_prop\n  (space_normalization_prop) ∧                           -- space_normalization_prop\n  (∀ word, single_word_prop word)                        -- single_word_prop\n\n/-!\n# Correctness Theorem\n-/\n\n/-- **Correctness theorem**: the pre‑condition implies the post‑condition. -/\ntheorem correctness_thm (numbers : String) (hPre : Pre numbers) : Post_prop numbers := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\n`sort_numbersImp numbers` computes the same result using imperative style with explicit loops.\n-/\ndef sort_numbersImp (numbers : String) : String :=\n  Id.run do\n    if numbers = \"\" then\n      return \"\"\n    let words := String.splitOn numbers \" \"\n    let mut result : List String := []\n    for word in words do\n      if word ≠ \"\" then\n        result := result ++ [word]\n    return String.intercalate \" \" result\n\n/-!\n# Imperative Tests\n-/\n\n/-- expected: \"\" -/\nexample : sort_numbersImp \"\" == \"\" := by sorry\n#eval sort_numbersImp \"\"\n\n/-!\n# Imperative Tests: Edge Cases\n-/\n\n/-- expected: \"three\" -/\nexample : sort_numbersImp \"three\" == \"three\" := by sorry\n#eval sort_numbersImp \"three\"\n\n/-- expected: \"three five nine\" -/\nexample : sort_numbersImp \"three five nine\" == \"three five nine\" := by sorry\n#eval sort_numbersImp \"three five nine\"\n\n/-!\n# Positive / Negative Test‑Suite\n-/\n\n/-- positive: space handling -/\nexample : sort_numbersImp \"  one  two  \" == \"one two\" := by sorry\n#eval sort_numbersImp \"  one  two  \" -- expected: \"one two\"\n\n/-- negative: doesn't reorder -/\nexample : ¬ (sort_numbersImp \"five one\" == \"one five\") := by sorry\n#eval (decide (sort_numbersImp \"five one\" == \"one five\")) -- expected: false\n\n/-- **Equivalence theorem**: functional and imperative implementations coincide. -/\ntheorem sort_numbers_equivalence_thm (numbers : String) :\n  sort_numbers numbers = sort_numbersImp numbers := sorry\n\nend SortNumbers\n"
}