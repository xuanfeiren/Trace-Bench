{
  "task_id": 109,
  "python_code": "# -- Implementation --\n# source: https://github.com/python/cpython/blob/3.13/Lib/heapq.py\n\n# 'heap' is a heap at all indices >= startpos, except possibly for pos.  pos\n# is the index of a leaf with a possibly out-of-order value.  Restore the\n# heap invariant.\ndef _siftdown(heap, startpos, pos):\n    newitem = heap[pos]\n    # Follow the path to the root, moving parents down until finding a place\n    # newitem fits.\n    while pos > startpos:\n        parentpos = (pos - 1) >> 1\n        parent = heap[parentpos]\n        if newitem < parent:\n            heap[pos] = parent\n            pos = parentpos\n            continue\n        break\n    heap[pos] = newitem\n\n\ndef heappush(heap, item):\n    \"\"\"Push item onto heap, maintaining the heap invariant.\"\"\"\n    heap.append(item)\n    _siftdown(heap, 0, len(heap) - 1)\n\n\n# -- Tests --\nfrom typing import Callable\nimport random\n\n\ndef _check_invariant(heap):\n    # Check the min-heap invariant: for every node, its value <= each child's value.\n    for pos, item in enumerate(heap):\n        if pos:  # pos 0 has no parent\n            parentpos = (pos - 1) >> 1\n            assert heap[parentpos] <= item, (\n                f\"heap invariant violated at pos={pos}: \"\n                f\"parent {heap[parentpos]} > child {item}\"\n            )\n\n\ndef check(candidate: Callable[[list, int], None]) -> bool:\n    # Basic unit tests\n    h = []\n    candidate(h, 3)\n    _check_invariant(h)\n    candidate(h, 1)\n    _check_invariant(h)\n    candidate(h, 2)\n    _check_invariant(h)\n    assert h[0] == 1, f\"expected min at root to be 1 but got {h[0]}\"\n\n    # Edge unit tests: push onto empty; push equal elements\n    h = []\n    candidate(h, 5)\n    _check_invariant(h)\n    candidate(h, 5)\n    _check_invariant(h)\n    assert min(h) == h[0] == 5, f\"expected root 5 but got {h[0]}\"\n\n    # Property check: push 256 random numbers; heap must be a permutation and satisfy invariant,\n    # and its root must equal min(data).\n    data = []\n    h = []\n    for _ in range(256):\n        x = random.random()\n        data.append(x)\n        candidate(h, x)\n        _check_invariant(h)\n    assert len(h) == len(data), \"heap size changed unexpectedly\"\n    assert sorted(h) == sorted(data), \"heap does not contain same multiset of items\"\n    assert h[0] == min(data), f\"root {h[0]} != min(data) {min(data)}\"\n\n    # Error behavior checks (mirrors heap_test.py expectations):\n    # Calling with missing arguments should raise TypeError\n    try:\n        heappush([])  # type: ignore[arg-type]\n        assert False, \"heappush([]) should raise TypeError (missing arg)\"\n    except TypeError:\n        pass\n\n    # Passing None heap or None item should raise (AttributeError or TypeError)\n    try:\n        heappush(None, None)  # type: ignore[arg-type]\n        assert False, \"heappush(None, None) should raise\"\n    except (AttributeError, TypeError):\n        pass\n\n    return True\n\n\nif __name__ == \"__main__\":\n    assert check(heappush), f\"Failed: {__file__}\"",
  "gold_reference_lean4_code": "/-!\n# VeriBench – Heappush (min-heap)\n\nFile order:\n\n1. Implementation (`_siftdown`, `heappush`)\n2. Unit tests (basic, edge, small property checks)\n3. Pre-condition\n4. Property propositions\n5. Post-condition (same order as properties)\n6. Correctness theorem `Pre → Post`\n\nAll nontrivial proofs are left as `sorry` for the learner/model/agent.\n-/\n\nnamespace HeapPush\n\n/--\n`_siftdown`\n\nGiven:\n* `heap` : a min-heap at all indices ≥ `startpos` except possibly at `pos`\n* `startpos` : root of the sifted subtree (usually `0`)\n* `pos` : index of a leaf whose value may violate the heap invariant\n\nRestores the heap invariant by moving parents down until a slot for `newitem`\nis found, then writes `newitem` once.\n-/\ndef _siftdown (heap : Array Int) (startpos pos : Nat) : Array Int :=\n  let newitem := heap[pos]!\n  let rec loop (h : Array Int) (pos : Nat) : Array Int :=\n    if pos > startpos then\n      let parentpos := (pos - 1) >>> 1\n      let parent := h[parentpos]!\n      if newitem < parent then\n        let h' := h.set! pos parent\n        loop h' parentpos\n      else\n        h.set! pos newitem\n    else\n      h.set! pos newitem\n  loop heap pos\n\n/--\n`heappush`\n\nPush `item` onto `heap` (append) and restore heap invariant via `_siftdown`.\n-/\ndef heappush (heap : Array Int) (item : Int) : Array Int :=\n  let heap1 := heap.push item\n  _siftdown heap1 0 (heap1.size - 1)\n\n\n/-!\n# Tests\n-/\n\n/-- Boolean heap invariant checker: for every child, parent ≤ child. -/\ndef checkInvariant (h : Array Int) : Bool :=\n  let n := h.size\n  let rec go (i : Nat) : Bool :=\n    if i ≥ n then\n      true\n    else if i = 0 then\n      go (i + 1)\n    else\n      let parentpos := (i - 1) >>> 1\n      if h[parentpos]! ≤ h[i]! then\n        go (i + 1)\n      else\n        false\n  go 0\n\n/-- expected: root becomes 1 after pushing 3,1,2 -/\nexample : (heappush (heappush (heappush (#[] : Array Int) 3) 1) 2)[0]! = 1 := by native_decide\n#eval (heappush (heappush (heappush (#[] : Array Int) 3) 1) 2)[0]!  -- expected: 1\n\n/-- expected: pushing 5 twice keeps root 5 -/\nexample :\n  let h1 := heappush (#[] : Array Int) 5\n  let h2 := heappush h1 5\n  h1[0]! = 5 ∧ h2[0]! = 5 := by native_decide\n#eval (let h1 := heappush (#[] : Array Int) 5; let h2 := heappush h1 5; (h1[0]!, h2[0]!))  -- expected: (5, 5)\n\n/-- positive: invariant holds after each push in [3,1,2] -/\nexample :\n  let h1 := heappush (#[] : Array Int) 3\n  let h2 := heappush h1 1\n  let h3 := heappush h2 2\n  checkInvariant h1 ∧ checkInvariant h2 ∧ checkInvariant h3 := by native_decide\n#eval (let h1 := heappush (#[] : Array Int) 3; let h2 := heappush h1 1; let h3 := heappush h2 2; (checkInvariant h1, checkInvariant h2, checkInvariant h3))  -- expected: (true, true, true)\n\n\n/-!\n# Pre-Condition\n-/\n\n/-- **Pre-condition.** The input `heap` already satisfies the min-heap invariant. -/\ndef Pre (heap : Array Int) : Prop :=\n  checkInvariant heap = true\n\n/-!\n# Property Theorems\n-/\n\n/-- **Invariant property**: after `heappush`, the heap invariant holds. -/\ndef prop_invariant (heap : Array Int) (item : Int) : Prop :=\n  checkInvariant (heappush heap item) = true\n\n/-- **Invariant theorem**: `heappush` preserves the heap invariant (given a heap input). -/\n@[simp] theorem invariant_thm (heap : Array Int) (item : Int) (hPre : Pre heap) :\n  prop_invariant heap item := by\n  sorry\n\n/-- **Size property**: pushing increases the size by one. -/\ndef prop_size (heap : Array Int) (item : Int) : Prop :=\n  (heappush heap item).size = heap.size + 1\n\n/-- **Size theorem**: `heappush` increases the size by one. -/\n@[simp] theorem size_thm (heap : Array Int) (item : Int) :\n  prop_size heap item := by\n  sorry\n\n/-- **Multiset property**: contents are preserved up to permutation. -/\ndef prop_multiset (heap : Array Int) (item : Int) : Prop :=\n  List.Perm (heappush heap item).toList (item :: heap.toList)\n\n/-- **Multiset theorem**: `heappush` preserves contents up to permutation. -/\n@[simp] theorem multiset_thm (heap : Array Int) (item : Int) :\n  prop_multiset heap item := by\n  sorry\n\n/-!\n# Post-Condition\n-/\n\n/-- **Post-condition** for `heappush`. -/\ndef Post_prop (heap : Array Int) (item : Int) : Prop :=\n  prop_invariant heap item ∧\n  prop_size heap item ∧\n  prop_multiset heap item\n\n/-!\n# Correctness Theorem\n-/\n\n/-- **Correctness theorem**: the pre-condition implies the post-condition. -/\ntheorem correctness_thm (heap : Array Int) (item : Int) (hPre : Pre heap) :\n  Post_prop heap item := by\n  exact And.intro\n    (invariant_thm heap item hPre)\n    (And.intro (size_thm heap item) (multiset_thm heap item))\n\nend HeapPush\n"
}