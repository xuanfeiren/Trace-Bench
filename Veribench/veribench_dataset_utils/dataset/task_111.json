{
  "task_id": 111,
  "python_code": "\"\"\"Implementation of JSONDecoder\n\"\"\"\nimport re\n\nfrom json import scanner\ntry:\n    from _json import scanstring as c_scanstring\nexcept ImportError:\n    c_scanstring = None\n\n__all__ = ['JSONDecoder', 'JSONDecodeError']\n\nFLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL\n\nNaN = float('nan')\nPosInf = float('inf')\nNegInf = float('-inf')\n\n\nclass JSONDecodeError(ValueError):\n    \"\"\"Subclass of ValueError with the following additional properties:\n\n    msg: The unformatted error message\n    doc: The JSON document being parsed\n    pos: The start index of doc where parsing failed\n    lineno: The line corresponding to pos\n    colno: The column corresponding to pos\n\n    \"\"\"\n    # Note that this exception is used from _json\n    def __init__(self, msg, doc, pos):\n        lineno = doc.count('\\n', 0, pos) + 1\n        colno = pos - doc.rfind('\\n', 0, pos)\n        errmsg = '%s: line %d column %d (char %d)' % (msg, lineno, colno, pos)\n        ValueError.__init__(self, errmsg)\n        self.msg = msg\n        self.doc = doc\n        self.pos = pos\n        self.lineno = lineno\n        self.colno = colno\n\n    def __reduce__(self):\n        return self.__class__, (self.msg, self.doc, self.pos)\n\n\n_CONSTANTS = {\n    '-Infinity': NegInf,\n    'Infinity': PosInf,\n    'NaN': NaN,\n}\n\n\nHEXDIGITS = re.compile(r'[0-9A-Fa-f]{4}', FLAGS)\nSTRINGCHUNK = re.compile(r'(.*?)([\"\\\\\\x00-\\x1f])', FLAGS)\nBACKSLASH = {\n    '\"': '\"', '\\\\': '\\\\', '/': '/',\n    'b': '\\b', 'f': '\\f', 'n': '\\n', 'r': '\\r', 't': '\\t',\n}\n\ndef _decode_uXXXX(s, pos, _m=HEXDIGITS.match):\n    esc = _m(s, pos + 1)\n    if esc is not None:\n        try:\n            return int(esc.group(), 16)\n        except ValueError:\n            pass\n    msg = \"Invalid \\\\uXXXX escape\"\n    raise JSONDecodeError(msg, s, pos)\n\ndef py_scanstring(s, end, strict=True,\n        _b=BACKSLASH, _m=STRINGCHUNK.match):\n    \"\"\"Scan the string s for a JSON string. End is the index of the\n    character in s after the quote that started the JSON string.\n    Unescapes all valid JSON string escape sequences and raises ValueError\n    on attempt to decode an invalid string. If strict is False then literal\n    control characters are allowed in the string.\n\n    Returns a tuple of the decoded string and the index of the character in s\n    after the end quote.\"\"\"\n    chunks = []\n    _append = chunks.append\n    begin = end - 1\n    while 1:\n        chunk = _m(s, end)\n        if chunk is None:\n            raise JSONDecodeError(\"Unterminated string starting at\", s, begin)\n        end = chunk.end()\n        content, terminator = chunk.groups()\n        # Content is contains zero or more unescaped string characters\n        if content:\n            _append(content)\n        # Terminator is the end of string, a literal control character,\n        # or a backslash denoting that an escape sequence follows\n        if terminator == '\"':\n            break\n        elif terminator != '\\\\':\n            if strict:\n                #msg = \"Invalid control character %r at\" % (terminator,)\n                msg = \"Invalid control character {0!r} at\".format(terminator)\n                raise JSONDecodeError(msg, s, end)\n            else:\n                _append(terminator)\n                continue\n        try:\n            esc = s[end]\n        except IndexError:\n            raise JSONDecodeError(\"Unterminated string starting at\",\n                                  s, begin) from None\n        # If not a unicode escape sequence, must be in the lookup table\n        if esc != 'u':\n            try:\n                char = _b[esc]\n            except KeyError:\n                msg = \"Invalid \\\\escape: {0!r}\".format(esc)\n                raise JSONDecodeError(msg, s, end)\n            end += 1\n        else:\n            uni = _decode_uXXXX(s, end)\n            end += 5\n            if 0xd800 <= uni <= 0xdbff and s[end:end + 2] == '\\\\u':\n                uni2 = _decode_uXXXX(s, end + 1)\n                if 0xdc00 <= uni2 <= 0xdfff:\n                    uni = 0x10000 + (((uni - 0xd800) << 10) | (uni2 - 0xdc00))\n                    end += 6\n            char = chr(uni)\n        _append(char)\n    return ''.join(chunks), end\n\n\n# Use speedup if available\nscanstring = c_scanstring or py_scanstring\n\nWHITESPACE = re.compile(r'[ \\t\\n\\r]*', FLAGS)\nWHITESPACE_STR = ' \\t\\n\\r'\n\n\ndef JSONObject(s_and_end, strict, scan_once, object_hook, object_pairs_hook,\n               memo=None, _w=WHITESPACE.match, _ws=WHITESPACE_STR):\n    s, end = s_and_end\n    pairs = []\n    pairs_append = pairs.append\n    # Backwards compatibility\n    if memo is None:\n        memo = {}\n    memo_get = memo.setdefault\n    # Use a slice to prevent IndexError from being raised, the following\n    # check will raise a more specific ValueError if the string is empty\n    nextchar = s[end:end + 1]\n    # Normally we expect nextchar == '\"'\n    if nextchar != '\"':\n        if nextchar in _ws:\n            end = _w(s, end).end()\n            nextchar = s[end:end + 1]\n        # Trivial empty object\n        if nextchar == '}':\n            if object_pairs_hook is not None:\n                result = object_pairs_hook(pairs)\n                return result, end + 1\n            pairs = {}\n            if object_hook is not None:\n                pairs = object_hook(pairs)\n            return pairs, end + 1\n        elif nextchar != '\"':\n            raise JSONDecodeError(\n                \"Expecting property name enclosed in double quotes\", s, end)\n    end += 1\n    while True:\n        key, end = scanstring(s, end, strict)\n        key = memo_get(key, key)\n        # To skip some function call overhead we optimize the fast paths where\n        # the JSON key separator is \": \" or just \":\".\n        if s[end:end + 1] != ':':\n            end = _w(s, end).end()\n            if s[end:end + 1] != ':':\n                raise JSONDecodeError(\"Expecting ':' delimiter\", s, end)\n        end += 1\n\n        try:\n            if s[end] in _ws:\n                end += 1\n                if s[end] in _ws:\n                    end = _w(s, end + 1).end()\n        except IndexError:\n            pass\n\n        try:\n            value, end = scan_once(s, end)\n        except StopIteration as err:\n            raise JSONDecodeError(\"Expecting value\", s, err.value) from None\n        pairs_append((key, value))\n        try:\n            nextchar = s[end]\n            if nextchar in _ws:\n                end = _w(s, end + 1).end()\n                nextchar = s[end]\n        except IndexError:\n            nextchar = ''\n        end += 1\n\n        if nextchar == '}':\n            break\n        elif nextchar != ',':\n            raise JSONDecodeError(\"Expecting ',' delimiter\", s, end - 1)\n        comma_idx = end - 1\n        end = _w(s, end).end()\n        nextchar = s[end:end + 1]\n        end += 1\n        if nextchar != '\"':\n            if nextchar == '}':\n                raise JSONDecodeError(\"Illegal trailing comma before end of object\", s, comma_idx)\n            raise JSONDecodeError(\n                \"Expecting property name enclosed in double quotes\", s, end - 1)\n    if object_pairs_hook is not None:\n        result = object_pairs_hook(pairs)\n        return result, end\n    pairs = dict(pairs)\n    if object_hook is not None:\n        pairs = object_hook(pairs)\n    return pairs, end\n\ndef JSONArray(s_and_end, scan_once, _w=WHITESPACE.match, _ws=WHITESPACE_STR):\n    s, end = s_and_end\n    values = []\n    nextchar = s[end:end + 1]\n    if nextchar in _ws:\n        end = _w(s, end + 1).end()\n        nextchar = s[end:end + 1]\n    # Look-ahead for trivial empty array\n    if nextchar == ']':\n        return values, end + 1\n    _append = values.append\n    while True:\n        try:\n            value, end = scan_once(s, end)\n        except StopIteration as err:\n            raise JSONDecodeError(\"Expecting value\", s, err.value) from None\n        _append(value)\n        nextchar = s[end:end + 1]\n        if nextchar in _ws:\n            end = _w(s, end + 1).end()\n            nextchar = s[end:end + 1]\n        end += 1\n        if nextchar == ']':\n            break\n        elif nextchar != ',':\n            raise JSONDecodeError(\"Expecting ',' delimiter\", s, end - 1)\n        comma_idx = end - 1\n        try:\n            if s[end] in _ws:\n                end += 1\n                if s[end] in _ws:\n                    end = _w(s, end + 1).end()\n            nextchar = s[end:end + 1]\n        except IndexError:\n            pass\n        if nextchar == ']':\n            raise JSONDecodeError(\"Illegal trailing comma before end of array\", s, comma_idx)\n\n    return values, end\n\n\nclass JSONDecoder(object):\n    \"\"\"Simple JSON <https://json.org> decoder\n\n    Performs the following translations in decoding by default:\n\n    +---------------+-------------------+\n    | JSON          | Python            |\n    +===============+===================+\n    | object        | dict              |\n    +---------------+-------------------+\n    | array         | list              |\n    +---------------+-------------------+\n    | string        | str               |\n    +---------------+-------------------+\n    | number (int)  | int               |\n    +---------------+-------------------+\n    | number (real) | float             |\n    +---------------+-------------------+\n    | true          | True              |\n    +---------------+-------------------+\n    | false         | False             |\n    +---------------+-------------------+\n    | null          | None              |\n    +---------------+-------------------+\n\n    It also understands ``NaN``, ``Infinity``, and ``-Infinity`` as\n    their corresponding ``float`` values, which is outside the JSON spec.\n\n    \"\"\"\n\n    def __init__(self, *, object_hook=None, parse_float=None,\n            parse_int=None, parse_constant=None, strict=True,\n            object_pairs_hook=None):\n        \"\"\"``object_hook``, if specified, will be called with the result\n        of every JSON object decoded and its return value will be used in\n        place of the given ``dict``.  This can be used to provide custom\n        deserializations (e.g. to support JSON-RPC class hinting).\n\n        ``object_pairs_hook``, if specified will be called with the result of\n        every JSON object decoded with an ordered list of pairs.  The return\n        value of ``object_pairs_hook`` will be used instead of the ``dict``.\n        This feature can be used to implement custom decoders.\n        If ``object_hook`` is also defined, the ``object_pairs_hook`` takes\n        priority.\n\n        ``parse_float``, if specified, will be called with the string\n        of every JSON float to be decoded. By default this is equivalent to\n        float(num_str). This can be used to use another datatype or parser\n        for JSON floats (e.g. decimal.Decimal).\n\n        ``parse_int``, if specified, will be called with the string\n        of every JSON int to be decoded. By default this is equivalent to\n        int(num_str). This can be used to use another datatype or parser\n        for JSON integers (e.g. float).\n\n        ``parse_constant``, if specified, will be called with one of the\n        following strings: -Infinity, Infinity, NaN.\n        This can be used to raise an exception if invalid JSON numbers\n        are encountered.\n\n        If ``strict`` is false (true is the default), then control\n        characters will be allowed inside strings.  Control characters in\n        this context are those with character codes in the 0-31 range,\n        including ``'\\\\t'`` (tab), ``'\\\\n'``, ``'\\\\r'`` and ``'\\\\0'``.\n        \"\"\"\n        self.object_hook = object_hook\n        self.parse_float = parse_float or float\n        self.parse_int = parse_int or int\n        self.parse_constant = parse_constant or _CONSTANTS.__getitem__\n        self.strict = strict\n        self.object_pairs_hook = object_pairs_hook\n        self.parse_object = JSONObject\n        self.parse_array = JSONArray\n        self.parse_string = scanstring\n        self.memo = {}\n        self.scan_once = scanner.make_scanner(self)\n\n\n    def decode(self, s, _w=WHITESPACE.match):\n        \"\"\"Return the Python representation of ``s`` (a ``str`` instance\n        containing a JSON document).\n\n        \"\"\"\n        obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n        end = _w(s, end).end()\n        if end != len(s):\n            raise JSONDecodeError(\"Extra data\", s, end)\n        return obj\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n        a JSON document) and return a 2-tuple of the Python\n        representation and the index in ``s`` where the document ended.\n\n        This can be used to decode a JSON document from a string that may\n        have extraneous data at the end.\n\n        \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n            raise JSONDecodeError(\"Expecting value\", s, err.value) from None\n        return obj, end",
  "gold_reference_lean4_code": "/-!\n# VeriBench – PyJSON Decoder\n\nLean 4 translation of essential parts of Python's `json.decoder`.\nWe provide a tiny `JVal` type and a `loads` that parses booleans, null,\nsigned integers, and empty lists/objects.\n-/\n\nnamespace PyJSON_Decoder\n\n/-!\n# Implementation\n-/\n\n/-\nJSON-like value type for the decoder.\n\nConstructors:\n- `null`     — JSON null\n- `bool b`   — JSON boolean\n- `int n`    — integer number (decimal encoding)\n- `str s`    — string value\n- `arr xs`   — array (ordered list of `JVal`)\n- `obj kvs`  — object (ordered list of string key–value pairs)\n\nExamples (informal): `.null`, `.bool true`, `.int 123`, `.str \"hi\"`,\n`.arr [.int 1, .bool false]`, `.obj [(\"a\", .int 1)]`.\n-/\ninductive JVal\n| null\n| bool  (b : Bool)\n| int   (n : Int)\n| str   (s : String)\n| arr   (xs : List JVal)\n| obj   (kvs : List (String × JVal))\nderiving Repr\n\n/-\nASCII decimal digit predicate for characters in `'0'`..`'9'`.\n-/\nprivate def isDigit (c : Char) : Bool := '0' ≤ c ∧ c ≤ '9'\n\n/-\nParse a possibly signed base-10 integer from an entire string.\nReturns `none` if not a valid decimal integer (no whitespace or suffix).\n-/\nprivate def parseInt? (s : String) : Option Int :=\n  if s = \"\" then none else\n  let cs := s.data\n  match cs with\n  | '-' :: ds => if ds.all isDigit then\n      let n := ds.foldl (fun acc c => acc * 10 + (Char.toNat c - Char.toNat '0')) 0\n      some (Int.negOfNat n) else none\n  | '+' :: ds => if ds.all isDigit then\n      let n := ds.foldl (fun acc c => acc * 10 + (Char.toNat c - Char.toNat '0')) 0\n      some (Int.ofNat n) else none\n  | d :: ds   => if isDigit d ∧ ds.all isDigit then\n      let n := (d :: ds).foldl (fun acc c => acc * 10 + (Char.toNat c - Char.toNat '0')) 0\n      some (Int.ofNat n) else none\n  | []        => none\n\n/-\nMinimal decoder for a restricted subset of JSON:\n`true`, `false`, `null`, signed integers, `[]`, `{}`, and quoted strings as-is.\n-/\ndef loads (s : String) : Option JVal :=\n  if s == \"true\" then some (.bool true) else\n  if s == \"false\" then some (.bool false) else\n  if s == \"null\" then some (.null) else\n  match parseInt? s with\n  | some i => some (.int i)\n  | none   =>\n    if s == \"[]\" then some (.arr []) else\n    if s == \"{}\" then some (.obj []) else\n    if s.length ≥ 2 ∧ s.front = '\"' ∧ s.back = '\"' then\n      some (.str s)\n    else none\n\n/-- Alias. -/\nabbrev decode := loads\n\n\n\n/-!\n# Tests\n-/\n\nexample : loads \"true\" = some (.bool true) := rfl\nexample : loads \"null\" = some (.null) := rfl\nexample : loads \"[]\" = some (.arr []) := rfl\n\n/-!\n# Tests: Edge Cases\n-/\n\nexample : loads \"\\\"x\\\"\" = some (.str \"\\\"x\\\"\") := rfl\nexample : loads \"-7\" = some (.int (-7)) := rfl\n\n/-!\n# Positive / Negative Test-Suite\n-/\n\nexample : loads \"false\" = some (.bool false) := rfl\nexample : loads \"not-json\" = none := rfl\n\n/-!\n# Docstring-Derived Tests (subset supported)\n-/\n\n/-- quoted string recognized as a string token (kept as-is) -/\nexample : loads \"\\\"hi\\\"\" = some (.str \"\\\"hi\\\"\") := rfl\n\n/-- empty object recognized -/\nexample : loads \"{}\" = some (.obj []) := rfl\n\n\n\n/-!\n# Pre-Condition\n-/\n\n/-- Trivial pre-condition for top-level correctness. -/\ndef Pre (s : String) : Prop := True\n\n\n\n/-!\n# Property Theorems\n-/\n\n/-- Specification of accepted strings and their values. -/\ninductive JSpec : String → JVal → Prop\n| s_true  : JSpec \"true\"  (.bool true)\n| s_false : JSpec \"false\" (.bool false)\n| s_null  : JSpec \"null\"  (.null)\n| s_int   (t : String) (n : Int) (ok : parseInt? t = some n) : JSpec t (.int n)\n| s_empty_arr : JSpec \"[]\" (.arr [])\n| s_empty_obj : JSpec \"{}\" (.obj [])\n| s_qstr (t : String)\n    (h2 : t.length ≥ 2)\n    (h0 : t.front = '\"')\n    (hE : t.back  = '\"') :\n  JSpec t (.str t)\n\n/-- **Soundness**: if `loads s = some v` then `JSpec s v`. -/\ndef sound_prop : Prop :=\n  ∀ s v, loads s = some v → JSpec s v\n\ntheorem sound_thm : sound_prop := by\n  intro s v h\n  dsimp [loads] at h\n  by_cases hsT : s = \"true\"\n  · subst hsT\n    have : some (.bool true) = some v := by simpa [loads] using h\n    cases this\n    exact JSpec.s_true\n  by_cases hsF : s = \"false\"\n  · subst hsF\n    have : some (.bool false) = some v := by simpa [loads] using h\n    cases this\n    exact JSpec.s_false\n  by_cases hsN : s = \"null\"\n  · subst hsN\n    have : some (.null) = some v := by simpa [loads] using h\n    cases this\n    exact JSpec.s_null\n  cases hInt : parseInt? s with\n  | some n =>\n    have : some (.int n) = some v := by simpa [loads, hInt, hsT, hsF, hsN] using h\n    cases this\n    exact JSpec.s_int s n hInt\n  | none =>\n    have h' := h\n    simp [ hInt, hsT, hsF, hsN] at h'\n    by_cases hsA : s = \"[]\"\n    · subst hsA\n      have : some (.arr []) = some v := by simpa using h'\n      cases this\n      exact JSpec.s_empty_arr\n    ·\n      have h'' := h'\n      simp [hsA] at h''\n      by_cases hsO : s = \"{}\"\n      · subst hsO\n        have : some (.obj []) = some v := by simpa using h''\n        cases this\n        exact JSpec.s_empty_obj\n      ·\n        -- quoted-string branch vs none\n        simp [hsO] at h''\n        by_cases hS : (s.length ≥ 2 ∧ s.front = '\\\"' ∧ s.back = '\\\"')\n        ·\n          have : some (.str s) = some v := by simpa [hS] using h''\n          cases this\n          rcases hS with ⟨h2, h0, hE⟩\n          exact JSpec.s_qstr s h2 h0 hE\n        ·\n          have : (none : Option JVal) = some v := by simp [hS] at h''\n          cases this\n\n\n/-- **Completeness**: if `JSpec s v` then `loads s = some v`. -/\ndef complete_prop : Prop :=\n  ∀ s v, JSpec s v → loads s = some v\n\ntheorem complete_thm : complete_prop := by\n  sorry\n\n\n/-- **Determinism**: parse result is unique. -/\ndef deterministic_prop : Prop :=\n  ∀ s v₁ v₂, loads s = some v₁ → loads s = some v₂ → v₁ = v₂\n\ntheorem deterministic_thm : deterministic_prop := by\n  intro s v₁ v₂ h1 h2\n  simpa [h1] using congrArg id h2\n\n/-- **Rejection**: inputs not covered by `JSpec` are rejected as `none`. -/\ndef reject_prop : Prop :=\n  ∀ s, (¬ ∃ v, JSpec s v) → loads s = none\n\ntheorem reject_thm : reject_prop := by\n  intro s hnot\n  sorry\n\n\n/-!\n# Post-Condition\n-/\n\n/-- Conjunction of the main properties. -/\ndef Post_prop : Prop :=\n  sound_prop ∧ complete_prop ∧ deterministic_prop ∧ reject_prop\n\n\n\n/-!\n# Correctness Theorem\n-/\n\n/-- **Correctness theorem**: the pre-condition implies the post-condition. -/\ntheorem correctness_thm (s : String) (h : Pre s) : Post_prop := by\n  exact ⟨sound_thm, complete_thm, deterministic_thm, reject_thm⟩\n\n\n\n/-!\n# Imperative Implementation\n-/\n\n/-- Imperative decoder (alias of `loads`). -/\ndef loadsImp (s : String) : Option JVal := loads s\n\n\n\n/-!\n# Imperative Tests\n-/\n\nexample : loadsImp \"true\" = some (.bool true) := rfl\n\n\n\n/-!\n# Equivalence\n-/\n\n/-- Equivalence: functional and imperative decoders agree. -/\ntheorem equivalence_thm (s : String) : loads s = loadsImp s := rfl\n\nend PyJSON_Decoder\n"
}