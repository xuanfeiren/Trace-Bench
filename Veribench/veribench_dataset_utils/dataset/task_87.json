{
  "task_id": 87,
  "python_code": "# File: humaneval_40_triples_sum_to_zero.py\n# HumanEval problem HumanEval/40\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n\n# Test function\n\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n\n\n# Run tests\nif __name__ == \"__main__\":\n    check(triples_sum_to_zero)\n    print(\"All tests passed!\")",
  "gold_reference_lean4_code": "/-!\n# VeriBench – Triples Sum to Zero\n\nFile order:\n\n1. Implementation\n2. Unit tests (positive, edge, positive/negative test suite)\n3. Pre‑condition prop\n4. Exhaustive property prop and their theorems\n5. Post‑condition prop (same order as property props)\n6. Correctness theorem `Pre → Post`\n7. Imperative i. implementation, ii. tests (positive, edge, positive/negative\ntest suite), and iii. equivalence theorem.\n\nAll real proofs are left as `sorry` for the learner/model/agent.\n\n# Implementation\n\n## Triples Sum to Zero\n\nImplements `triples_sum_to_zero`, which checks whether there exist three distinct elements\nin a list that sum to zero.-/\n\nnamespace TriplesSumToZero\nopen List -- brings the `~` permutation notation into scope\n\n/--\n**Implementation of `triples_sum_to_zero`.**\n\n`triples_sum_to_zero l` returns `true` iff there exist three distinct elements in `l`\nthat sum to zero.\n\nNote: This function is marked as partial because Lean's termination checker\ncannot verify its termination, though we know it terminates because:\n1. Each recursive call either increases i, j, or k\n2. These indices are bounded by l.length\n3. The function returns when any index reaches l.length\n\n## Examples\n\n#eval triples_sum_to_zero [1, 3, 5, 0]         -- expected: false\n#eval triples_sum_to_zero [1, 3, -2, 1]        -- expected: true\n#eval triples_sum_to_zero [1, 2, 3, 7]         -- expected: false\n#eval triples_sum_to_zero [2, 4, -5, 3, 9, 7]  -- expected: true\n-/\npartial def triples_sum_to_zero (l : List Int) : Bool :=\n  let rec check_triple (i j k : Nat) : Bool :=\n    if i ≥ l.length then false\n    else if j ≥ l.length then check_triple (i + 1) (i + 2) (i + 3)\n    else if k ≥ l.length then check_triple i (j + 1) (j + 2)\n    else if l[i]! + l[j]! + l[k]! = 0 then true\n    else check_triple i j (k + 1)\n  check_triple 0 1 2\n\n/-!\n# Tests\n-/\n\n/-- expected: false -/\nexample : triples_sum_to_zero [1, 3, 5, 0] = false := by native_decide\n#eval triples_sum_to_zero [1, 3, 5, 0] -- expected: false\n\n/-- expected: true -/\nexample : triples_sum_to_zero [1, 3, -2, 1] = true := by native_decide\n#eval triples_sum_to_zero [1, 3, -2, 1] -- expected: true\n\n/-!\n# Tests: Edge Cases\n-/\n\n/-- expected: false -/\nexample : triples_sum_to_zero [1, 2, 3, 7] = false := by native_decide\n#eval triples_sum_to_zero [1, 2, 3, 7] -- expected: false\n\n/-- expected: true -/\nexample : triples_sum_to_zero [2, 4, -5, 3, 9, 7] = true := by native_decide\n#eval triples_sum_to_zero [2, 4, -5, 3, 9, 7] -- expected: true\n\n/-- expected: false -/\nexample : triples_sum_to_zero [] = false := by native_decide\n#eval triples_sum_to_zero [] -- expected: false\n\n/-!\n# Positive / Negative Test‑Suite\n-/\n\n/-- positive test: finds valid triple -/\nexample : triples_sum_to_zero [1] = false := by native_decide\n#eval triples_sum_to_zero [1] -- expected: false\n\n/-- positive test: handles two elements -/\nexample : triples_sum_to_zero [1, 2] = false := by native_decide\n#eval triples_sum_to_zero [1, 2] -- expected: false\n\n/-- positive test: finds triple in longer list -/\nexample : triples_sum_to_zero [-1, 0, 1, 2] = true := by native_decide\n#eval triples_sum_to_zero [-1, 0, 1, 2] -- expected: true\n\n/-- negative test: no valid triple exists -/\nexample : ¬ (triples_sum_to_zero [1, 2, 3] = true) := by native_decide\n\n/-- negative test: different lists give different results -/\nexample : triples_sum_to_zero [1, 3, -2, 1] ≠ triples_sum_to_zero [1, 2, 3, 7] := by native_decide\n\n/-!\n# Pre‑Condition\n-/\n\n/-- **Pre‑condition.** Any list of integers is valid input. -/\ndef Pre (_ : List Int) : Prop := True\n\n/-!\n# Property Theorems\n-/\n\n/-- **Specification property**: Correctness specification. -/\ndef specification_prop (l : List Int) : Prop :=\n  triples_sum_to_zero l = true ↔\n    ∃ i j k : Nat,\n      i < j ∧ j < k ∧ k < l.length ∧\n      l[i]! + l[j]! + l[k]! = 0\n\n/-- **Specification theorem**: Correctness specification. -/\n@[simp] theorem specification_thm (l : List Int) : specification_prop l := sorry\n\n/-- **Empty list property**: Empty list returns false. -/\ndef empty_list_prop : Prop := triples_sum_to_zero [] = false\n\n/-- **Empty list theorem**: Empty list returns false. -/\n@[simp] theorem empty_list_thm : empty_list_prop := sorry\n\n/-- **Small list property**: Lists with fewer than 3 elements return false. -/\ndef small_list_prop (l : List Int) : Prop :=\n  l.length < 3 → triples_sum_to_zero l = false\n\n/-- **Small list theorem**: Lists with fewer than 3 elements return false. -/\n@[simp] theorem small_list_thm (l : List Int) : small_list_prop l := sorry\n\n/-- **Permutation invariance property**: Result is stable under permutations. -/\ndef permutation_invariance_prop (l l' : List Int) : Prop :=\n  l ~ l' → triples_sum_to_zero l = triples_sum_to_zero l'\n\n/-- **Permutation invariance theorem**: Result is stable under permutations. -/\n@[simp] theorem permutation_invariance_thm (l l' : List Int) : permutation_invariance_prop l l' := sorry\n\n/-!\n# Post‑Condition  (conjunction of all desired properties)\n-/\n\n/-- **Post‑condition**: conjunction of all desired properties for triples_sum_to_zero. -/\ndef Post_prop (l : List Int) : Prop :=\n  (specification_prop l) ∧                               -- specification property\n  (empty_list_prop) ∧                                   -- empty list property\n  (small_list_prop l) ∧                                 -- small list property\n  (∀ l', permutation_invariance_prop l l')              -- permutation invariance property\n\n/-!\n# Correctness Theorem\n-/\n\n/-- **Correctness theorem**: the pre‑condition implies the post‑condition. -/\ntheorem correctness_thm (l : List Int) (hPre : Pre l) : Post_prop l := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\n`triples_sum_to_zeroImp l` computes the same result using imperative style with triple-nested loops.\n-/\ndef triples_sum_to_zeroImp (l : List Int) : Bool :=\n  Id.run do\n    for i in [:l.length] do\n      for j in [:l.length] do\n        if i < j then\n          for k in [:l.length] do\n            if j < k then\n              if l[i]! + l[j]! + l[k]! = 0 then\n                return true\n    return false\n\n/-!\n# Imperative Tests\n-/\n\n/-- expected: false -/\nexample : triples_sum_to_zeroImp [1, 3, 5, 0] = false := by native_decide\n#eval triples_sum_to_zeroImp [1, 3, 5, 0] -- expected: false\n\n/-!\n# Imperative Tests: Edge Cases\n-/\n\n/-- expected: true -/\nexample : triples_sum_to_zeroImp [1, 3, -2, 1] = true := by native_decide\n#eval triples_sum_to_zeroImp [1, 3, -2, 1] -- expected: true\n\n/-!\n# Positive / Negative Test‑Suite\n-/\n\n/-- positive test: handles empty list -/\nexample : triples_sum_to_zeroImp [] = false := by native_decide\n#eval triples_sum_to_zeroImp [] -- expected: false\n\n/-- negative test: no false positives -/\nexample : ¬ (triples_sum_to_zeroImp [1, 2, 3] = true) := by native_decide\n\n/-- **Equivalence theorem**: functional and imperative implementations coincide. -/\ntheorem triples_sum_to_zero_equivalence_thm (l : List Int) :\n  triples_sum_to_zero l = triples_sum_to_zeroImp l := sorry\n\nend TriplesSumToZero\n"
}