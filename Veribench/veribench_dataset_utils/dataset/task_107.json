{
  "task_id": 107,
  "python_code": "# -- Implementation --\n\nfrom typing import Callable, Iterable, List, Optional, TypeVar\n\nT = TypeVar(\"T\")\nK = TypeVar(\"K\")\n\n\ndef bisect_right(a: List[T], x: K, lo: int = 0, hi: Optional[int] = None, *, key: Optional[Callable[[T], K]] = None) -> int:\n    \"\"\"\n    Return the index where to insert item x in list a, assuming a is sorted.\n\n    The return value i is such that all e in a[:i] have e <= x, and all e in\n    a[i:] have e > x.  So if x already appears in the list, a.insert(i, x) will\n    insert just after the rightmost x already there.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n\n    A custom key function can be supplied to customize the sort order.\n\n    >>> bisect_right([1,2,4,4,10], 4)\n    4\n    >>> bisect_right([\"A\",\"bb\",\"CC\",\"ddd\"], 2, key=len)\n    3\n    \"\"\"\n    if lo < 0:\n        raise ValueError(\"lo must be non-negative\")\n    if hi is None:\n        hi = len(a)\n    # Note, the comparison uses \"<\" to match list.sort() / heapq semantics.\n    if key is None:\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if x < a[mid]:           # compare in element space\n                hi = mid\n            else:\n                lo = mid + 1\n    else:\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if x < key(a[mid]):      # compare in key space\n                hi = mid\n            else:\n                lo = mid + 1\n    return lo\n\n\ndef insort_right(a: List[T], x: T, lo: int = 0, hi: Optional[int] = None, *, key: Optional[Callable[[T], K]] = None) -> None:\n    \"\"\"\n    Insert item x in list a, and keep it sorted assuming a is sorted.\n\n    If x is already in a, insert it to the right of the rightmost x.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n\n    A custom key function can be supplied to customize the sort order.\n\n    >>> lst = [1,2,4,4,10]\n    >>> insort_right(lst, 4); lst\n    [1, 2, 4, 4, 4, 10]\n    >>> lst2 = [\"A\",\"bb\",\"CC\",\"ddd\"]\n    >>> insort_right(lst2, \"cC\", key=str.lower); lst2\n    ['A', 'bb', 'CC', 'cC', 'ddd']\n    \"\"\"\n    if key is None:\n        idx = bisect_right(a, x, lo, hi)\n    else:\n        idx = bisect_right(a, key(x), lo, hi, key=key)\n    a.insert(idx, x)\n\n\n# -- Tests --\nfrom typing import Callable\n\n\ndef check_bisect(candidate: Callable[[List[T], K, int, Optional[int]], int]) -> bool:\n    # Basic\n    assert candidate([1, 2, 4, 4, 10], 4, 0, None) == 4\n    assert candidate([1, 2, 4, 4, 10], 0, 0, None) == 0\n    assert candidate([1, 2, 4, 4, 10], 99, 0, None) == 5\n\n    # With key=len on strings, compare in key space\n    key = len\n    def cand_with_key(a: List[str], k: int) -> int:\n        return bisect_right(a, k, 0, None, key=key)\n\n    assert cand_with_key([\"A\",\"bb\",\"CC\",\"ddd\"], 1) == 1\n    assert cand_with_key([\"A\",\"bb\",\"CC\",\"ddd\"], 2) == 3\n    assert cand_with_key([\"A\",\"bb\",\"CC\",\"ddd\"], 3) == 4\n\n    return True\n\n\ndef check_insort() -> bool:\n    lst = [1, 2, 4, 4, 10]\n    insort_right(lst, 4)\n    assert lst == [1, 2, 4, 4, 4, 10]\n\n    lst2 = [\"A\",\"bb\",\"CC\",\"ddd\"]\n    insort_right(lst2, \"cC\", key=str.lower)\n    assert lst2 == [\"A\",\"bb\",\"CC\",\"cC\",\"ddd\"]\n    return True\n\n\nif __name__ == \"__main__\":\n    assert check_bisect(lambda a, x, lo, hi: bisect_right(a, x, lo, hi))\n    assert check_insort()",
  "gold_reference_lean4_code": "import Std\n\n/-!\n# VeriBench – Verified Bisection (Right-Biased Insertion Index)\n\nFile order:\n\n1. Implementation\n2. Unit tests (positive, edge, keyed)\n3. Pre-condition\n4. Property theorems\n5. Post-condition (same order as theorems)\n6. Correctness theorem `Pre → Post`\n7. Insertion properties\n\nAll real proofs are left as `sorry` for the learner / model.\n\n# Implementation\n\n## `bisect_right` and `insort_right`\n\n`bisect_right a x lo hi key?` returns the index `i` such that:\n- all elements in `a[lo:i]` are `≤ x` in key space, and\n- all elements in `a[i:hi]` are `> x`.\n\nInsertion at `i` places `x` to the right of any equal elements, matching Python’s behavior.\n-/\n\n\nnamespace Bisect\n\ndef bisect_right\n    {α γ}\n    (a   : Array α)\n    (x   : γ)\n    (lo  : Nat := 0)\n    (hi? : Option Nat := none)\n    (key?: Option (α → γ) := none)\n    [LT γ] [DecidableRel (· < · : γ → γ → Prop)]\n    [Coe α γ] [Inhabited α] :\n    Nat := Id.run do\n  let hi := hi?.getD a.size\n  match key? with\n  | none =>\n    let mut loM := lo\n    let mut hiM := hi\n    while loM < hiM do\n      let mid := (loM + hiM) / 2\n      let y : γ := (↑(a[mid]!) : γ)\n      if x < y then\n        hiM := mid\n      else\n        loM := mid + 1\n    return loM\n  | some key =>\n    let mut loM := lo\n    let mut hiM := hi\n    while loM < hiM do\n      let mid := (loM + hiM) / 2\n      let y := key (a[mid]!)\n      if x < y then\n        hiM := mid\n      else\n        loM := mid + 1\n    return loM\n\n/-- Literal translation of Python's `insort_right` using `bisect_right`. -/\ndef insort_right\n    {α γ}\n    (a   : Array α)\n    (x   : α)\n    (lo  : Nat := 0)\n    (hi? : Option Nat := none)\n    (key?: Option (α → γ) := none)\n    [LT γ] [DecidableRel (· < · : γ → γ → Prop)]\n    [Coe α γ] [Inhabited α] :\n    Array α := Id.run do\n  let idx :=\n    match key? with\n    | none      => bisect_right a ((↑x : γ)) lo hi? (key? := none)\n    | some key  => bisect_right a (key x)    lo hi? (key? := some key)\n  let left  := a.extract 0 idx\n  let right := a.extract idx a.size\n  return left ++ #[x] ++ right\n\n\n\n/-!\n# Tests\n-/\n\n-- Scoped coercions so tests compile\nlocal instance : Coe Nat Nat    where coe := id\nlocal instance : Coe String String where coe := id\nlocal instance : Coe String Nat where coe := fun s => s.length\n\n\n/-- expected: 4 -/\nexample : bisect_right (#[(1:Nat),2,4,4,10]) (4) = 4 := by native_decide\n#eval bisect_right (#[(1:Nat),2,4,4,10]) (4)  -- expected: 4\n\n/-- expected: 0 -/\nexample : bisect_right (#[(1:Nat),2,4,4,10]) (0) = 0 := by native_decide\n#eval bisect_right (#[(1:Nat),2,4,4,10]) (0)  -- expected: 0\n\n/-- expected: 5 -/\nexample : bisect_right (#[(1:Nat),2,4,4,10]) (99) = 5 := by native_decide\n#eval bisect_right (#[(1:Nat),2,4,4,10]) (99) -- expected: 5\n\n/-!\n# Tests: Keyed (string length)\n-/\n\n/-- expected: 1 -/\nexample :\n  bisect_right #[\"A\",\"bb\",\"CC\",\"ddd\"] (1) (key? := some (·.length)) = 1 := by\n  native_decide\n#eval bisect_right #[\"A\",\"bb\",\"CC\",\"ddd\"] (1) (key? := some (·.length))  -- expected: 1\n\n/-- expected: 3 -/\nexample :\n  bisect_right #[\"A\",\"bb\",\"CC\",\"ddd\"] (2) (key? := some (·.length)) = 3 := by\n  native_decide\n#eval bisect_right #[\"A\",\"bb\",\"CC\",\"ddd\"] (2) (key? := some (·.length))  -- expected: 3\n\n/-- expected: 4 -/\nexample :\n  bisect_right #[\"A\",\"bb\",\"CC\",\"ddd\"] (3) (key? := some (·.length)) = 4 := by\n  native_decide\n#eval bisect_right #[\"A\",\"bb\",\"CC\",\"ddd\"] (3) (key? := some (·.length))  -- expected: 4\n\n/-!\n# Positive / Negative Test-Suite (insertion)\n-/\n\n/-- expected: #[1,2,4,4,4,10] -/\nexample :\n  insort_right (γ := Nat) (#[(1:Nat),2,4,4,10]) 4\n    = #[(1:Nat),2,4,4,4,10] := by\n  native_decide\n#eval insort_right (γ := Nat) (#[(1:Nat),2,4,4,10]) 4  -- expected: #[1,2,4,4,4,10]\n\n/-- expected: #[\"A\",\"bb\",\"CC\",\"cC\",\"ddd\"] -/\nexample :\n  insort_right #[\"A\",\"bb\",\"CC\",\"ddd\"] \"cC\" (key? := some (fun s => s.toLower))\n    = #[\"A\",\"bb\",\"CC\",\"cC\",\"ddd\"] := by\n  native_decide\n#eval insort_right #[\"A\",\"bb\",\"CC\",\"ddd\"] \"cC\" (key? := some (fun s => s.toLower))\n-- expected: #[\"A\",\"bb\",\"CC\",\"cC\",\"ddd\"]\n\n/-!\n# Pre-Condition\n-/\n\n/-- Default projection when no key is provided. -/\ndef defaultProj {α : Type u} {γ : Type v} [Coe α γ] : α → γ :=\n  fun a => (↑a : γ)\n\n/-- Project into key space (uses `key` if provided, else coercion). -/\ndef Proj {α : Type u} {γ : Type v} (key? : Option (α → γ)) [Coe α γ] : α → γ :=\n  key?.elim defaultProj id\n\n/-- `SortedSlice a lo hi proj` means `a[lo:hi]` is nondecreasing under `proj`. -/\ndef SortedSlice {α : Type u} {γ : Type v}\n    (a : Array α) (lo hi : Nat) (proj : α → γ)\n    [LE γ] [DecidableRel (· ≤ · : γ → γ → Prop)] [Inhabited α] : Prop :=\n  ∀ i j, lo ≤ i → i ≤ j → j < hi → proj (a[i]!) ≤ proj (a[j]!)\n\n/-- Bounds + sortedness precondition for `bisect_right`. -/\ndef Pre {α : Type u} {γ : Type v}\n    (a : Array α) (lo hi : Nat) (key? : Option (α → γ))\n    [LE γ] [DecidableRel (· ≤ · : γ → γ → Prop)] [Coe α γ] [Inhabited α] : Prop :=\n  lo ≤ hi ∧ hi ≤ a.size ∧ SortedSlice a lo hi (Proj key?)\n\n\n\n/-!\n# Insertion Properties (`insort_right`)\n-/\n\n/-- **Splice shape**: `insort_right` equals `left.push x ++ right` at the bisect index. -/\ntheorem insort_splice_shape\n    {α γ} [LT γ] [DecidableRel (· < · : γ → γ → Prop)]\n    [Coe α γ] [Inhabited α]\n    (a : Array α) (xα : α) (lo : Nat) (hi? : Option Nat) (key? : Option (α → γ)) :\n  let idx :=\n    match key? with\n    | none     => bisect_right a ((↑xα : γ)) lo hi? (key? := none)\n    | some key => bisect_right a (key xα)       lo hi? (key? := some key)\n  insort_right a xα lo hi? key? =\n    (a.extract 0 idx).push xα ++ a.extract idx a.size := by\n  intro idx\n  simp [insort_right, idx]\n  rfl\n\n/-- **Sortedness preserved on the slice**:\nIf `a[lo:hi]` was sorted in key space, inserting at the bisect index keeps it sorted. -/\ntheorem insort_preserves_sorted_slice\n    {α γ}\n    [LT γ] [DecidableRel (· < · : γ → γ → Prop)]\n    [LE γ] [DecidableRel (· ≤ · : γ → γ → Prop)]\n    [Coe α γ] [Inhabited α]\n    (a : Array α) (xα : α) (lo : Nat) (hi? : Option Nat) (key? : Option (α → γ))\n    (hpre : Pre a lo (hi?.getD a.size) key?) :\n    let x  := match key? with | none => (↑xα : γ) | some key => key xα\n    let i  := bisect_right a x lo hi? key?\n    let a' := insort_right a xα lo hi? key?;\n    SortedSlice a' lo (i+1) (Proj key?) ∧\n    SortedSlice a' (i+1) (hi?.getD a.size + 1) (Proj key?) := by\n  -- `let`-bindings are part of the goal; no additional `intro`s needed.\n  sorry\n\n/-- **Insert partition**:\nAfter `insort_right`, elements before `i` are `≤ x` and elements at/after `i+1` are `> x`. -/\ntheorem insort_partition_after_insert\n    {α γ}\n    [LT γ] [DecidableRel (· < · : γ → γ → Prop)]\n    [LE γ] [DecidableRel (· ≤ · : γ → γ → Prop)]\n    [Coe α γ] [Inhabited α]\n    (a : Array α) (xα : α) (lo : Nat) (hi? : Option Nat) (key? : Option (α → γ))\n    (hpre : Pre a lo (hi?.getD a.size) key?) :\n    let proj := Proj key?\n    let x := match key? with | none => (↑xα : γ) | some key => key xα\n    let i := bisect_right a x lo hi? key?\n    let a' := insort_right a xα lo hi? key?;\n    (∀ j, lo ≤ j → j < i → proj (a'[j]!) ≤ x) ∧\n    (∀ j, i+1 ≤ j → j < a'.size → x < proj (a'[j]!)) := by\n  -- Same note: the `let`-bindings are already in the goal context.\n  sorry\n\n\nend Bisect\n"
}