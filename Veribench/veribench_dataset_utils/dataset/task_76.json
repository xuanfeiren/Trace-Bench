{
  "task_id": 76,
  "python_code": "# File: humaneval_31_is_prime.py\n# HumanEval problem HumanEval/31\n\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n\n# Test function\n\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n\n\n# Run tests\nif __name__ == \"__main__\":\n    check(is_prime)\n    print(\"All tests passed!\")",
  "gold_reference_lean4_code": "/-!\n\n# VeriBench – Is Prime\n\nFile order:\n\n1. Implementation\n2. Unit tests (positive, edge, positive/negative test suite)\n3. Pre‑condition prop\n4. Exhaustive property prop and their theorems\n5. Post‑condition prop (same order as property props)\n6. Correctness theorem `Pre → Post`\n7. Imperative i. implementation, ii. tests (positive, edge, positive/negative\ntest suite), and iii. equivalence theorem.\n\nAll real proofs are left as `sorry` for the learner/model/agent.\n\n# Implementation\n\n## Is Prime\n\nImplements `isPrime`, which checks if a number is prime.-/\n\nnamespace PrimeCheck\n\n/--\n**Implementation of `isPrime`.**\n\nA prime number is a natural number greater than 1 that is only divisible by 1 and itself.\nReturns true if the input number is prime, false otherwise.\n\n## Examples\n\n#eval isPrime 2 -- expected: true\n#eval isPrime 3 -- expected: true\n#eval isPrime 4 -- expected: false\n#eval isPrime 5 -- expected: true\n-/\npartial def isPrime (n : Nat) : Bool :=\n  if n < 2 then\n    false\n  else\n    let rec checkDivisors (k : Nat) : Bool :=\n      if k * k > n then\n        true\n      else if n % k = 0 then\n        false\n      else\n        checkDivisors (k + 1)\n    checkDivisors 2\n\n/-!\n# Tests\n-/\n\n/-- expected: true -/\nexample : isPrime 2 = true := by sorry\n#eval isPrime 2\n\n/-- expected: true -/\nexample : isPrime 3 = true := by sorry\n#eval isPrime 3\n\n/-!\n# Tests: Edge Cases\n-/\n\n/-- expected: false -/\nexample : isPrime 4 = false := by sorry\n#eval isPrime 4\n\n/-- expected: true -/\nexample : isPrime 5 = true := by sorry\n#eval isPrime 5\n\n/-!\n# Positive / Negative Test‑Suite\n-/\n\n/-- positive: small prime -/\nexample : isPrime 7 = true := by sorry\n#eval isPrime 7 -- expected: true\n\n/-- positive: larger prime -/\nexample : isPrime 17 = true := by sorry\n#eval isPrime 17 -- expected: true\n\n/-- negative: 1 is not prime -/\nexample : ¬ (isPrime 1 = true) := by sorry\n#eval (decide (isPrime 1 = true)) -- expected: false\n\n/-- negative: composite number -/\nexample : ¬ (isPrime 9 = true) := by sorry\n#eval (decide (isPrime 9 = true)) -- expected: false\n\n/-!\n# Pre‑Condition\n-/\n\n/-- **Pre‑condition.** Any natural number is valid input. -/\ndef Pre (n : Nat) : Prop := True\n\n/-!\n# Property Theorems\n-/\n\n/-- **Small numbers property**: Numbers less than 2 are not prime. -/\ndef small_numbers_prop (n : Nat) : Prop := n < 2 → isPrime n = false\n\n/-- **Small numbers theorem**: Numbers less than 2 are not prime. -/\n@[simp] theorem small_numbers_thm (n : Nat) : small_numbers_prop n := sorry\n\n/-- **Two is prime property**: 2 is prime. -/\ndef two_is_prime_prop : Prop := isPrime 2 = true\n\n/-- **Two is prime theorem**: 2 is prime. -/\n@[simp] theorem two_is_prime_thm : two_is_prime_prop := sorry\n\n/-- **Composite property**: If n has a divisor between 2 and sqrt(n), it's not prime. -/\ndef composite_prop (n : Nat) : Prop :=\n  n ≥ 2 → (∃ k, 2 ≤ k ∧ k * k ≤ n ∧ n % k = 0) → isPrime n = false\n\n/-- **Composite theorem**: If n has a divisor between 2 and sqrt(n), it's not prime. -/\n@[simp] theorem composite_thm (n : Nat) : composite_prop n := sorry\n\n/-- **Prime definition property**: Prime numbers have exactly two divisors. -/\ndef prime_definition_prop (n : Nat) : Prop :=\n  isPrime n = true → n > 1 ∧ ∀ k, k ∣ n → k = 1 ∨ k = n\n\n/-- **Prime definition theorem**: Prime numbers have exactly two divisors. -/\n@[simp] theorem prime_definition_thm (n : Nat) : prime_definition_prop n := sorry\n\n/-- **Deterministic property**: isPrime always returns the same result for the same input. -/\ndef deterministic_prop (n : Nat) : Prop :=\n  isPrime n = isPrime n\n\n/-- **Deterministic theorem**: isPrime always returns the same result for the same input. -/\n@[simp] theorem deterministic_thm (n : Nat) : deterministic_prop n := sorry\n\n/-!\n# Post‑Condition  (conjunction of all desired properties)\n-/\n\n/-- **Post‑condition**: conjunction of all desired properties for isPrime. -/\ndef Post_prop (n : Nat) : Prop :=\n  (small_numbers_prop n) ∧                               -- small_numbers_prop\n  (two_is_prime_prop) ∧                                  -- two_is_prime_prop\n  (composite_prop n) ∧                                   -- composite_prop\n  (prime_definition_prop n) ∧                            -- prime_definition_prop\n  (deterministic_prop n)                                 -- deterministic_prop\n\n/-!\n# Correctness Theorem\n-/\n\n/-- **Correctness theorem**: the pre‑condition implies the post‑condition. -/\ntheorem correctness_thm (n : Nat) (hPre : Pre n) : Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\n`isPrimeImp n` computes the same result using imperative style with explicit loops.\n-/\ndef isPrimeImp (n : Nat) : Bool :=\n  Id.run do\n    if n < 2 then\n      return false\n\n    let mut k := 2\n    while k * k ≤ n do\n      if n % k = 0 then\n        return false\n      k := k + 1\n\n    return true\n\n/-!\n# Imperative Tests\n-/\n\n/-- expected: true -/\nexample : isPrimeImp 2 = true := by sorry\n#eval isPrimeImp 2\n\n/-!\n# Imperative Tests: Edge Cases\n-/\n\n/-- expected: true -/\nexample : isPrimeImp 3 = true := by sorry\n#eval isPrimeImp 3\n\n/-- expected: false -/\nexample : isPrimeImp 4 = false := by sorry\n#eval isPrimeImp 4\n\n/-!\n# Positive / Negative Test‑Suite\n-/\n\n/-- positive: prime number -/\nexample : isPrimeImp 13 = true := by sorry\n#eval isPrimeImp 13 -- expected: true\n\n/-- negative: composite number -/\nexample : ¬ (isPrimeImp 15 = true) := by sorry\n#eval (decide (isPrimeImp 15 = true)) -- expected: false\n\n/-- **Equivalence theorem**: functional and imperative implementations coincide. -/\ntheorem isPrime_equivalence_thm (n : Nat) :\n  isPrime n = isPrimeImp n := sorry\n\nend PrimeCheck\n"
}