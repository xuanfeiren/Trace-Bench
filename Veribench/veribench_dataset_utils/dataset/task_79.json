{
  "task_id": 79,
  "python_code": "# File: humaneval_33_sort_third.py\n# HumanEval problem HumanEval/33\n\ndef sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n\n# Test function\n\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n\n\n# Run tests\nif __name__ == \"__main__\":\n    check(sort_third)\n    print(\"All tests passed!\")",
  "gold_reference_lean4_code": "/-!\n# VeriBench – Sort Third\n\nFile order:\n\n1. Implementation\n2. Unit tests (positive, edge, positive/negative test suite)\n3. Pre‑condition prop\n4. Exhaustive property prop and their theorems\n5. Post‑condition prop (same order as property props)\n6. Correctness theorem `Pre → Post`\n7. Imperative i. implementation, ii. tests (positive, edge, positive/negative\ntest suite), and iii. equivalence theorem.\n\nAll real proofs are left as `sorry` for the learner/model/agent.\n\n# Implementation\n\n## Sort Third\n\nSorts elements at indices divisible by three in a list while preserving other elements.-/\n\nnamespace SortThird\n\n/-- Helper function to sort a list using insertion sort -/\ndef insertionSort (l : List Int) : List Int :=\n  let rec insert (x : Int) (l : List Int) : List Int :=\n    match l with\n    | [] => [x]\n    | h::t => if x ≤ h then x::h::t else h::(insert x t)\n\n  let rec sort (l : List Int) : List Int :=\n    match l with\n    | [] => []\n    | h::t => insert h (sort t)\n\n  sort l\n\n/--\n**Implementation of `sort_third`.**\n\n`sort_third l` sorts elements at indices divisible by three in a list while preserving other elements.\n\nGiven a list l, returns a list l' where:\n1. Elements at indices not divisible by 3 remain unchanged\n2. Elements at indices divisible by 3 (0, 3, 6, ...) are sorted in ascending order\n\n## Examples\n\n#eval sort_third [1, 2, 3]  -- expected: [1, 2, 3]\n#eval sort_third [5, 6, 3, 4, 8, 9, 2]  -- expected: [2, 6, 3, 4, 8, 9, 5]\n-/\ndef sort_third (l : List Int) : List Int :=\n  let indices := List.range l.length\n  let third_indices := indices.filter (fun i => i % 3 = 0)\n  let third_values := third_indices.map (fun i => l[i]!)\n  let sorted_third := insertionSort third_values\n  let rec update_list (curr : List Int) (pos : List Nat) (vals : List Int) : List Int :=\n    match pos, vals with\n    | [], _ => curr\n    | _, [] => curr\n    | p::ps, v::vs =>\n      let new_curr := curr.set p v\n      update_list new_curr ps vs\n\n  update_list l third_indices sorted_third\n\n/-!\n# Tests\n-/\n\n/-- expected: [1, 2, 3] -/\nexample : sort_third [1, 2, 3] = [1, 2, 3] := by native_decide\n#eval sort_third [1, 2, 3] -- expected: [1, 2, 3]\n\n/-- expected: [2, 6, 3, 4, 8, 9, 5] -/\nexample : sort_third [5, 6, 3, 4, 8, 9, 2] = [2, 6, 3, 4, 8, 9, 5] := by native_decide\n#eval sort_third [5, 6, 3, 4, 8, 9, 2] -- expected: [2, 6, 3, 4, 8, 9, 5]\n\n/-!\n# Tests: Edge Cases\n-/\n\n/-- expected: [] -/\nexample : sort_third [] = [] := by native_decide\n#eval sort_third [] -- expected: []\n\n/-- expected: [1] -/\nexample : sort_third [1] = [1] := by native_decide\n#eval sort_third [1] -- expected: [1]\n\n/-!\n# Positive / Negative Test‑Suite\n-/\n\n/-- positive test: elements at third indices are sorted -/\nexample : sort_third [3, 2, 1, 6, 5, 4] = [3, 2, 1, 6, 5, 4] := by native_decide\n#eval sort_third [3, 2, 1, 6, 5, 4] -- expected: [3, 2, 1, 6, 5, 4]\n\n/-- positive test: larger list -/\nexample : sort_third [9, 8, 7, 6, 5, 4, 3, 2, 1] = [3, 8, 7, 6, 5, 4, 9, 2, 1] := by native_decide\n#eval sort_third [9, 8, 7, 6, 5, 4, 3, 2, 1] -- expected: [3, 8, 7, 6, 5, 4, 9, 2, 1]\n\n/-- negative test: non-third indices change -/\nexample : ¬ (sort_third [5, 6, 3, 4, 8, 9, 2] = [5, 6, 3, 4, 8, 9, 2]) := by native_decide\n\n/-- negative test: different input gives different result -/\nexample : ¬ (sort_third [1, 2, 3] = sort_third [3, 2, 1]) := by native_decide\n\n/-!\n# Pre‑Condition\n-/\n\n/-- **Pre‑condition.** Any list is valid input. -/\ndef Pre (_ : List Int) : Prop := True\n\n/-!\n# Property Theorems\n-/\n\n/-- **Length preservation property**: Length is preserved. -/\ndef length_preservation_prop (l : List Int) : Prop := (sort_third l).length = l.length\n\n/-- **Length preservation theorem**: Length is preserved. -/\n@[simp] theorem length_preservation_thm (l : List Int) : length_preservation_prop l := sorry\n\n/-- **Non-third preservation property**: Elements at non-third indices remain unchanged. -/\ndef non_third_preservation_prop (l : List Int) : Prop :=\n  ∀ i, i < l.length → i % 3 ≠ 0 → (sort_third l)[i]! = l[i]!\n\n/-- **Non-third preservation theorem**: Elements at non-third indices remain unchanged. -/\n@[simp] theorem non_third_preservation_thm (l : List Int) : non_third_preservation_prop l := sorry\n\n/-- **Third sorting property**: Elements at third indices are sorted in ascending order. -/\ndef third_sorting_prop (l : List Int) : Prop :=\n  ∀ i j, i < l.length → j < l.length → i % 3 = 0 → j % 3 = 0 → i < j → (sort_third l)[i]! ≤ (sort_third l)[j]!\n\n/-- **Third sorting theorem**: Elements at third indices are sorted in ascending order. -/\n@[simp] theorem third_sorting_thm (l : List Int) : third_sorting_prop l := sorry\n\n/-- **Idempotent property**: sort_third is idempotent. -/\ndef idempotent_prop (l : List Int) : Prop := sort_third (sort_third l) = sort_third l\n\n/-- **Idempotent theorem**: sort_third is idempotent. -/\n@[simp] theorem idempotent_thm (l : List Int) : idempotent_prop l := sorry\n\n/-!\n# Post‑Condition  (conjunction of all desired properties)\n-/\n\n/-- **Post‑condition**: conjunction of all desired properties for sort_third. -/\ndef Post_prop (l : List Int) : Prop :=\n  (length_preservation_prop l) ∧                         -- length preservation property\n  (non_third_preservation_prop l) ∧                      -- non-third preservation property\n  (third_sorting_prop l) ∧                               -- third sorting property\n  (idempotent_prop l)                                    -- idempotent property\n\n/-!\n# Correctness Theorem\n-/\n\n/-- **Correctness theorem**: the pre‑condition implies the post‑condition. -/\ntheorem correctness_thm (l : List Int) (hPre : Pre l) : Post_prop l := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\n`sort_thirdImp l` computes the same result using imperative style with mutable arrays.\n-/\ndef sort_thirdImp (l : List Int) : List Int :=\n  Id.run do\n    let mut result := l.toArray\n    let mut third_values : List Int := []\n    let mut third_indices : List Nat := []\n\n    -- Collect third indices and their values\n    for i in [:l.length] do\n      if i % 3 = 0 then\n        third_values := third_values ++ [l[i]!]\n        third_indices := third_indices ++ [i]\n\n    -- Sort third values\n    third_values := insertionSort third_values\n\n    -- Update the result array using runtime bounds checking\n    for i in [:third_indices.length] do\n      let idx := third_indices[i]!\n      let val := third_values[i]!\n      -- Use runtime bounds checking with ! notation\n      if idx < result.size then\n        result := result.set! idx val\n\n    return result.toList\n\n/-!\n# Imperative Tests\n-/\n\n/-- expected: [1, 2, 3] -/\nexample : sort_thirdImp [1, 2, 3] = [1, 2, 3] := by native_decide\n#eval sort_thirdImp [1, 2, 3] -- expected: [1, 2, 3]\n\n/-!\n# Imperative Tests: Edge Cases\n-/\n\n/-- expected: [2, 6, 3, 4, 8, 9, 5] -/\nexample : sort_thirdImp [5, 6, 3, 4, 8, 9, 2] = [2, 6, 3, 4, 8, 9, 5] := by native_decide\n#eval sort_thirdImp [5, 6, 3, 4, 8, 9, 2] -- expected: [2, 6, 3, 4, 8, 9, 5]\n\n/-!\n# Positive / Negative Test‑Suite\n-/\n\n/-- positive test: finds correct result -/\nexample : sort_thirdImp [9, 8, 7, 6, 5, 4, 3, 2, 1] = [3, 8, 7, 6, 5, 4, 9, 2, 1] := by native_decide\n#eval sort_thirdImp [9, 8, 7, 6, 5, 4, 3, 2, 1] -- expected: [3, 8, 7, 6, 5, 4, 9, 2, 1]\n\n/-- negative test: not exactly the same as unsorted -/\nexample : ¬ (sort_thirdImp [5, 6, 3, 4, 8, 9, 2] = [5, 6, 3, 4, 8, 9, 2]) := by native_decide\n\n/-- **Equivalence theorem**: functional and imperative implementations coincide. -/\ntheorem sort_third_equivalence_thm (l : List Int) :\n  sort_third l = sort_thirdImp l := sorry\n\nend SortThird\n"
}