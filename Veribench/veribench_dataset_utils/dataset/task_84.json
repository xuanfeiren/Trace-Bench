{
  "task_id": 84,
  "python_code": "# File: humaneval_38_encode_cyclic.py\n# HumanEval problem HumanEval/38\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    returns encoded string by cycling groups of three characters.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n    return encode_cyclic(encode_cyclic(s))\n\n# Test function\n\n\nMETADATA = {}\n\n\ndef check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n\n\n# Run tests\nif __name__ == \"__main__\":\n    check(decode_cyclic)\n    print(\"All tests passed!\")",
  "gold_reference_lean4_code": "/-!\n# VeriBench – Cyclic Encoding\n\nFile order:\n\n1. Implementation\n2. Unit tests (positive, edge, positive/negative test suite)\n3. Pre‑condition prop\n4. Exhaustive property prop and their theorems\n5. Post‑condition prop (same order as property props)\n6. Correctness theorem `Pre → Post`\n7. Imperative i. implementation, ii. tests (positive, edge, positive/negative\ntest suite), and iii. equivalence theorem.\n\nAll real proofs are left as `sorry` for the learner/model/agent.\n\n# Implementation\n\n## Cyclic String Encoding\n\nImplements cyclic encoding and decoding of strings, where each group of three characters\nis cycled by moving the first character to the end.-/\n\nnamespace CyclicEncoding\n\n/--\nSplits a list of characters into groups of size n.\nReturns a list of lists, where each inner list has at most n elements.\n\nNote: This function is marked as partial because Lean's termination checker\ncannot verify its termination, though we know it terminates because:\n1. Each recursive call processes a shorter suffix of the input list\n2. The function returns when the input list is empty\n\n## Examples\n\n#eval splitIntoGroups ['a', 'b', 'c', 'd', 'e'] 3  -- expected: [['a', 'b', 'c'], ['d', 'e']]\n#eval splitIntoGroups ['a', 'b'] 3                 -- expected: [['a', 'b']]\n-/\npartial def splitIntoGroups (chars : List Char) (n : Nat) : List (List Char) :=\n  match chars with\n  | [] => []\n  | _ =>\n    let group := chars.take n\n    group :: splitIntoGroups (chars.drop n) n\n\n/--\nCycles a group of characters if it has exactly 3 elements.\nFor groups of other sizes, returns the group unchanged.\n\n## Examples\n\n#eval cycleGroup ['a', 'b', 'c']  -- expected: ['b', 'c', 'a']\n#eval cycleGroup ['a', 'b']       -- expected: ['a', 'b']\n-/\ndef cycleGroup (group : List Char) : List Char :=\n  if group.length = 3 then\n    group.drop 1 ++ group.take 1\n  else\n    group\n\n/--\n**Implementation of `encode_cyclic`.**\n\n`encode_cyclic s` encodes a string by cycling each group of three characters.\nGroups with fewer than 3 characters are left unchanged.\n\n## Examples\n\n#eval encode_cyclic \"abcdef\"  -- expected: \"bcadef\"\n#eval encode_cyclic \"abc\"     -- expected: \"bca\"\n#eval encode_cyclic \"abcd\"    -- expected: \"bcad\"\n-/\ndef encode_cyclic (s : String) : String :=\n  let groups := splitIntoGroups s.data 3\n  let cycled := groups.map cycleGroup\n  String.mk (List.flatten cycled)\n\n/--\nDecodes a string that was encoded with `encode_cyclic`.\nApplies the encoding function twice to return the original string.\n\n## Examples\n\n#eval decode_cyclic (encode_cyclic \"abcdef\")  -- expected: \"abcdef\"\n#eval decode_cyclic (encode_cyclic \"abc\")     -- expected: \"abc\"\n-/\ndef decode_cyclic (s : String) : String :=\n  encode_cyclic (encode_cyclic s)\n\n/-!\n# Tests\n-/\n\n/-- expected: \"bcadef\" -/\nexample : encode_cyclic \"abcdef\" = \"bcadef\" := by sorry\n#eval encode_cyclic \"abcdef\" -- expected: \"bcadef\"\n\n/-- expected: \"bca\" -/\nexample : encode_cyclic \"abc\" = \"bca\" := by sorry\n#eval encode_cyclic \"abc\" -- expected: \"bca\"\n\n/-!\n# Tests: Edge Cases\n-/\n\n/-- expected: \"bcad\" -/\nexample : encode_cyclic \"abcd\" = \"bcad\" := by sorry\n#eval encode_cyclic \"abcd\" -- expected: \"bcad\"\n\n/-- expected: \"\" -/\nexample : encode_cyclic \"\" = \"\" := by sorry\n#eval encode_cyclic \"\" -- expected: \"\"\n\n/-!\n# Positive / Negative Test‑Suite\n-/\n\n/-- positive test: decoding works -/\nexample : decode_cyclic (encode_cyclic \"abcdef\") = \"abcdef\" := by sorry\n#eval decode_cyclic (encode_cyclic \"abcdef\") -- expected: \"abcdef\"\n\n/-- positive test: decoding works for short strings -/\nexample : decode_cyclic (encode_cyclic \"abc\") = \"abc\" := by sorry\n#eval decode_cyclic (encode_cyclic \"abc\") -- expected: \"abc\"\n\n/-- negative test: encoding changes the string -/\nexample : ¬ (encode_cyclic \"abcdef\" = \"abcdef\") := by sorry\n\n/-- negative test: different strings encode differently -/\nexample : ¬ (encode_cyclic \"abc\" = encode_cyclic \"def\") := by sorry\n\n/-!\n# Pre‑Condition\n-/\n\n/-- **Pre‑condition.** Any string is valid input. -/\ndef Pre (_ : String) : Prop := True\n\n/-!\n# Property Theorems\n-/\n\n/-- **Length preservation property**: Encoding preserves string length. -/\ndef length_preservation_prop (s : String) : Prop :=\n  (encode_cyclic s).length = s.length\n\n/-- **Length preservation theorem**: Encoding preserves string length. -/\n@[simp] theorem length_preservation_thm (s : String) : length_preservation_prop s := sorry\n\n/-- **Decoding correctness property**: Decoding an encoded string returns the original. -/\ndef decoding_correctness_prop (s : String) : Prop :=\n  decode_cyclic (encode_cyclic s) = s\n\n/-- **Decoding correctness theorem**: Decoding an encoded string returns the original. -/\n@[simp] theorem decoding_correctness_thm (s : String) : decoding_correctness_prop s := sorry\n\n/-- **Empty string property**: Empty string returns empty string. -/\ndef empty_string_prop : Prop := encode_cyclic \"\" = \"\"\n\n/-- **Empty string theorem**: Empty string returns empty string. -/\n@[simp] theorem empty_string_thm : empty_string_prop := sorry\n\n/-- **Group preservation property**: Number of groups is preserved. -/\ndef group_preservation_prop (s : String) : Prop :=\n  (splitIntoGroups s.data 3).length = (splitIntoGroups (encode_cyclic s).data 3).length\n\n/-- **Group preservation theorem**: Number of groups is preserved. -/\n@[simp] theorem group_preservation_thm (s : String) : group_preservation_prop s := sorry\n\n/-!\n# Post‑Condition  (conjunction of all desired properties)\n-/\n\n/-- **Post‑condition**: conjunction of all desired properties for encode_cyclic. -/\ndef Post_prop (s : String) : Prop :=\n  (length_preservation_prop s) ∧                         -- length preservation property\n  (decoding_correctness_prop s) ∧                        -- decoding correctness property\n  (empty_string_prop) ∧                                  -- empty string property\n  (group_preservation_prop s)                            -- group preservation property\n\n/-!\n# Correctness Theorem\n-/\n\n/-- **Correctness theorem**: the pre‑condition implies the post‑condition. -/\ntheorem correctness_thm (s : String) (hPre : Pre s) : Post_prop s := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\n`encode_cyclicImp s` computes the same result using imperative style with explicit loops.\n-/\ndef encode_cyclicImp (s : String) : String :=\n  Id.run do\n    let mut result : List Char := []\n    let mut i := 0\n    while i < s.length do\n      let group := s.data.drop i |>.take 3\n      if group.length = 3 then\n        result := result ++ group.drop 1 ++ group.take 1\n      else\n        result := result ++ group\n      i := i + 3\n    return String.mk result\n\n/-!\n# Imperative Tests\n-/\n\n/-- expected: \"bcadef\" -/\nexample : encode_cyclicImp \"abcdef\" = \"bcadef\" := by sorry\n#eval encode_cyclicImp \"abcdef\" -- expected: \"bcadef\"\n\n/-!\n# Imperative Tests: Edge Cases\n-/\n\n/-- expected: \"bca\" -/\nexample : encode_cyclicImp \"abc\" = \"bca\" := by sorry\n#eval encode_cyclicImp \"abc\" -- expected: \"bca\"\n\n/-!\n# Positive / Negative Test‑Suite\n-/\n\n/-- positive test: empty string -/\nexample : encode_cyclicImp \"\" = \"\" := by sorry\n#eval encode_cyclicImp \"\" -- expected: \"\"\n\n/-- negative test: encoding changes the string -/\nexample : ¬ (encode_cyclicImp \"abcdef\" = \"abcdef\") := by sorry\n\n/-- **Equivalence theorem**: functional and imperative implementations coincide. -/\ntheorem encode_cyclic_equivalence_thm (s : String) :\n  encode_cyclic s = encode_cyclicImp s := sorry\n\nend CyclicEncoding\n"
}