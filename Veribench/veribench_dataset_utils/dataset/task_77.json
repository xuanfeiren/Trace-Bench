{
  "task_id": 77,
  "python_code": "\"\"\"Find a root of a polynomial via bisection on a given bracket [a, b].\n\nWe evaluate a polynomial with coefficients xs at x as:\n    xs[0] + xs[1]*x + xs[2]*x**2 + ...\n\nEdge cases:\n- Requires a non-empty coefficient list and a < b.\n- Requires the bracket to contain a sign change or a root (f(a)*f(b) <= 0).\n\"\"\"\n\nfrom typing import Callable, List\n\n# -- Implementation --\n\ndef pre(xs: List[float], a: float, b: float, fuel: int) -> bool:\n    return (\n        isinstance(xs, list)\n        and len(xs) > 0\n        and all(isinstance(c, (int, float)) for c in xs)\n        and isinstance(a, (int, float))\n        and isinstance(b, (int, float))\n        and isinstance(fuel, int) and fuel >= 0\n        and a < b\n        and poly(xs, a) * poly(xs, b) <= 0\n    )\n\ndef poly(xs: List[float], x: float) -> float:\n    acc = 0.0\n    p = 1.0\n    for c in xs:\n        acc += float(c) * p\n        p *= float(x)\n    return acc\n\ndef find_zero(xs: List[float], a: float, b: float, fuel: int) -> float:\n    \"\"\"\n    Return an approximate root of the polynomial defined by xs on [a, b].\n    Uses bisection up to `fuel` iterations.\n    \"\"\"\n    if not pre(xs, a, b, fuel):\n        raise ValueError(\"Invalid inputs or bracket does not contain a root\")\n\n    left, right = float(a), float(b)\n    for _ in range(fuel):\n        mid = (left + right) / 2.0\n        f_mid = poly(xs, mid)\n        if abs(f_mid) < 1e-10:\n            return mid\n        if poly(xs, left) * f_mid <= 0:\n            right = mid\n        else:\n            left = mid\n    return (left + right) / 2.0\n\n\n# -- Tests --\n\ndef check(candidate: Callable[[List[float], float, float, int], float]) -> bool:\n    # Basic unit tests (close to expected roots)\n    r1 = candidate([1.0, 2.0], -1.0, 0.0, 100)\n    assert abs(r1 + 0.5) < 1e-2\n\n    r2 = candidate([-6.0, 11.0, -6.0, 1.0], 0.0, 2.0, 100)\n    assert abs(r2 - 1.0) < 1e-2\n\n    # Edge unit tests\n    r3 = candidate([0.0, 1.0], -1.0, 1.0, 100)\n    assert abs(r3 - 0.0) < 1e-2\n\n    r4 = candidate([4.0, -4.0, 1.0], 1.0, 3.0, 100)\n    assert abs(r4 - 2.0) < 1e-2\n\n    # Negative (pre-violations must raise ValueError)\n    bad = [([], -1.0, 1.0, 10), ([1.0], 0.0, 1.0, -1), ([1.0], 1.0, 0.0, 10)]\n    for xs, a, b, fuel in bad:\n        try:\n            candidate(xs, a, b, fuel)\n            raise AssertionError(\"expected pre-violation did not raise\")\n        except ValueError:\n            pass\n\n    return True\n\nif __name__ == \"__main__\":\n    assert check(find_zero), f\"Failed: {__file__}\"\n    print(\"All tests passed.\")",
  "gold_reference_lean4_code": "/-!\n# VeriBench – Find Zero\n\nFile order:\n\n1. Implementation\n2. Unit tests (positive, edge, positive/negative test suite)\n3. Pre‑condition prop\n4. Exhaustive property prop and their theorems\n5. Post‑condition prop (same order as property props)\n6. Correctness theorem `Pre → Post`\n7. Imperative i. implementation, ii. tests (positive, edge, positive/negative\ntest suite), and iii. equivalence theorem.\n\nAll real proofs are left as `sorry` for the learner/model/agent.\n\n# Implementation\n\n## Find Zero\n\nImplements `find_zero`, which finds a root of a polynomial using binary search method within a given bracket.-/\n\nnamespace PolynomialRoot\n\n/-- Small epsilon value for float comparisons -/\ndef epsilon : Float := 1e-10\n\n/--\nEvaluates a polynomial at a given point x.\n\nGiven a list of coefficients [a₀, a₁, ..., aₙ], evaluates:\na₀ + a₁x + a₂x² + ... + aₙxⁿ\n-/\ndef poly (xs : List Float) (x : Float) : Float :=\n  let rec eval_at (i : Nat) (acc : Float) : Float :=\n    match i with\n    | 0 => acc\n    | n + 1 =>\n      match xs[n]? with\n      | none => acc\n      | some coeff => eval_at n (acc + coeff * (x ^ n.toFloat))\n  eval_at xs.length 0\n\n/--\n**Implementation of `find_zero`.**\n\n`find_zero xs a b fuel` finds a root of a polynomial using binary search method within the bracket [a, b].\nReturns an x such that poly(x) ≈ 0. Uses binary search for a maximum of `fuel` iterations.\n\n## Examples\n\n#eval find_zero [1.0, 2.0] (-1.0) 0.0 100 -- expected: close to -0.5 (root of 1 + 2x)\n#eval find_zero [-6.0, 11.0, -6.0, 1.0] 0.0 2.0 100 -- expected: close to 1.0 (root of (x-1)(x-2)(x-3))\n-/\ndef find_zero (xs : List Float) (a b : Float) (fuel : Nat) : Float :=\n  match fuel with\n  | 0 => (a + b) / 2\n  | fuel + 1 =>\n    let mid := (a + b) / 2\n    let f_mid := poly xs mid\n    if Float.abs f_mid < epsilon then\n      mid\n    else if poly xs a * f_mid ≤ 0 then\n      find_zero xs a mid fuel\n    else\n      find_zero xs mid b fuel\n\n/-!\n# Tests\n-/\n\n/-- expected: close to -0.5 -/\nexample : Float.abs (find_zero [1.0, 2.0] (-1.0) 0.0 100 + 0.5) < 0.01 := by sorry\n#eval find_zero [1.0, 2.0] (-1.0) 0.0 100 -- expected: close to -0.5\n\n/-- expected: close to 1.0 -/\nexample : Float.abs (find_zero [-6.0, 11.0, -6.0, 1.0] 0.0 2.0 100 - 1.0) < 0.01 := by sorry\n#eval find_zero [-6.0, 11.0, -6.0, 1.0] 0.0 2.0 100 -- expected: close to 1.0\n\n/-!\n# Tests: Edge Cases\n-/\n\n/-- expected: close to 0.0 -/\nexample : Float.abs (find_zero [0.0, 1.0] (-1.0) 1.0 100) < 0.01 := by sorry\n#eval find_zero [0.0, 1.0] (-1.0) 1.0 100 -- expected: close to 0.0\n\n/-- expected: close to 2.0 -/\nexample : Float.abs (find_zero [4.0, -4.0, 1.0] 1.0 3.0 100 - 2.0) < 0.01 := by sorry\n#eval find_zero [4.0, -4.0, 1.0] 1.0 3.0 100 -- expected: close to 2.0\n\n/-!\n# Positive / Negative Test‑Suite\n-/\n\n/-- positive test: linear polynomial -/\nexample : Float.abs (find_zero [3.0, -1.0] 0.0 4.0 100 - 3.0) < 0.01 := by sorry\n#eval find_zero [3.0, -1.0] 0.0 4.0 100 -- expected: close to 3.0\n\n/-- positive test: quadratic polynomial -/\nexample : Float.abs (find_zero [-1.0, 0.0, 1.0] 0.0 2.0 100 - 1.0) < 0.01 := by sorry\n#eval find_zero [-1.0, 0.0, 1.0] 0.0 2.0 100 -- expected: close to 1.0\n\n/-- negative test: result is not exact zero (floating point) -/\nexample : ¬ (find_zero [1.0, 2.0] (-1.0) 0.0 100 = 0.0) := by sorry\n-- Note: removed #eval decide due to Decidable instance issues with Float equality\n\n/-- negative test: different polynomials give different roots -/\nexample : ¬ (find_zero [1.0, 2.0] (-1.0) 0.0 100 = find_zero [2.0, 1.0] (-2.0) 0.0 100) := by sorry\n-- Note: removed #eval decide due to Decidable instance issues with Float equality\n\n/-!\n# Pre‑Condition\n-/\n\n/-- **Pre‑condition.** Polynomial must have at least one coefficient, and the bracket [a, b] must contain a root. -/\ndef Pre (xs : List Float) (a b : Float) : Prop :=\n  xs ≠ [] ∧ a < b ∧ poly xs a * poly xs b ≤ 0\n\n/-!\n# Property Theorems\n-/\n\n/-- **Root property**: The result is approximately a root of the polynomial. -/\ndef root_prop (xs : List Float) (a b : Float) (fuel : Nat) : Prop :=\n  Float.abs (poly xs (find_zero xs a b fuel)) < epsilon\n\n/-- **Root theorem**: The result is approximately a root of the polynomial. -/\n@[simp] theorem root_thm (xs : List Float) (a b : Float) (fuel : Nat) : root_prop xs a b fuel := sorry\n\n/-- **Bracket property**: The result lies within the given bracket. -/\ndef bracket_prop (xs : List Float) (a b : Float) (fuel : Nat) : Prop :=\n  a ≤ find_zero xs a b fuel ∧ find_zero xs a b fuel ≤ b\n\n/-- **Bracket theorem**: The result lies within the given bracket. -/\n@[simp] theorem bracket_thm (xs : List Float) (a b : Float) (fuel : Nat) : bracket_prop xs a b fuel := sorry\n\n/-- **Polynomial evaluation property**: poly evaluates polynomials correctly. -/\ndef poly_eval_prop (xs : List Float) (x : Float) : Prop :=\n  poly xs x = (xs.mapIdx (fun i c => c * (x ^ i.toFloat))).sum\n\n/-- **Polynomial evaluation theorem**: poly evaluates polynomials correctly. -/\n@[simp] theorem poly_eval_thm (xs : List Float) (x : Float) : poly_eval_prop xs x := sorry\n\n/-- **Deterministic property**: Same inputs give the same root. -/\ndef deterministic_prop (xs : List Float) (a b : Float) (fuel : Nat) : Prop :=\n  find_zero xs a b fuel = find_zero xs a b fuel\n\n/-- **Deterministic theorem**: Same inputs give the same root. -/\n@[simp] theorem deterministic_thm (xs : List Float) (a b : Float) (fuel : Nat) : deterministic_prop xs a b fuel := sorry\n\n/-!\n# Post‑Condition  (conjunction of all desired properties)\n-/\n\n/-- **Post‑condition**: conjunction of all desired properties for find_zero. -/\ndef Post_prop (xs : List Float) (a b : Float) (fuel : Nat) : Prop :=\n  (root_prop xs a b fuel) ∧                              -- root property\n  (bracket_prop xs a b fuel) ∧                           -- bracket property\n  (∀ x, poly_eval_prop xs x) ∧                           -- polynomial evaluation property\n  (deterministic_prop xs a b fuel)                       -- deterministic property\n\n/-!\n# Correctness Theorem\n-/\n\n/-- **Correctness theorem**: the pre‑condition implies the post‑condition. -/\ntheorem correctness_thm (xs : List Float) (a b : Float) (fuel : Nat) (hPre : Pre xs a b) : Post_prop xs a b fuel := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\n`find_zeroImp xs a b fuel` computes the same result using imperative style with explicit loops.\n-/\ndef find_zeroImp (xs : List Float) (a b : Float) (fuel : Nat) : Float :=\n  Id.run do\n    let mut left := a\n    let mut right := b\n    let mut result := (left + right) / 2\n\n    for _ in [1:fuel+1] do\n      let mid := (left + right) / 2\n      let f_mid := poly xs mid\n      if Float.abs f_mid < epsilon then\n        result := mid\n        break\n      if poly xs left * f_mid ≤ 0 then\n        right := mid\n      else\n        left := mid\n      result := mid\n\n    return result\n\n/-!\n# Imperative Tests\n-/\n\n/-- expected: close to -0.5 -/\nexample : Float.abs (find_zeroImp [1.0, 2.0] (-1.0) 0.0 100 + 0.5) < 0.01 := by sorry\n#eval find_zeroImp [1.0, 2.0] (-1.0) 0.0 100 -- expected: close to -0.5\n\n/-!\n# Imperative Tests: Edge Cases\n-/\n\n/-- expected: close to 1.0 -/\nexample : Float.abs (find_zeroImp [-6.0, 11.0, -6.0, 1.0] 0.0 2.0 100 - 1.0) < 0.01 := by sorry\n#eval find_zeroImp [-6.0, 11.0, -6.0, 1.0] 0.0 2.0 100 -- expected: close to 1.0\n\n/-!\n# Positive / Negative Test‑Suite\n-/\n\n/-- positive test: finds root -/\nexample : Float.abs (find_zeroImp [2.0, -1.0] 0.0 4.0 100 - 2.0) < 0.01 := by sorry\n#eval find_zeroImp [2.0, -1.0] 0.0 4.0 100 -- expected: close to 2.0\n\n/-- negative test: not exactly zero due to floating point -/\nexample : ¬ (find_zeroImp [1.0, 1.0] (-2.0) 0.0 100 = 0.0) := by sorry\n-- Note: removed #eval decide due to Decidable instance issues with Float equality\n\n/-- **Equivalence theorem**: functional and imperative implementations coincide. -/\ntheorem find_zero_equivalence_thm (xs : List Float) (a b : Float) (fuel : Nat) :\n  Float.abs (find_zero xs a b fuel - find_zeroImp xs a b fuel) < epsilon := sorry\n\nend PolynomialRoot\n"
}