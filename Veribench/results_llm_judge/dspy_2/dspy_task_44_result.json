{
  "task_idx": 44,
  "task_id": 44,
  "success": true,
  "attempts": 7,
  "best_score": 1.0,
  "best_lean_code": "/-!\n# Square or Double Function\n\nIf n is even return n\u00b2, else return 2n, for natural number n.\n\n## Properties:\n- For even n: returns n\u00b2\n- For odd n: returns 2n (which is always even)\n- Works for zero (returns 0)\n- Type safety enforced by Lean's type system\n\n## Edge Cases:\n- Zero is handled correctly (returns 0)\n- All outputs for odd inputs are even numbers\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n squared if n is even, otherwise returns 2 times n.\n\n## Properties\n- For even n: returns n\u00b2\n- For odd n: returns 2n\n- Output is always even when input is odd\n\n## Examples\n- `squareOrDouble 4 = 16` (even case)\n- `squareOrDouble 5 = 10` (odd case)\n- `squareOrDouble 0 = 0` (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! # Basic Tests -/\n\n/-- Basic test: even number case -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test: odd number case -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-! # Additional Test Cases -/\n\n/-- Additional even cases -/\nexample : squareOrDouble 2 = 4 := by native_decide\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 2  -- expected: 4\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Additional odd cases -/\nexample : squareOrDouble 3 = 6 := by native_decide\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 3  -- expected: 6\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Properties -/\n\n/-- Pre-condition: always true for Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Even case property: n\u00b2 when n is even -/\ndef even_case_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd case property: 2n when n is odd -/\ndef odd_case_prop (n : Nat) : Prop :=\n  n % 2 = 1 \u2192 squareOrDouble n = 2 * n\n\n/-- Result is even when input is odd property -/\ndef result_is_even_prop (n : Nat) : Prop :=\n  n % 2 = 1 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Monotonicity property based on parity -/\ndef monotonicity_prop (n : Nat) : Prop :=\n  (n % 2 = 0 \u2192 squareOrDouble n \u2265 n) \u2227\n  (n % 2 = 1 \u2192 squareOrDouble n \u2265 n)\n\n/-- Zero case property -/\ndef zero_case_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-! # Theorems -/\n\n/-- Even case theorem -/\ntheorem even_case_thm (n : Nat) : even_case_prop n := sorry\n\n/-- Odd case theorem -/\ntheorem odd_case_thm (n : Nat) : odd_case_prop n := sorry\n\n/-- Result is even theorem -/\ntheorem result_is_even_thm (n : Nat) : result_is_even_prop n := sorry\n\n/-- Monotonicity theorem -/\ntheorem monotonicity_thm (n : Nat) : monotonicity_prop n := sorry\n\n/-- Zero case theorem -/\ntheorem zero_case_thm : zero_case_prop := sorry\n\n/-! # Post-condition -/\n\n/-- Post-condition combines all core properties -/\ndef Post (n : Nat) : Prop :=\n  even_case_prop n \u2227\n  odd_case_prop n \u2227\n  result_is_even_prop n \u2227\n  monotonicity_prop n \u2227\n  zero_case_prop\n\n/-- Correctness theorem: Pre implies Post -/\ntheorem correctness_thm (n : Nat) (h : Pre n) : Post n := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative version using mutable state.\nMaintains same properties as functional version.\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-! # Imperative Tests -/\n\n/-- Test even cases -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\nexample : squareOrDoubleImp 2 = 4 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n#eval squareOrDoubleImp 2  -- expected: 4\n\n/-- Test odd cases -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\nexample : squareOrDoubleImp 3 = 6 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n#eval squareOrDoubleImp 3  -- expected: 6\n\n/-- Test zero case -/\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem -/\ntheorem equivalence_thm (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
  "duration_seconds": 237.45017433166504,
  "history": [
    {
      "attempt": 1,
      "score": 0.76,
      "best_score": 0.76,
      "is_new_best": true,
      "feedback": "The original code passed compilation and unit tests. We use a LLM judge to score the semantic equivalence between the golden reference and the generated Lean 4 code. Rationale from the LLM judge: While both implementations target the same core functionality (squaring even numbers and doubling odd ones), there are several significant differences:\n\n1. Type System:\n- GOLD uses `Nat` (natural numbers)\n- AGENT uses `Int` (integers)\nThis is a meaningful semantic difference as it affects the domain.\n\n2",
      "lean_code": "/-!\n# Square or Double Function\n\nThis function takes an integer n and:\n- Returns n\u00b2 if n is even\n- Returns 2n if n is odd\n\nEdge cases:\n- Works for zero (returns 0)\n- Type safety enforced by Lean's type system\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns the square of n if n is even, otherwise returns 2 times n.\n\n## Examples\n- `squareOrDouble 4 = 16`\n- `squareOrDouble 5 = 10`\n- `squareOrDouble 0 = 0`\n-/\ndef squareOrDouble (n : Int) : Int :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Basic test: even number case -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test: odd number case -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-! # Additional Test Cases -/\n\n/-- Positive test: even number -/\nexample : squareOrDouble 2 = 4 := by native_decide\n#eval squareOrDouble 2  -- expected: 4\n\n/-- Positive test: odd number -/\nexample : squareOrDouble 3 = 6 := by native_decide\n#eval squareOrDouble 3  -- expected: 6\n\n/-- Negative test: even number -/\nexample : \u00ac(squareOrDouble 4 = 8) := by native_decide\n#eval decide (squareOrDouble 4 = 8)  -- expected: false\n\n/-! # Properties -/\n\n/-- Property: result is non-negative for non-negative even inputs -/\ndef evenNonNegativeProp (n : Int) : Prop :=\n  n \u2265 0 \u2192 n % 2 = 0 \u2192 squareOrDouble n \u2265 0\n\n/-- Property: result is double the input for odd numbers -/\ndef oddDoubleProp (n : Int) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Property: result is square of input for even numbers -/\ndef evenSquareProp (n : Int) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-! # Theorems -/\n\n/-- Theorem: non-negative even inputs produce non-negative outputs -/\ntheorem evenNonNegative_thm (n : Int) : evenNonNegativeProp n := sorry\n\n/-- Theorem: odd inputs are doubled -/\ntheorem oddDouble_thm (n : Int) : oddDoubleProp n := sorry\n\n/-- Theorem: even inputs are squared -/\ntheorem evenSquare_thm (n : Int) : evenSquareProp n := sorry\n\nend SquareOrDouble",
      "best_lean_code": "/-!\n# Square or Double Function\n\nThis function takes an integer n and:\n- Returns n\u00b2 if n is even\n- Returns 2n if n is odd\n\nEdge cases:\n- Works for zero (returns 0)\n- Type safety enforced by Lean's type system\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns the square of n if n is even, otherwise returns 2 times n.\n\n## Examples\n- `squareOrDouble 4 = 16`\n- `squareOrDouble 5 = 10`\n- `squareOrDouble 0 = 0`\n-/\ndef squareOrDouble (n : Int) : Int :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Basic test: even number case -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test: odd number case -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-! # Additional Test Cases -/\n\n/-- Positive test: even number -/\nexample : squareOrDouble 2 = 4 := by native_decide\n#eval squareOrDouble 2  -- expected: 4\n\n/-- Positive test: odd number -/\nexample : squareOrDouble 3 = 6 := by native_decide\n#eval squareOrDouble 3  -- expected: 6\n\n/-- Negative test: even number -/\nexample : \u00ac(squareOrDouble 4 = 8) := by native_decide\n#eval decide (squareOrDouble 4 = 8)  -- expected: false\n\n/-! # Properties -/\n\n/-- Property: result is non-negative for non-negative even inputs -/\ndef evenNonNegativeProp (n : Int) : Prop :=\n  n \u2265 0 \u2192 n % 2 = 0 \u2192 squareOrDouble n \u2265 0\n\n/-- Property: result is double the input for odd numbers -/\ndef oddDoubleProp (n : Int) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Property: result is square of input for even numbers -/\ndef evenSquareProp (n : Int) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-! # Theorems -/\n\n/-- Theorem: non-negative even inputs produce non-negative outputs -/\ntheorem evenNonNegative_thm (n : Int) : evenNonNegativeProp n := sorry\n\n/-- Theorem: odd inputs are doubled -/\ntheorem oddDouble_thm (n : Int) : oddDoubleProp n := sorry\n\n/-- Theorem: even inputs are squared -/\ntheorem evenSquare_thm (n : Int) : evenSquareProp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 2,
      "score": 0.9333333333333333,
      "best_score": 0.9333333333333333,
      "is_new_best": true,
      "feedback": "The original code passed compilation and unit tests. We use a LLM judge to score the semantic equivalence between the golden reference and the generated Lean 4 code. Rationale from the LLM judge: The agent's implementation captures the core functionality of squaring even numbers and doubling odd ones, but there are several differences from the gold standard:\n\n1. Core Function:\n- Both implement the same logic but with different names (mySquareOrDouble vs squareOrDouble)\n- The fundamental behavior",
      "lean_code": "/-!\n# Square or Double Function\n\nThis function takes a natural number n and:\n- Returns n\u00b2 if n is even\n- Returns 2n if n is odd\n\nEdge cases:\n- Works for zero (returns 0)\n- Type safety enforced by Lean's type system\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns the square of n if n is even, otherwise returns 2 times n.\n\n## Examples\n- `squareOrDouble 4 = 16`\n- `squareOrDouble 5 = 10`\n- `squareOrDouble 0 = 0`\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! # Basic Tests -/\n\n/-- Basic test: even number case -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test: odd number case -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-! # Additional Test Cases -/\n\n/-- Positive test: even number -/\nexample : squareOrDouble 2 = 4 := by native_decide\n#eval squareOrDouble 2  -- expected: 4\n\n/-- Positive test: odd number -/\nexample : squareOrDouble 3 = 6 := by native_decide\n#eval squareOrDouble 3  -- expected: 6\n\n/-- Negative test: even number incorrect result -/\nexample : \u00ac(squareOrDouble 4 = 8) := by native_decide\n#eval decide (squareOrDouble 4 = 8)  -- expected: false\n\n/-! # Pre-conditions -/\n\n/-- Pre-condition: Input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: result is non-negative (always true for Nat) -/\ndef nonNegativeProp (n : Nat) : Prop :=\n  squareOrDouble n \u2265 0\n\n/-- Property: result is even for even inputs -/\ndef evenResultProp (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n % 2 = 0\n\n/-- Property: result equals n\u00b2 for even inputs -/\ndef evenSquareProp (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Property: result equals 2n for odd inputs -/\ndef oddDoubleProp (n : Nat) : Prop :=\n  n % 2 = 1 \u2192 squareOrDouble n = 2 * n\n\n/-- Property: zero case -/\ndef zeroProp : Prop :=\n  squareOrDouble 0 = 0\n\n/-! # Theorems -/\n\n/-- Theorem: result is always non-negative -/\ntheorem nonNegative_thm (n : Nat) : nonNegativeProp n := sorry\n\n/-- Theorem: even inputs produce even outputs -/\ntheorem evenResult_thm (n : Nat) : evenResultProp n := sorry\n\n/-- Theorem: even inputs are squared -/\ntheorem evenSquare_thm (n : Nat) : evenSquareProp n := sorry\n\n/-- Theorem: odd inputs are doubled -/\ntheorem oddDouble_thm (n : Nat) : oddDoubleProp n := sorry\n\n/-- Theorem: zero case works correctly -/\ntheorem zero_thm : zeroProp := sorry\n\n/-! # Post-condition -/\n\n/-- Post-condition: conjunction of all desired properties -/\ndef Post (n : Nat) : Prop :=\n  nonNegativeProp n \u2227\n  evenResultProp n \u2227\n  evenSquareProp n \u2227\n  oddDoubleProp n\n\n/-- Correctness theorem: Pre implies Post -/\ntheorem correctness_thm (n : Nat) (h : Pre n) : Post n := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative version that computes the same result using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-! # Imperative Tests -/\n\n/-- Test imperative version with even input -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\n/-- Test imperative version with odd input -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\n/-- Test imperative version with zero -/\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem: functional and imperative versions produce same results -/\ntheorem equivalence_thm (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "best_lean_code": "/-!\n# Square or Double Function\n\nThis function takes a natural number n and:\n- Returns n\u00b2 if n is even\n- Returns 2n if n is odd\n\nEdge cases:\n- Works for zero (returns 0)\n- Type safety enforced by Lean's type system\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns the square of n if n is even, otherwise returns 2 times n.\n\n## Examples\n- `squareOrDouble 4 = 16`\n- `squareOrDouble 5 = 10`\n- `squareOrDouble 0 = 0`\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! # Basic Tests -/\n\n/-- Basic test: even number case -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test: odd number case -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-! # Additional Test Cases -/\n\n/-- Positive test: even number -/\nexample : squareOrDouble 2 = 4 := by native_decide\n#eval squareOrDouble 2  -- expected: 4\n\n/-- Positive test: odd number -/\nexample : squareOrDouble 3 = 6 := by native_decide\n#eval squareOrDouble 3  -- expected: 6\n\n/-- Negative test: even number incorrect result -/\nexample : \u00ac(squareOrDouble 4 = 8) := by native_decide\n#eval decide (squareOrDouble 4 = 8)  -- expected: false\n\n/-! # Pre-conditions -/\n\n/-- Pre-condition: Input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: result is non-negative (always true for Nat) -/\ndef nonNegativeProp (n : Nat) : Prop :=\n  squareOrDouble n \u2265 0\n\n/-- Property: result is even for even inputs -/\ndef evenResultProp (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n % 2 = 0\n\n/-- Property: result equals n\u00b2 for even inputs -/\ndef evenSquareProp (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Property: result equals 2n for odd inputs -/\ndef oddDoubleProp (n : Nat) : Prop :=\n  n % 2 = 1 \u2192 squareOrDouble n = 2 * n\n\n/-- Property: zero case -/\ndef zeroProp : Prop :=\n  squareOrDouble 0 = 0\n\n/-! # Theorems -/\n\n/-- Theorem: result is always non-negative -/\ntheorem nonNegative_thm (n : Nat) : nonNegativeProp n := sorry\n\n/-- Theorem: even inputs produce even outputs -/\ntheorem evenResult_thm (n : Nat) : evenResultProp n := sorry\n\n/-- Theorem: even inputs are squared -/\ntheorem evenSquare_thm (n : Nat) : evenSquareProp n := sorry\n\n/-- Theorem: odd inputs are doubled -/\ntheorem oddDouble_thm (n : Nat) : oddDoubleProp n := sorry\n\n/-- Theorem: zero case works correctly -/\ntheorem zero_thm : zeroProp := sorry\n\n/-! # Post-condition -/\n\n/-- Post-condition: conjunction of all desired properties -/\ndef Post (n : Nat) : Prop :=\n  nonNegativeProp n \u2227\n  evenResultProp n \u2227\n  evenSquareProp n \u2227\n  oddDoubleProp n\n\n/-- Correctness theorem: Pre implies Post -/\ntheorem correctness_thm (n : Nat) (h : Pre n) : Post n := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative version that computes the same result using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-! # Imperative Tests -/\n\n/-- Test imperative version with even input -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\n/-- Test imperative version with odd input -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\n/-- Test imperative version with zero -/\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem: functional and imperative versions produce same results -/\ntheorem equivalence_thm (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 3,
      "score": 0.92,
      "best_score": 0.9333333333333333,
      "is_new_best": false,
      "feedback": "The original code passed compilation and unit tests. We use a LLM judge to score the semantic equivalence between the golden reference and the generated Lean 4 code. Rationale from the LLM judge: The agent's implementation captures the core functionality of squaring even numbers and doubling odd numbers, but there are several differences to note:\n\n1. Core Function:\n- Both implement the same logic but with different names (mySquareOrDouble vs squareOrDouble)\n- The fundamental behavior is identica",
      "lean_code": "/-!\n# Square or Double Function\n\nThis function takes a natural number n and:\n- Returns n\u00b2 if n is even\n- Returns 2n if n is odd\n\nEdge cases:\n- Works for zero (returns 0)\n- Type safety enforced by Lean's type system\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns the square of n if n is even, otherwise returns 2 times n.\n\n## Examples\n- `squareOrDouble 4 = 16` \n- `squareOrDouble 5 = 10`\n- `squareOrDouble 0 = 0`\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! # Basic Tests -/\n\n/-- Basic test: even number case -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test: odd number case -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-! # Additional Test Cases -/\n\n/-- Positive test: even number -/\nexample : squareOrDouble 2 = 4 := by native_decide\n#eval squareOrDouble 2  -- expected: 4\n\n/-- Positive test: odd number -/\nexample : squareOrDouble 3 = 6 := by native_decide\n#eval squareOrDouble 3  -- expected: 6\n\n/-- Negative test: even number incorrect result -/\nexample : \u00ac(squareOrDouble 4 = 8) := by native_decide\n#eval decide (squareOrDouble 4 = 8)  -- expected: false\n\n/-! # Pre-conditions -/\n\n/-- Pre-condition: Input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: result is even when input is even -/\ndef result_is_even_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n % 2 = 0\n\n/-- Property: monotonicity - output increases with input -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n < m \u2192 squareOrDouble n < squareOrDouble m\n\n/-- Property: result equals n\u00b2 for even inputs -/\ndef even_case_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Property: result equals 2n for odd inputs -/\ndef odd_case_prop (n : Nat) : Prop :=\n  n % 2 = 1 \u2192 squareOrDouble n = 2 * n\n\n/-- Property: zero case -/\ndef zero_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-! # Theorems -/\n\n/-- Theorem: result is even when input is even -/\ntheorem result_is_even_thm (n : Nat) : result_is_even_prop n := sorry\n\n/-- Theorem: function is monotonic -/\ntheorem monotonicity_thm (n m : Nat) : monotonicity_prop n m := sorry\n\n/-- Theorem: even case behavior -/\ntheorem even_case_thm (n : Nat) : even_case_prop n := sorry\n\n/-- Theorem: odd case behavior -/\ntheorem odd_case_thm (n : Nat) : odd_case_prop n := sorry\n\n/-- Theorem: zero case works correctly -/\ntheorem zero_thm : zero_prop := sorry\n\n/-! # Post-condition -/\n\n/-- Post-condition: conjunction of all desired properties -/\ndef Post (n : Nat) : Prop :=\n  result_is_even_prop n \u2227\n  (\u2200 m, monotonicity_prop n m) \u2227\n  even_case_prop n \u2227\n  odd_case_prop n\n\n/-- Correctness theorem: Pre implies Post -/\ntheorem correctness_thm (n : Nat) (h : Pre n) : Post n := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative version that computes the same result using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-! # Imperative Tests -/\n\n/-- Test imperative version with even input -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\n/-- Test imperative version with odd input -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\n/-- Test imperative version with zero -/\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Additional test cases for thorough verification -/\nexample : squareOrDoubleImp 6 = 36 := by native_decide\nexample : squareOrDoubleImp 7 = 14 := by native_decide\nexample : squareOrDoubleImp 8 = 64 := by native_decide\nexample : squareOrDoubleImp 9 = 18 := by native_decide\n\n/-- Equivalence theorem: functional and imperative versions produce same results -/\ntheorem equivalence_thm (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "best_lean_code": "/-!\n# Square or Double Function\n\nThis function takes a natural number n and:\n- Returns n\u00b2 if n is even\n- Returns 2n if n is odd\n\nEdge cases:\n- Works for zero (returns 0)\n- Type safety enforced by Lean's type system\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns the square of n if n is even, otherwise returns 2 times n.\n\n## Examples\n- `squareOrDouble 4 = 16`\n- `squareOrDouble 5 = 10`\n- `squareOrDouble 0 = 0`\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! # Basic Tests -/\n\n/-- Basic test: even number case -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test: odd number case -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-! # Additional Test Cases -/\n\n/-- Positive test: even number -/\nexample : squareOrDouble 2 = 4 := by native_decide\n#eval squareOrDouble 2  -- expected: 4\n\n/-- Positive test: odd number -/\nexample : squareOrDouble 3 = 6 := by native_decide\n#eval squareOrDouble 3  -- expected: 6\n\n/-- Negative test: even number incorrect result -/\nexample : \u00ac(squareOrDouble 4 = 8) := by native_decide\n#eval decide (squareOrDouble 4 = 8)  -- expected: false\n\n/-! # Pre-conditions -/\n\n/-- Pre-condition: Input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: result is non-negative (always true for Nat) -/\ndef nonNegativeProp (n : Nat) : Prop :=\n  squareOrDouble n \u2265 0\n\n/-- Property: result is even for even inputs -/\ndef evenResultProp (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n % 2 = 0\n\n/-- Property: result equals n\u00b2 for even inputs -/\ndef evenSquareProp (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Property: result equals 2n for odd inputs -/\ndef oddDoubleProp (n : Nat) : Prop :=\n  n % 2 = 1 \u2192 squareOrDouble n = 2 * n\n\n/-- Property: zero case -/\ndef zeroProp : Prop :=\n  squareOrDouble 0 = 0\n\n/-! # Theorems -/\n\n/-- Theorem: result is always non-negative -/\ntheorem nonNegative_thm (n : Nat) : nonNegativeProp n := sorry\n\n/-- Theorem: even inputs produce even outputs -/\ntheorem evenResult_thm (n : Nat) : evenResultProp n := sorry\n\n/-- Theorem: even inputs are squared -/\ntheorem evenSquare_thm (n : Nat) : evenSquareProp n := sorry\n\n/-- Theorem: odd inputs are doubled -/\ntheorem oddDouble_thm (n : Nat) : oddDoubleProp n := sorry\n\n/-- Theorem: zero case works correctly -/\ntheorem zero_thm : zeroProp := sorry\n\n/-! # Post-condition -/\n\n/-- Post-condition: conjunction of all desired properties -/\ndef Post (n : Nat) : Prop :=\n  nonNegativeProp n \u2227\n  evenResultProp n \u2227\n  evenSquareProp n \u2227\n  oddDoubleProp n\n\n/-- Correctness theorem: Pre implies Post -/\ntheorem correctness_thm (n : Nat) (h : Pre n) : Post n := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative version that computes the same result using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-! # Imperative Tests -/\n\n/-- Test imperative version with even input -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\n/-- Test imperative version with odd input -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\n/-- Test imperative version with zero -/\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem: functional and imperative versions produce same results -/\ntheorem equivalence_thm (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 4,
      "score": 0.8933333333333333,
      "best_score": 0.9333333333333333,
      "is_new_best": false,
      "feedback": "The original code passed compilation and unit tests. We use a LLM judge to score the semantic equivalence between the golden reference and the generated Lean 4 code. Rationale from the LLM judge: The agent's implementation captures the core functionality but has some notable differences:\n\n1. Core Function:\n- Both implement the same logic (square if even, double if odd)\n- Both handle the same edge cases\n- Both are type-safe with Nat inputs\n\n2. Properties and Theorems:\n- Agent is missing some key ",
      "lean_code": "/-!\n# Square or Double Function\n\nIf n is even return n\u00b2, else return 2n, for natural number n.\n\nEdge cases:\n- Works for zero (returns 0)\n- Type safety enforced by Lean's type system\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n squared if n is even, otherwise returns 2 times n.\n\n## Examples\n- `squareOrDouble 4 = 16`\n- `squareOrDouble 5 = 10`\n- `squareOrDouble 0 = 0`\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! # Basic Tests -/\n\n/-- Basic test: even number case -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test: odd number case -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-! # Properties -/\n\n/-- Pre-condition: always true for Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Even case property: n\u00b2 when n is even -/\ndef even_case_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd case property: 2n when n is odd -/\ndef odd_case_prop (n : Nat) : Prop :=\n  n % 2 = 1 \u2192 squareOrDouble n = 2 * n\n\n/-- Zero case property -/\ndef zero_case_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-! # Theorems -/\n\n/-- Even case theorem -/\ntheorem even_case_thm (n : Nat) : even_case_prop n := sorry\n\n/-- Odd case theorem -/\ntheorem odd_case_thm (n : Nat) : odd_case_prop n := sorry\n\n/-- Zero case theorem -/\ntheorem zero_case_thm : zero_case_prop := sorry\n\n/-! # Post-condition -/\n\n/-- Post-condition combines core properties -/\ndef Post (n : Nat) : Prop :=\n  even_case_prop n \u2227\n  odd_case_prop n \u2227\n  zero_case_prop\n\n/-- Correctness theorem: Pre implies Post -/\ntheorem correctness_thm (n : Nat) (h : Pre n) : Post n := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative version using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-! # Imperative Tests -/\n\n/-- Test even case -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\n/-- Test odd case -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\n/-- Test zero case -/\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem -/\ntheorem equivalence_thm (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "best_lean_code": "/-!\n# Square or Double Function\n\nThis function takes a natural number n and:\n- Returns n\u00b2 if n is even\n- Returns 2n if n is odd\n\nEdge cases:\n- Works for zero (returns 0)\n- Type safety enforced by Lean's type system\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns the square of n if n is even, otherwise returns 2 times n.\n\n## Examples\n- `squareOrDouble 4 = 16`\n- `squareOrDouble 5 = 10`\n- `squareOrDouble 0 = 0`\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! # Basic Tests -/\n\n/-- Basic test: even number case -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test: odd number case -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-! # Additional Test Cases -/\n\n/-- Positive test: even number -/\nexample : squareOrDouble 2 = 4 := by native_decide\n#eval squareOrDouble 2  -- expected: 4\n\n/-- Positive test: odd number -/\nexample : squareOrDouble 3 = 6 := by native_decide\n#eval squareOrDouble 3  -- expected: 6\n\n/-- Negative test: even number incorrect result -/\nexample : \u00ac(squareOrDouble 4 = 8) := by native_decide\n#eval decide (squareOrDouble 4 = 8)  -- expected: false\n\n/-! # Pre-conditions -/\n\n/-- Pre-condition: Input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: result is non-negative (always true for Nat) -/\ndef nonNegativeProp (n : Nat) : Prop :=\n  squareOrDouble n \u2265 0\n\n/-- Property: result is even for even inputs -/\ndef evenResultProp (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n % 2 = 0\n\n/-- Property: result equals n\u00b2 for even inputs -/\ndef evenSquareProp (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Property: result equals 2n for odd inputs -/\ndef oddDoubleProp (n : Nat) : Prop :=\n  n % 2 = 1 \u2192 squareOrDouble n = 2 * n\n\n/-- Property: zero case -/\ndef zeroProp : Prop :=\n  squareOrDouble 0 = 0\n\n/-! # Theorems -/\n\n/-- Theorem: result is always non-negative -/\ntheorem nonNegative_thm (n : Nat) : nonNegativeProp n := sorry\n\n/-- Theorem: even inputs produce even outputs -/\ntheorem evenResult_thm (n : Nat) : evenResultProp n := sorry\n\n/-- Theorem: even inputs are squared -/\ntheorem evenSquare_thm (n : Nat) : evenSquareProp n := sorry\n\n/-- Theorem: odd inputs are doubled -/\ntheorem oddDouble_thm (n : Nat) : oddDoubleProp n := sorry\n\n/-- Theorem: zero case works correctly -/\ntheorem zero_thm : zeroProp := sorry\n\n/-! # Post-condition -/\n\n/-- Post-condition: conjunction of all desired properties -/\ndef Post (n : Nat) : Prop :=\n  nonNegativeProp n \u2227\n  evenResultProp n \u2227\n  evenSquareProp n \u2227\n  oddDoubleProp n\n\n/-- Correctness theorem: Pre implies Post -/\ntheorem correctness_thm (n : Nat) (h : Pre n) : Post n := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative version that computes the same result using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-! # Imperative Tests -/\n\n/-- Test imperative version with even input -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\n/-- Test imperative version with odd input -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\n/-- Test imperative version with zero -/\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem: functional and imperative versions produce same results -/\ntheorem equivalence_thm (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 5,
      "score": 0.9733333333333334,
      "best_score": 0.9733333333333334,
      "is_new_best": true,
      "feedback": "The original code passed compilation and unit tests. We use a LLM judge to score the semantic equivalence between the golden reference and the generated Lean 4 code. Rationale from the LLM judge: The agent's implementation is semantically equivalent to the gold standard, with all core functionality preserved. Key observations:\n\n1. Core Function:\n- Both implement the same logic (square if even, double if odd)\n- Both handle edge cases like zero correctly\n- Both return Nat type\n\n2. Properties & The",
      "lean_code": "/-!\n# Square or Double Function\n\nIf n is even return n\u00b2, else return 2n, for natural number n.\n\n## Properties:\n- For even n: returns n\u00b2\n- For odd n: returns 2n (which is always even)\n- Works for zero (returns 0)\n- Type safety enforced by Lean's type system\n\n## Edge Cases:\n- Zero is handled correctly (returns 0)\n- All outputs for odd inputs are even numbers\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n squared if n is even, otherwise returns 2 times n.\n\n## Properties\n- For even n: returns n\u00b2\n- For odd n: returns 2n\n- Output is always even when input is odd\n\n## Examples\n- `squareOrDouble 4 = 16` (even case)\n- `squareOrDouble 5 = 10` (odd case)\n- `squareOrDouble 0 = 0` (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! # Basic Tests -/\n\n/-- Basic test: even number case -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test: odd number case -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-! # Additional Test Cases -/\n\n/-- Additional even cases -/\nexample : squareOrDouble 2 = 4 := by native_decide\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 2  -- expected: 4\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Additional odd cases -/\nexample : squareOrDouble 3 = 6 := by native_decide\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 3  -- expected: 6\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Properties -/\n\n/-- Pre-condition: always true for Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Even case property: n\u00b2 when n is even -/\ndef even_case_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd case property: 2n when n is odd -/\ndef odd_case_prop (n : Nat) : Prop :=\n  n % 2 = 1 \u2192 squareOrDouble n = 2 * n\n\n/-- Result is even when input is odd property -/\ndef result_is_even_prop (n : Nat) : Prop :=\n  n % 2 = 1 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Monotonicity property based on parity -/\ndef monotonicity_prop (n : Nat) : Prop :=\n  (n % 2 = 0 \u2192 squareOrDouble n \u2265 n) \u2227\n  (n % 2 = 1 \u2192 squareOrDouble n \u2265 n)\n\n/-- Zero case property -/\ndef zero_case_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-! # Theorems -/\n\n/-- Even case theorem -/\ntheorem even_case_thm (n : Nat) : even_case_prop n := sorry\n\n/-- Odd case theorem -/\ntheorem odd_case_thm (n : Nat) : odd_case_prop n := sorry\n\n/-- Result is even theorem -/\ntheorem result_is_even_thm (n : Nat) : result_is_even_prop n := sorry\n\n/-- Monotonicity theorem -/\ntheorem monotonicity_thm (n : Nat) : monotonicity_prop n := sorry\n\n/-- Zero case theorem -/\ntheorem zero_case_thm : zero_case_prop := sorry\n\n/-! # Post-condition -/\n\n/-- Post-condition combines all core properties -/\ndef Post (n : Nat) : Prop :=\n  even_case_prop n \u2227\n  odd_case_prop n \u2227\n  result_is_even_prop n \u2227\n  monotonicity_prop n \u2227\n  zero_case_prop\n\n/-- Correctness theorem: Pre implies Post -/\ntheorem correctness_thm (n : Nat) (h : Pre n) : Post n := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative version using mutable state.\nMaintains same properties as functional version.\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-! # Imperative Tests -/\n\n/-- Test even cases -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\nexample : squareOrDoubleImp 2 = 4 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n#eval squareOrDoubleImp 2  -- expected: 4\n\n/-- Test odd cases -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\nexample : squareOrDoubleImp 3 = 6 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n#eval squareOrDoubleImp 3  -- expected: 6\n\n/-- Test zero case -/\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem -/\ntheorem equivalence_thm (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "best_lean_code": "/-!\n# Square or Double Function\n\nIf n is even return n\u00b2, else return 2n, for natural number n.\n\n## Properties:\n- For even n: returns n\u00b2\n- For odd n: returns 2n (which is always even)\n- Works for zero (returns 0)\n- Type safety enforced by Lean's type system\n\n## Edge Cases:\n- Zero is handled correctly (returns 0)\n- All outputs for odd inputs are even numbers\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n squared if n is even, otherwise returns 2 times n.\n\n## Properties\n- For even n: returns n\u00b2\n- For odd n: returns 2n\n- Output is always even when input is odd\n\n## Examples\n- `squareOrDouble 4 = 16` (even case)\n- `squareOrDouble 5 = 10` (odd case)\n- `squareOrDouble 0 = 0` (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! # Basic Tests -/\n\n/-- Basic test: even number case -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test: odd number case -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-! # Additional Test Cases -/\n\n/-- Additional even cases -/\nexample : squareOrDouble 2 = 4 := by native_decide\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 2  -- expected: 4\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Additional odd cases -/\nexample : squareOrDouble 3 = 6 := by native_decide\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 3  -- expected: 6\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Properties -/\n\n/-- Pre-condition: always true for Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Even case property: n\u00b2 when n is even -/\ndef even_case_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd case property: 2n when n is odd -/\ndef odd_case_prop (n : Nat) : Prop :=\n  n % 2 = 1 \u2192 squareOrDouble n = 2 * n\n\n/-- Result is even when input is odd property -/\ndef result_is_even_prop (n : Nat) : Prop :=\n  n % 2 = 1 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Monotonicity property based on parity -/\ndef monotonicity_prop (n : Nat) : Prop :=\n  (n % 2 = 0 \u2192 squareOrDouble n \u2265 n) \u2227\n  (n % 2 = 1 \u2192 squareOrDouble n \u2265 n)\n\n/-- Zero case property -/\ndef zero_case_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-! # Theorems -/\n\n/-- Even case theorem -/\ntheorem even_case_thm (n : Nat) : even_case_prop n := sorry\n\n/-- Odd case theorem -/\ntheorem odd_case_thm (n : Nat) : odd_case_prop n := sorry\n\n/-- Result is even theorem -/\ntheorem result_is_even_thm (n : Nat) : result_is_even_prop n := sorry\n\n/-- Monotonicity theorem -/\ntheorem monotonicity_thm (n : Nat) : monotonicity_prop n := sorry\n\n/-- Zero case theorem -/\ntheorem zero_case_thm : zero_case_prop := sorry\n\n/-! # Post-condition -/\n\n/-- Post-condition combines all core properties -/\ndef Post (n : Nat) : Prop :=\n  even_case_prop n \u2227\n  odd_case_prop n \u2227\n  result_is_even_prop n \u2227\n  monotonicity_prop n \u2227\n  zero_case_prop\n\n/-- Correctness theorem: Pre implies Post -/\ntheorem correctness_thm (n : Nat) (h : Pre n) : Post n := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative version using mutable state.\nMaintains same properties as functional version.\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-! # Imperative Tests -/\n\n/-- Test even cases -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\nexample : squareOrDoubleImp 2 = 4 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n#eval squareOrDoubleImp 2  -- expected: 4\n\n/-- Test odd cases -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\nexample : squareOrDoubleImp 3 = 6 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n#eval squareOrDoubleImp 3  -- expected: 6\n\n/-- Test zero case -/\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem -/\ntheorem equivalence_thm (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 6,
      "score": 0.9866666666666667,
      "best_score": 0.9866666666666667,
      "is_new_best": true,
      "feedback": "The original code passed compilation and unit tests. We use a LLM judge to score the semantic equivalence between the golden reference and the generated Lean 4 code. Rationale from the LLM judge: The agent's implementation is semantically equivalent to the gold standard, with all key components present but with some minor structural differences:\n\n1. Core Function:\n- Both implement the same logic (square if even, double if odd)\n- Both handle edge cases correctly (especially 0)\n- Both use the same",
      "lean_code": "/-!\n# Square or Double Function\n\nIf n is even return n\u00b2, else return 2n, for natural number n.\n\n## Properties:\n- For even n: returns n\u00b2\n- For odd n: returns 2n (which is always even)\n- Works for zero (returns 0)\n- Type safety enforced by Lean's type system\n\n## Edge Cases:\n- Zero is handled correctly (returns 0)\n- All outputs for odd inputs are even numbers\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n squared if n is even, otherwise returns 2 times n.\n\n## Properties\n- For even n: returns n\u00b2\n- For odd n: returns 2n\n- Output is always even when input is odd\n\n## Examples\n- `squareOrDouble 4 = 16` (even case)\n- `squareOrDouble 5 = 10` (odd case)\n- `squareOrDouble 0 = 0` (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! # Basic Tests -/\n\n/-- Basic test: even number case -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test: odd number case -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-! # Additional Test Cases -/\n\n/-- Additional even cases -/\nexample : squareOrDouble 2 = 4 := by native_decide\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 2  -- expected: 4\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Additional odd cases -/\nexample : squareOrDouble 3 = 6 := by native_decide\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 3  -- expected: 6\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Properties -/\n\n/-- Pre-condition: always true for Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Even case property: n\u00b2 when n is even -/\ndef even_case_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd case property: 2n when n is odd -/\ndef odd_case_prop (n : Nat) : Prop :=\n  n % 2 = 1 \u2192 squareOrDouble n = 2 * n\n\n/-- Result is even when input is odd property -/\ndef result_is_even_prop (n : Nat) : Prop :=\n  n % 2 = 1 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Monotonicity property based on parity -/\ndef monotonicity_prop (n : Nat) : Prop :=\n  (n % 2 = 0 \u2192 squareOrDouble n \u2265 n) \u2227\n  (n % 2 = 1 \u2192 squareOrDouble n \u2265 n)\n\n/-- Zero case property -/\ndef zero_case_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-! # Theorems -/\n\n/-- Even case theorem -/\ntheorem even_case_thm (n : Nat) : even_case_prop n := sorry\n\n/-- Odd case theorem -/\ntheorem odd_case_thm (n : Nat) : odd_case_prop n := sorry\n\n/-- Result is even theorem -/\ntheorem result_is_even_thm (n : Nat) : result_is_even_prop n := sorry\n\n/-- Monotonicity theorem -/\ntheorem monotonicity_thm (n : Nat) : monotonicity_prop n := sorry\n\n/-- Zero case theorem -/\ntheorem zero_case_thm : zero_case_prop := sorry\n\n/-! # Post-condition -/\n\n/-- Post-condition combines all core properties -/\ndef Post (n : Nat) : Prop :=\n  even_case_prop n \u2227\n  odd_case_prop n \u2227\n  result_is_even_prop n \u2227\n  monotonicity_prop n \u2227\n  zero_case_prop\n\n/-- Correctness theorem: Pre implies Post -/\ntheorem correctness_thm (n : Nat) (h : Pre n) : Post n := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative version using mutable state.\nMaintains same properties as functional version.\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-! # Imperative Tests -/\n\n/-- Test even cases -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\nexample : squareOrDoubleImp 2 = 4 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n#eval squareOrDoubleImp 2  -- expected: 4\n\n/-- Test odd cases -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\nexample : squareOrDoubleImp 3 = 6 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n#eval squareOrDoubleImp 3  -- expected: 6\n\n/-- Test zero case -/\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem -/\ntheorem equivalence_thm (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "best_lean_code": "/-!\n# Square or Double Function\n\nIf n is even return n\u00b2, else return 2n, for natural number n.\n\n## Properties:\n- For even n: returns n\u00b2\n- For odd n: returns 2n (which is always even)\n- Works for zero (returns 0)\n- Type safety enforced by Lean's type system\n\n## Edge Cases:\n- Zero is handled correctly (returns 0)\n- All outputs for odd inputs are even numbers\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n squared if n is even, otherwise returns 2 times n.\n\n## Properties\n- For even n: returns n\u00b2\n- For odd n: returns 2n\n- Output is always even when input is odd\n\n## Examples\n- `squareOrDouble 4 = 16` (even case)\n- `squareOrDouble 5 = 10` (odd case)\n- `squareOrDouble 0 = 0` (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! # Basic Tests -/\n\n/-- Basic test: even number case -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test: odd number case -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-! # Additional Test Cases -/\n\n/-- Additional even cases -/\nexample : squareOrDouble 2 = 4 := by native_decide\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 2  -- expected: 4\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Additional odd cases -/\nexample : squareOrDouble 3 = 6 := by native_decide\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 3  -- expected: 6\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Properties -/\n\n/-- Pre-condition: always true for Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Even case property: n\u00b2 when n is even -/\ndef even_case_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd case property: 2n when n is odd -/\ndef odd_case_prop (n : Nat) : Prop :=\n  n % 2 = 1 \u2192 squareOrDouble n = 2 * n\n\n/-- Result is even when input is odd property -/\ndef result_is_even_prop (n : Nat) : Prop :=\n  n % 2 = 1 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Monotonicity property based on parity -/\ndef monotonicity_prop (n : Nat) : Prop :=\n  (n % 2 = 0 \u2192 squareOrDouble n \u2265 n) \u2227\n  (n % 2 = 1 \u2192 squareOrDouble n \u2265 n)\n\n/-- Zero case property -/\ndef zero_case_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-! # Theorems -/\n\n/-- Even case theorem -/\ntheorem even_case_thm (n : Nat) : even_case_prop n := sorry\n\n/-- Odd case theorem -/\ntheorem odd_case_thm (n : Nat) : odd_case_prop n := sorry\n\n/-- Result is even theorem -/\ntheorem result_is_even_thm (n : Nat) : result_is_even_prop n := sorry\n\n/-- Monotonicity theorem -/\ntheorem monotonicity_thm (n : Nat) : monotonicity_prop n := sorry\n\n/-- Zero case theorem -/\ntheorem zero_case_thm : zero_case_prop := sorry\n\n/-! # Post-condition -/\n\n/-- Post-condition combines all core properties -/\ndef Post (n : Nat) : Prop :=\n  even_case_prop n \u2227\n  odd_case_prop n \u2227\n  result_is_even_prop n \u2227\n  monotonicity_prop n \u2227\n  zero_case_prop\n\n/-- Correctness theorem: Pre implies Post -/\ntheorem correctness_thm (n : Nat) (h : Pre n) : Post n := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative version using mutable state.\nMaintains same properties as functional version.\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-! # Imperative Tests -/\n\n/-- Test even cases -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\nexample : squareOrDoubleImp 2 = 4 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n#eval squareOrDoubleImp 2  -- expected: 4\n\n/-- Test odd cases -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\nexample : squareOrDoubleImp 3 = 6 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n#eval squareOrDoubleImp 3  -- expected: 6\n\n/-- Test zero case -/\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem -/\ntheorem equivalence_thm (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 7,
      "score": 1.0,
      "best_score": 1.0,
      "is_new_best": true,
      "feedback": "The original code passed compilation and unit tests. We use a LLM judge to score the semantic equivalence between the golden reference and the generated Lean 4 code. Rationale from the LLM judge: The agent's implementation is semantically equivalent to the gold standard, with all core functionality preserved. Key observations:\n\n1. Core Function:\n- Both implement the same logic: square even numbers, double odd numbers\n- Both handle edge cases like 0 correctly\n- Both use the same modulo-2 check fo",
      "lean_code": "/-!\n# Square or Double Function\n\nIf n is even return n\u00b2, else return 2n, for natural number n.\n\n## Properties:\n- For even n: returns n\u00b2\n- For odd n: returns 2n (which is always even)\n- Works for zero (returns 0)\n- Type safety enforced by Lean's type system\n\n## Edge Cases:\n- Zero is handled correctly (returns 0)\n- All outputs for odd inputs are even numbers\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n squared if n is even, otherwise returns 2 times n.\n\n## Properties\n- For even n: returns n\u00b2\n- For odd n: returns 2n\n- Output is always even when input is odd\n\n## Examples\n- `squareOrDouble 4 = 16` (even case)\n- `squareOrDouble 5 = 10` (odd case)\n- `squareOrDouble 0 = 0` (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! # Basic Tests -/\n\n/-- Basic test: even number case -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test: odd number case -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-! # Additional Test Cases -/\n\n/-- Additional even cases -/\nexample : squareOrDouble 2 = 4 := by native_decide\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 2  -- expected: 4\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Additional odd cases -/\nexample : squareOrDouble 3 = 6 := by native_decide\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 3  -- expected: 6\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Properties -/\n\n/-- Pre-condition: always true for Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Even case property: n\u00b2 when n is even -/\ndef even_case_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd case property: 2n when n is odd -/\ndef odd_case_prop (n : Nat) : Prop :=\n  n % 2 = 1 \u2192 squareOrDouble n = 2 * n\n\n/-- Result is even when input is odd property -/\ndef result_is_even_prop (n : Nat) : Prop :=\n  n % 2 = 1 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Monotonicity property based on parity -/\ndef monotonicity_prop (n : Nat) : Prop :=\n  (n % 2 = 0 \u2192 squareOrDouble n \u2265 n) \u2227\n  (n % 2 = 1 \u2192 squareOrDouble n \u2265 n)\n\n/-- Zero case property -/\ndef zero_case_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-! # Theorems -/\n\n/-- Even case theorem -/\ntheorem even_case_thm (n : Nat) : even_case_prop n := sorry\n\n/-- Odd case theorem -/\ntheorem odd_case_thm (n : Nat) : odd_case_prop n := sorry\n\n/-- Result is even theorem -/\ntheorem result_is_even_thm (n : Nat) : result_is_even_prop n := sorry\n\n/-- Monotonicity theorem -/\ntheorem monotonicity_thm (n : Nat) : monotonicity_prop n := sorry\n\n/-- Zero case theorem -/\ntheorem zero_case_thm : zero_case_prop := sorry\n\n/-! # Post-condition -/\n\n/-- Post-condition combines all core properties -/\ndef Post (n : Nat) : Prop :=\n  even_case_prop n \u2227\n  odd_case_prop n \u2227\n  result_is_even_prop n \u2227\n  monotonicity_prop n \u2227\n  zero_case_prop\n\n/-- Correctness theorem: Pre implies Post -/\ntheorem correctness_thm (n : Nat) (h : Pre n) : Post n := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative version using mutable state.\nMaintains same properties as functional version.\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-! # Imperative Tests -/\n\n/-- Test even cases -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\nexample : squareOrDoubleImp 2 = 4 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n#eval squareOrDoubleImp 2  -- expected: 4\n\n/-- Test odd cases -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\nexample : squareOrDoubleImp 3 = 6 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n#eval squareOrDoubleImp 3  -- expected: 6\n\n/-- Test zero case -/\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem -/\ntheorem equivalence_thm (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "best_lean_code": "/-!\n# Square or Double Function\n\nIf n is even return n\u00b2, else return 2n, for natural number n.\n\n## Properties:\n- For even n: returns n\u00b2\n- For odd n: returns 2n (which is always even)\n- Works for zero (returns 0)\n- Type safety enforced by Lean's type system\n\n## Edge Cases:\n- Zero is handled correctly (returns 0)\n- All outputs for odd inputs are even numbers\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n squared if n is even, otherwise returns 2 times n.\n\n## Properties\n- For even n: returns n\u00b2\n- For odd n: returns 2n\n- Output is always even when input is odd\n\n## Examples\n- `squareOrDouble 4 = 16` (even case)\n- `squareOrDouble 5 = 10` (odd case)\n- `squareOrDouble 0 = 0` (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! # Basic Tests -/\n\n/-- Basic test: even number case -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test: odd number case -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-! # Additional Test Cases -/\n\n/-- Additional even cases -/\nexample : squareOrDouble 2 = 4 := by native_decide\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 2  -- expected: 4\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Additional odd cases -/\nexample : squareOrDouble 3 = 6 := by native_decide\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 3  -- expected: 6\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Properties -/\n\n/-- Pre-condition: always true for Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Even case property: n\u00b2 when n is even -/\ndef even_case_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd case property: 2n when n is odd -/\ndef odd_case_prop (n : Nat) : Prop :=\n  n % 2 = 1 \u2192 squareOrDouble n = 2 * n\n\n/-- Result is even when input is odd property -/\ndef result_is_even_prop (n : Nat) : Prop :=\n  n % 2 = 1 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Monotonicity property based on parity -/\ndef monotonicity_prop (n : Nat) : Prop :=\n  (n % 2 = 0 \u2192 squareOrDouble n \u2265 n) \u2227\n  (n % 2 = 1 \u2192 squareOrDouble n \u2265 n)\n\n/-- Zero case property -/\ndef zero_case_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-! # Theorems -/\n\n/-- Even case theorem -/\ntheorem even_case_thm (n : Nat) : even_case_prop n := sorry\n\n/-- Odd case theorem -/\ntheorem odd_case_thm (n : Nat) : odd_case_prop n := sorry\n\n/-- Result is even theorem -/\ntheorem result_is_even_thm (n : Nat) : result_is_even_prop n := sorry\n\n/-- Monotonicity theorem -/\ntheorem monotonicity_thm (n : Nat) : monotonicity_prop n := sorry\n\n/-- Zero case theorem -/\ntheorem zero_case_thm : zero_case_prop := sorry\n\n/-! # Post-condition -/\n\n/-- Post-condition combines all core properties -/\ndef Post (n : Nat) : Prop :=\n  even_case_prop n \u2227\n  odd_case_prop n \u2227\n  result_is_even_prop n \u2227\n  monotonicity_prop n \u2227\n  zero_case_prop\n\n/-- Correctness theorem: Pre implies Post -/\ntheorem correctness_thm (n : Nat) (h : Pre n) : Post n := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative version using mutable state.\nMaintains same properties as functional version.\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-! # Imperative Tests -/\n\n/-- Test even cases -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\nexample : squareOrDoubleImp 2 = 4 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n#eval squareOrDoubleImp 2  -- expected: 4\n\n/-- Test odd cases -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\nexample : squareOrDoubleImp 3 = 6 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n#eval squareOrDoubleImp 3  -- expected: 6\n\n/-- Test zero case -/\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem -/\ntheorem equivalence_thm (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    }
  ],
  "settings": {
    "model": "anthropic/claude-3.5-sonnet",
    "max_attempts": 50
  }
}