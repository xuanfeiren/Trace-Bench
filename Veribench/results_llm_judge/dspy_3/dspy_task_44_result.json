{
  "task_idx": 44,
  "task_id": 44,
  "success": true,
  "attempts": 11,
  "best_score": 1.0,
  "best_lean_code": "/-!\n# Square or Double Function\n\nIf n is even return n^2 else return 2n, for natural number n.\n\nEdge cases:\n- Works for zero.\n- Takes only natural number inputs (invalid inputs not possible due to Nat type)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\nEdge cases:\n- Works for zero\n- Only accepts natural numbers (enforced by type system)\n- Non-integer inputs are invalid (handled by Lean type system)\n\n## Examples\n#eval squareOrDouble 4 -- expected: 16\n#eval squareOrDouble 5 -- expected: 10\n#eval squareOrDouble 0 -- expected: 0\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-!\n# Basic Tests\n-/\n\n/-- Basic test: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4 -- expected: 16\n\n/-- Basic test: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5 -- expected: 10\n\n/-!\n# Edge Case Tests\n-/\n\n/-- Edge test: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0 -- expected: 0\n\n/-!\n# Additional Test Cases\n-/\n\n/-- Test: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6 -- expected: 36\n\n/-- Test: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7 -- expected: 14\n\n/-- Test: 8\u00b2 = 64 -/\nexample : squareOrDouble 8 = 64 := by native_decide\n#eval squareOrDouble 8 -- expected: 64\n\n/-- Test: 2 * 3 = 6 -/\nexample : squareOrDouble 3 = 6 := by native_decide\n#eval squareOrDouble 3 -- expected: 6\n\n/-- Test: 2\u00b2 = 4 -/\nexample : squareOrDouble 2 = 4 := by native_decide\n#eval squareOrDouble 2 -- expected: 4\n\n/-!\n# Negative Tests\n-/\n\n/-- Negative test: 4\u00b2 \u2260 8 -/\nexample : \u00ac(squareOrDouble 4 = 8) := by native_decide\n#eval decide (squareOrDouble 4 = 8) -- expected: false\n\n/-- Negative test: 2 * 3 \u2260 9 -/\nexample : \u00ac(squareOrDouble 3 = 9) := by native_decide\n#eval decide (squareOrDouble 3 = 9) -- expected: false\n\n/-- Negative test: 2 * 5 \u2260 25 -/\nexample : \u00ac(squareOrDouble 5 = 25) := by native_decide\n#eval decide (squareOrDouble 5 = 25) -- expected: false\n\n/-!\n# Properties and Theorems\n-/\n\n/-- Pre-condition: input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Even input results in square property -/\ndef even_square_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd input results in double property -/\ndef odd_double_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Zero property -/\ndef zero_prop : Prop := squareOrDouble 0 = 0\n\n/-- Result is even for even inputs property -/\ndef result_is_even_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Result is greater than input for non-zero even inputs -/\ndef growth_prop (n : Nat) : Prop :=\n  n > 0 \u2227 n % 2 = 0 \u2192 squareOrDouble n > n\n\n/-- Post-condition combining all properties -/\ndef Post_prop (n : Nat) : Prop :=\n  even_square_prop n \u2227\n  odd_double_prop n \u2227\n  zero_prop \u2227\n  result_is_even_prop n \u2227\n  growth_prop n\n\n/-- Even case theorem -/\ntheorem even_case (n : Nat) (h : n % 2 = 0) : \n  squareOrDouble n = n * n := sorry\n\n/-- Odd case theorem -/\ntheorem odd_case (n : Nat) (h : n % 2 \u2260 0) : \n  squareOrDouble n = 2 * n := sorry\n\n/-- Zero case theorem -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Even result theorem -/\ntheorem even_result (n : Nat) (h : n % 2 = 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Growth theorem -/\ntheorem growth (n : Nat) (h1 : n > 0) (h2 : n % 2 = 0) :\n  squareOrDouble n > n := sorry\n\n/-- Correctness theorem -/\ntheorem correctness (n : Nat) (h : Pre n) : Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state.\nReturns n\u00b2 for even n, 2n for odd n.\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-!\n# Imperative Tests\n-/\n\n/-- Test imperative even: 4\u00b2 = 16 -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4 -- expected: 16\n\n/-- Test imperative odd: 2 * 5 = 10 -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5 -- expected: 10\n\n/-- Test imperative zero case -/\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0 -- expected: 0\n\n/-- Test imperative even: 6\u00b2 = 36 -/\nexample : squareOrDoubleImp 6 = 36 := by native_decide\n#eval squareOrDoubleImp 6 -- expected: 36\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
  "duration_seconds": 361.2353620529175,
  "history": [
    {
      "attempt": 1,
      "score": 0.0,
      "best_score": 0.0,
      "is_new_best": false,
      "feedback": "The original code failed to compile. Feedback from the compilation: Lean compilation FAILED with 1 error(s). Please make the Lean code correct and as simple as possible.\n\nErrors:\n\nError discovered at line 74:\nMessage: <anonymous>:74:34: error: failed to synthesize\n  Decidable zeroProp\n\nAdditional diagnostic information may be available using the `set_option diagnostics true` command.\n\nCode context (indentation block):\n    73 | /-- Theorem: function works correctly for zero -/\n>>  74 | theorem ze",
      "lean_code": "/-!\n# SquareOrDouble Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\n\nEdge cases:\n- Works for zero (returns 0)\n- Takes only integer inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nMain implementation of squareOrDouble.\nReturns the square of n if n is even, otherwise returns double of n.\n\n## Examples\n#eval squareOrDouble 4 -- expected: 16\n#eval squareOrDouble 5 -- expected: 10\n#eval squareOrDouble 0 -- expected: 0\n-/\ndef squareOrDouble (n : Int) : Int :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-!\n# Tests\n-/\n\n/-- Basic test: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4 -- expected: 16\n\n/-- Basic test: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5 -- expected: 10\n\n/-!\n# Edge Case Tests\n-/\n\n/-- Edge test: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0 -- expected: 0\n\n/-!\n# Properties\n-/\n\n/-- Even number property: result should be perfect square -/\ndef evenProp (n : Int) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd number property: result should be double -/\ndef oddProp (n : Int) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Zero property: squareOrDouble 0 = 0 -/\ndef zeroProp : Prop := squareOrDouble 0 = 0\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: function works correctly for even numbers -/\ntheorem even_number_thm (n : Int) : evenProp n := sorry\n\n/-- Theorem: function works correctly for odd numbers -/\ntheorem odd_number_thm (n : Int) : oddProp n := sorry\n\n/-- Theorem: function works correctly for zero -/\ntheorem zero_thm : zeroProp := by native_decide\n\n/-!\n# Additional Test Cases\n-/\n\n/-- Test even positive: 2\u00b2 = 4 -/\nexample : squareOrDouble 2 = 4 := by native_decide\n#eval squareOrDouble 2 -- expected: 4\n\n/-- Test odd positive: 2 * 3 = 6 -/\nexample : squareOrDouble 3 = 6 := by native_decide\n#eval squareOrDouble 3 -- expected: 6\n\n/-- Test even negative: (-2)\u00b2 = 4 -/\nexample : squareOrDouble (-2) = 4 := by native_decide\n#eval squareOrDouble (-2) -- expected: 4\n\n/-- Test odd negative: 2 * (-3) = -6 -/\nexample : squareOrDouble (-3) = -6 := by native_decide\n#eval squareOrDouble (-3) -- expected: -6\n\nend SquareOrDouble",
      "best_lean_code": null
    },
    {
      "attempt": 2,
      "score": 0.76,
      "best_score": 0.76,
      "is_new_best": true,
      "feedback": "The original code passed compilation and unit tests. We use a LLM judge to score the semantic equivalence between the golden reference and the generated Lean 4 code. Rationale from the LLM judge: While both implementations aim to achieve the same core functionality (squaring even numbers and doubling odd ones), there are several significant differences:\n\n1. Type Differences:\n- Gold uses `Nat` while Agent uses `Int`\n- This is a significant semantic difference as it affects the domain of the funct",
      "lean_code": "/-!\n# SquareOrDouble Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\n\nEdge cases:\n- Works for zero (returns 0)\n- Takes only integer inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nMain implementation of squareOrDouble.\nReturns the square of n if n is even, otherwise returns double of n.\n\n## Examples\n#eval squareOrDouble 4 -- expected: 16\n#eval squareOrDouble 5 -- expected: 10\n#eval squareOrDouble 0 -- expected: 0\n-/\ndef squareOrDouble (n : Int) : Int :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-!\n# Tests\n-/\n\n/-- Basic test: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4 -- expected: 16\n\n/-- Basic test: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5 -- expected: 10\n\n/-!\n# Edge Case Tests\n-/\n\n/-- Edge test: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0 -- expected: 0\n\n/-!\n# Properties\n-/\n\n/-- Even number property: result should be perfect square -/\ndef evenProp (n : Int) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd number property: result should be double -/\ndef oddProp (n : Int) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: function works correctly for even numbers -/\ntheorem even_number_thm (n : Int) : evenProp n := sorry\n\n/-- Theorem: function works correctly for odd numbers -/\ntheorem odd_number_thm (n : Int) : oddProp n := sorry\n\n/-- Theorem: function works correctly for zero -/\ntheorem zero_thm : squareOrDouble 0 = 0 := by native_decide\n\n/-!\n# Additional Test Cases\n-/\n\n/-- Test even positive: 2\u00b2 = 4 -/\nexample : squareOrDouble 2 = 4 := by native_decide\n#eval squareOrDouble 2 -- expected: 4\n\n/-- Test odd positive: 2 * 3 = 6 -/\nexample : squareOrDouble 3 = 6 := by native_decide\n#eval squareOrDouble 3 -- expected: 6\n\n/-- Test even negative: (-2)\u00b2 = 4 -/\nexample : squareOrDouble (-2) = 4 := by native_decide\n#eval squareOrDouble (-2) -- expected: 4\n\n/-- Test odd negative: 2 * (-3) = -6 -/\nexample : squareOrDouble (-3) = -6 := by native_decide\n#eval squareOrDouble (-3) -- expected: -6\n\nend SquareOrDouble",
      "best_lean_code": "/-!\n# SquareOrDouble Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\n\nEdge cases:\n- Works for zero (returns 0)\n- Takes only integer inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nMain implementation of squareOrDouble.\nReturns the square of n if n is even, otherwise returns double of n.\n\n## Examples\n#eval squareOrDouble 4 -- expected: 16\n#eval squareOrDouble 5 -- expected: 10\n#eval squareOrDouble 0 -- expected: 0\n-/\ndef squareOrDouble (n : Int) : Int :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-!\n# Tests\n-/\n\n/-- Basic test: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4 -- expected: 16\n\n/-- Basic test: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5 -- expected: 10\n\n/-!\n# Edge Case Tests\n-/\n\n/-- Edge test: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0 -- expected: 0\n\n/-!\n# Properties\n-/\n\n/-- Even number property: result should be perfect square -/\ndef evenProp (n : Int) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd number property: result should be double -/\ndef oddProp (n : Int) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: function works correctly for even numbers -/\ntheorem even_number_thm (n : Int) : evenProp n := sorry\n\n/-- Theorem: function works correctly for odd numbers -/\ntheorem odd_number_thm (n : Int) : oddProp n := sorry\n\n/-- Theorem: function works correctly for zero -/\ntheorem zero_thm : squareOrDouble 0 = 0 := by native_decide\n\n/-!\n# Additional Test Cases\n-/\n\n/-- Test even positive: 2\u00b2 = 4 -/\nexample : squareOrDouble 2 = 4 := by native_decide\n#eval squareOrDouble 2 -- expected: 4\n\n/-- Test odd positive: 2 * 3 = 6 -/\nexample : squareOrDouble 3 = 6 := by native_decide\n#eval squareOrDouble 3 -- expected: 6\n\n/-- Test even negative: (-2)\u00b2 = 4 -/\nexample : squareOrDouble (-2) = 4 := by native_decide\n#eval squareOrDouble (-2) -- expected: 4\n\n/-- Test odd negative: 2 * (-3) = -6 -/\nexample : squareOrDouble (-3) = -6 := by native_decide\n#eval squareOrDouble (-3) -- expected: -6\n\nend SquareOrDouble"
    },
    {
      "attempt": 3,
      "score": 0.92,
      "best_score": 0.92,
      "is_new_best": true,
      "feedback": "The original code passed compilation and unit tests. We use a LLM judge to score the semantic equivalence between the golden reference and the generated Lean 4 code. Rationale from the LLM judge: The agent's implementation is semantically equivalent to the gold standard in core functionality, but has some notable differences:\n\n1. Core Function:\n- Both implement the same logic (square for even, double for odd)\n- Both handle edge cases like 0 correctly\n- Both use the same basic if-then-else struct",
      "lean_code": "/-!\n# SquareOrDouble Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\n\nEdge cases:\n- Works for zero (returns 0)\n- Takes only natural number inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nMain implementation of squareOrDouble.\nReturns the square of n if n is even, otherwise returns double of n.\n\n## Examples\n#eval squareOrDouble 4 -- expected: 16\n#eval squareOrDouble 5 -- expected: 10\n#eval squareOrDouble 0 -- expected: 0\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-!\n# Tests\n-/\n\n/-- Basic test: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4 -- expected: 16\n\n/-- Basic test: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5 -- expected: 10\n\n/-!\n# Edge Case Tests\n-/\n\n/-- Edge test: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0 -- expected: 0\n\n/-!\n# Properties\n-/\n\n/-- Pre-condition: input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Even number property: result should be perfect square -/\ndef evenProp (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd number property: result should be double -/\ndef oddProp (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Result is even property: output should be even when input is even -/\ndef result_is_even_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Monotonicity property: for even numbers, result increases faster than input -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n % 2 = 0 \u2192 m % 2 = 0 \u2192 n < m \u2192 squareOrDouble n < squareOrDouble m\n\n/-- Post-condition: combines all desired properties -/\ndef Post_prop (n : Nat) : Prop :=\n  evenProp n \u2227 oddProp n \u2227 result_is_even_prop n\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: function works correctly for even numbers -/\ntheorem even_number_thm (n : Nat) : evenProp n := sorry\n\n/-- Theorem: function works correctly for odd numbers -/\ntheorem odd_number_thm (n : Nat) : oddProp n := sorry\n\n/-- Theorem: function works correctly for zero -/\ntheorem zero_thm : squareOrDouble 0 = 0 := by native_decide\n\n/-- Theorem: result is even when input is even -/\ntheorem result_is_even_thm (n : Nat) : result_is_even_prop n := sorry\n\n/-- Theorem: monotonic on even numbers -/\ntheorem monotonicity_thm (n m : Nat) : monotonicity_prop n m := sorry\n\n/-- Correctness theorem: Pre implies Post -/\ntheorem correctness_thm (n : Nat) (hPre : Pre n) : Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state.\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      -- For square, multiply n by itself\n      result := n * n\n    else\n      -- For double, add n to itself\n      result := n + n\n    return result\n\n/-!\n# Additional Test Cases\n-/\n\n/-- Test even positive: 2\u00b2 = 4 -/\nexample : squareOrDouble 2 = 4 := by native_decide\n#eval squareOrDouble 2 -- expected: 4\n\n/-- Test odd positive: 2 * 3 = 6 -/\nexample : squareOrDouble 3 = 6 := by native_decide\n#eval squareOrDouble 3 -- expected: 6\n\n/-- Test imperative even: 4\u00b2 = 16 -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4 -- expected: 16\n\n/-- Test imperative odd: 2 * 5 = 10 -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5 -- expected: 10\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "best_lean_code": "/-!\n# SquareOrDouble Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\n\nEdge cases:\n- Works for zero (returns 0)\n- Takes only natural number inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nMain implementation of squareOrDouble.\nReturns the square of n if n is even, otherwise returns double of n.\n\n## Examples\n#eval squareOrDouble 4 -- expected: 16\n#eval squareOrDouble 5 -- expected: 10\n#eval squareOrDouble 0 -- expected: 0\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-!\n# Tests\n-/\n\n/-- Basic test: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4 -- expected: 16\n\n/-- Basic test: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5 -- expected: 10\n\n/-!\n# Edge Case Tests\n-/\n\n/-- Edge test: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0 -- expected: 0\n\n/-!\n# Properties\n-/\n\n/-- Pre-condition: input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Even number property: result should be perfect square -/\ndef evenProp (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd number property: result should be double -/\ndef oddProp (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Result is even property: output should be even when input is even -/\ndef result_is_even_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Monotonicity property: for even numbers, result increases faster than input -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n % 2 = 0 \u2192 m % 2 = 0 \u2192 n < m \u2192 squareOrDouble n < squareOrDouble m\n\n/-- Post-condition: combines all desired properties -/\ndef Post_prop (n : Nat) : Prop :=\n  evenProp n \u2227 oddProp n \u2227 result_is_even_prop n\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: function works correctly for even numbers -/\ntheorem even_number_thm (n : Nat) : evenProp n := sorry\n\n/-- Theorem: function works correctly for odd numbers -/\ntheorem odd_number_thm (n : Nat) : oddProp n := sorry\n\n/-- Theorem: function works correctly for zero -/\ntheorem zero_thm : squareOrDouble 0 = 0 := by native_decide\n\n/-- Theorem: result is even when input is even -/\ntheorem result_is_even_thm (n : Nat) : result_is_even_prop n := sorry\n\n/-- Theorem: monotonic on even numbers -/\ntheorem monotonicity_thm (n m : Nat) : monotonicity_prop n m := sorry\n\n/-- Correctness theorem: Pre implies Post -/\ntheorem correctness_thm (n : Nat) (hPre : Pre n) : Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state.\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      -- For square, multiply n by itself\n      result := n * n\n    else\n      -- For double, add n to itself\n      result := n + n\n    return result\n\n/-!\n# Additional Test Cases\n-/\n\n/-- Test even positive: 2\u00b2 = 4 -/\nexample : squareOrDouble 2 = 4 := by native_decide\n#eval squareOrDouble 2 -- expected: 4\n\n/-- Test odd positive: 2 * 3 = 6 -/\nexample : squareOrDouble 3 = 6 := by native_decide\n#eval squareOrDouble 3 -- expected: 6\n\n/-- Test imperative even: 4\u00b2 = 16 -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4 -- expected: 16\n\n/-- Test imperative odd: 2 * 5 = 10 -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5 -- expected: 10\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 4,
      "score": 0.0,
      "best_score": 0.92,
      "is_new_best": false,
      "feedback": "The original code failed to compile. Feedback from the compilation: Lean compilation FAILED with 1 error(s). Please make the Lean code correct and as simple as possible.\n\nErrors:\n\nError discovered at line 110:\nMessage: <anonymous>:110:34: error: failed to synthesize\n  Decidable zeroProp\n\nAdditional diagnostic information may be available using the `set_option diagnostics true` command.\n\nCode context (indentation block):\n   109 | /-- Theorem: function works correctly for zero -/\n>> 110 | theorem ",
      "lean_code": "/-!\n# SquareOrDouble Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\n\nEdge cases:\n- Works for zero (returns 0)\n- Takes only natural number inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nMain implementation of squareOrDouble.\nReturns the square of n if n is even, otherwise returns double of n.\n\n## Examples\n#eval squareOrDouble 4 -- expected: 16\n#eval squareOrDouble 5 -- expected: 10\n#eval squareOrDouble 0 -- expected: 0\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-!\n# Tests\n-/\n\n/-- Basic test: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4 -- expected: 16\n\n/-- Basic test: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5 -- expected: 10\n\n/-!\n# Edge Case Tests\n-/\n\n/-- Edge test: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0 -- expected: 0\n\n/-!\n# Negative Tests\n-/\n\n/-- Negative test: 4\u00b2 \u2260 8 -/\nexample : \u00ac(squareOrDouble 4 = 8) := by native_decide\n#eval decide (squareOrDouble 4 = 8) -- expected: false\n\n/-- Negative test: 2 * 3 \u2260 9 -/\nexample : \u00ac(squareOrDouble 3 = 9) := by native_decide\n#eval decide (squareOrDouble 3 = 9) -- expected: false\n\n/-!\n# Properties\n-/\n\n/-- Pre-condition: input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Even number property: result should be perfect square -/\ndef evenProp (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd number property: result should be double -/\ndef oddProp (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Zero property: zero maps to zero -/\ndef zeroProp : Prop := squareOrDouble 0 = 0\n\n/-- Result is even property: output should be even when input is even -/\ndef result_is_even_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Growth property: for even n > 0, square grows faster than double -/\ndef growth_prop (n : Nat) : Prop :=\n  n > 0 \u2192 n % 2 = 0 \u2192 squareOrDouble n > 2 * n\n\n/-- Monotonicity property: result increases with input -/\ndef monotonicity_prop (n : Nat) : Prop :=\n  \u2200 m, n < m \u2192 squareOrDouble n < squareOrDouble m\n\n/-- Post-condition: combines all desired properties -/\ndef Post_prop (n : Nat) : Prop :=\n  evenProp n \u2227 \n  oddProp n \u2227 \n  result_is_even_prop n \u2227\n  growth_prop n \u2227\n  monotonicity_prop n \u2227\n  (n = 0 \u2192 zeroProp)\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: function works correctly for even numbers -/\ntheorem even_number_thm (n : Nat) : evenProp n := sorry\n\n/-- Theorem: function works correctly for odd numbers -/\ntheorem odd_number_thm (n : Nat) : oddProp n := sorry\n\n/-- Theorem: function works correctly for zero -/\ntheorem zero_thm : zeroProp := by native_decide\n\n/-- Theorem: result is even when input is even -/\ntheorem result_is_even_thm (n : Nat) : result_is_even_prop n := sorry\n\n/-- Theorem: squares grow faster than doubles for even numbers > 0 -/\ntheorem growth_thm (n : Nat) : growth_prop n := sorry\n\n/-- Theorem: function is monotonic -/\ntheorem monotonicity_thm (n : Nat) : monotonicity_prop n := sorry\n\n/-- Correctness theorem: Pre implies Post -/\ntheorem correctness_thm (n : Nat) (hPre : Pre n) : Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state.\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      -- For square, multiply n by itself\n      result := n * n\n    else\n      -- For double, add n to itself\n      result := n + n\n    return result\n\n/-!\n# Additional Test Cases\n-/\n\n/-- Test even positive: 2\u00b2 = 4 -/\nexample : squareOrDouble 2 = 4 := by native_decide\n#eval squareOrDouble 2 -- expected: 4\n\n/-- Test odd positive: 2 * 3 = 6 -/\nexample : squareOrDouble 3 = 6 := by native_decide\n#eval squareOrDouble 3 -- expected: 6\n\n/-- Test imperative even: 4\u00b2 = 16 -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4 -- expected: 16\n\n/-- Test imperative odd: 2 * 5 = 10 -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5 -- expected: 10\n\n/-- Test growth property: 4\u00b2 > 2 * 4 -/\nexample : squareOrDouble 4 > 2 * 4 := by native_decide\n#eval decide (squareOrDouble 4 > 2 * 4) -- expected: true\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "best_lean_code": "/-!\n# SquareOrDouble Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\n\nEdge cases:\n- Works for zero (returns 0)\n- Takes only natural number inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nMain implementation of squareOrDouble.\nReturns the square of n if n is even, otherwise returns double of n.\n\n## Examples\n#eval squareOrDouble 4 -- expected: 16\n#eval squareOrDouble 5 -- expected: 10\n#eval squareOrDouble 0 -- expected: 0\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-!\n# Tests\n-/\n\n/-- Basic test: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4 -- expected: 16\n\n/-- Basic test: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5 -- expected: 10\n\n/-!\n# Edge Case Tests\n-/\n\n/-- Edge test: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0 -- expected: 0\n\n/-!\n# Properties\n-/\n\n/-- Pre-condition: input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Even number property: result should be perfect square -/\ndef evenProp (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd number property: result should be double -/\ndef oddProp (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Result is even property: output should be even when input is even -/\ndef result_is_even_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Monotonicity property: for even numbers, result increases faster than input -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n % 2 = 0 \u2192 m % 2 = 0 \u2192 n < m \u2192 squareOrDouble n < squareOrDouble m\n\n/-- Post-condition: combines all desired properties -/\ndef Post_prop (n : Nat) : Prop :=\n  evenProp n \u2227 oddProp n \u2227 result_is_even_prop n\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: function works correctly for even numbers -/\ntheorem even_number_thm (n : Nat) : evenProp n := sorry\n\n/-- Theorem: function works correctly for odd numbers -/\ntheorem odd_number_thm (n : Nat) : oddProp n := sorry\n\n/-- Theorem: function works correctly for zero -/\ntheorem zero_thm : squareOrDouble 0 = 0 := by native_decide\n\n/-- Theorem: result is even when input is even -/\ntheorem result_is_even_thm (n : Nat) : result_is_even_prop n := sorry\n\n/-- Theorem: monotonic on even numbers -/\ntheorem monotonicity_thm (n m : Nat) : monotonicity_prop n m := sorry\n\n/-- Correctness theorem: Pre implies Post -/\ntheorem correctness_thm (n : Nat) (hPre : Pre n) : Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state.\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      -- For square, multiply n by itself\n      result := n * n\n    else\n      -- For double, add n to itself\n      result := n + n\n    return result\n\n/-!\n# Additional Test Cases\n-/\n\n/-- Test even positive: 2\u00b2 = 4 -/\nexample : squareOrDouble 2 = 4 := by native_decide\n#eval squareOrDouble 2 -- expected: 4\n\n/-- Test odd positive: 2 * 3 = 6 -/\nexample : squareOrDouble 3 = 6 := by native_decide\n#eval squareOrDouble 3 -- expected: 6\n\n/-- Test imperative even: 4\u00b2 = 16 -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4 -- expected: 16\n\n/-- Test imperative odd: 2 * 5 = 10 -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5 -- expected: 10\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 5,
      "score": 0.8,
      "best_score": 0.92,
      "is_new_best": false,
      "feedback": "The original code passed compilation and unit tests. We use a LLM judge to score the semantic equivalence between the golden reference and the generated Lean 4 code. Rationale from the LLM judge: The agent's implementation captures the core functionality of squaring even numbers and doubling odd ones, but has some notable differences from the gold standard:\n\n1. Core Implementation:\n- Both implementations correctly handle the even/odd cases\n- Both use the same logic (if n % 2 = 0 then square else",
      "lean_code": "/-!\n# SquareOrDouble Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\n\nEdge cases:\n- Works for zero (returns 0)\n- Takes only natural number inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nMain implementation of squareOrDouble.\nReturns the square of n if n is even, otherwise returns double of n.\n\n## Examples\n#eval squareOrDouble 4 -- expected: 16\n#eval squareOrDouble 5 -- expected: 10\n#eval squareOrDouble 0 -- expected: 0\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-!\n# Tests\n-/\n\n/-- Basic test: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4 -- expected: 16\n\n/-- Basic test: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5 -- expected: 10\n\n/-!\n# Edge Case Tests\n-/\n\n/-- Edge test: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0 -- expected: 0\n\n/-!\n# Negative Tests\n-/\n\n/-- Negative test: 4\u00b2 \u2260 8 -/\nexample : \u00ac(squareOrDouble 4 = 8) := by native_decide\n#eval decide (squareOrDouble 4 = 8) -- expected: false\n\n/-- Negative test: 2 * 3 \u2260 9 -/\nexample : \u00ac(squareOrDouble 3 = 9) := by native_decide\n#eval decide (squareOrDouble 3 = 9) -- expected: false\n\n/-!\n# Properties and Theorems\n-/\n\n/-- Pre-condition: input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Even number property: result should be perfect square -/\ntheorem even_case (n : Nat) (h : n % 2 = 0) : \n  squareOrDouble n = n * n := sorry\n\n/-- Odd number property: result should be double -/\ntheorem odd_case (n : Nat) (h : n % 2 \u2260 0) : \n  squareOrDouble n = 2 * n := sorry\n\n/-- Zero property: zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Result is even for even inputs -/\ntheorem even_result (n : Nat) (h : n % 2 = 0) : \n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Growth property: for even n > 0, square grows faster than double -/\ntheorem growth (n : Nat) (h1 : n > 0) (h2 : n % 2 = 0) : \n  squareOrDouble n > 2 * n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state.\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := n + n\n    return result\n\n/-!\n# Imperative Tests\n-/\n\n/-- Test imperative even: 4\u00b2 = 16 -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4 -- expected: 16\n\n/-- Test imperative odd: 2 * 5 = 10 -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5 -- expected: 10\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "best_lean_code": "/-!\n# SquareOrDouble Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\n\nEdge cases:\n- Works for zero (returns 0)\n- Takes only natural number inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nMain implementation of squareOrDouble.\nReturns the square of n if n is even, otherwise returns double of n.\n\n## Examples\n#eval squareOrDouble 4 -- expected: 16\n#eval squareOrDouble 5 -- expected: 10\n#eval squareOrDouble 0 -- expected: 0\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-!\n# Tests\n-/\n\n/-- Basic test: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4 -- expected: 16\n\n/-- Basic test: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5 -- expected: 10\n\n/-!\n# Edge Case Tests\n-/\n\n/-- Edge test: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0 -- expected: 0\n\n/-!\n# Properties\n-/\n\n/-- Pre-condition: input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Even number property: result should be perfect square -/\ndef evenProp (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd number property: result should be double -/\ndef oddProp (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Result is even property: output should be even when input is even -/\ndef result_is_even_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Monotonicity property: for even numbers, result increases faster than input -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n % 2 = 0 \u2192 m % 2 = 0 \u2192 n < m \u2192 squareOrDouble n < squareOrDouble m\n\n/-- Post-condition: combines all desired properties -/\ndef Post_prop (n : Nat) : Prop :=\n  evenProp n \u2227 oddProp n \u2227 result_is_even_prop n\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: function works correctly for even numbers -/\ntheorem even_number_thm (n : Nat) : evenProp n := sorry\n\n/-- Theorem: function works correctly for odd numbers -/\ntheorem odd_number_thm (n : Nat) : oddProp n := sorry\n\n/-- Theorem: function works correctly for zero -/\ntheorem zero_thm : squareOrDouble 0 = 0 := by native_decide\n\n/-- Theorem: result is even when input is even -/\ntheorem result_is_even_thm (n : Nat) : result_is_even_prop n := sorry\n\n/-- Theorem: monotonic on even numbers -/\ntheorem monotonicity_thm (n m : Nat) : monotonicity_prop n m := sorry\n\n/-- Correctness theorem: Pre implies Post -/\ntheorem correctness_thm (n : Nat) (hPre : Pre n) : Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state.\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      -- For square, multiply n by itself\n      result := n * n\n    else\n      -- For double, add n to itself\n      result := n + n\n    return result\n\n/-!\n# Additional Test Cases\n-/\n\n/-- Test even positive: 2\u00b2 = 4 -/\nexample : squareOrDouble 2 = 4 := by native_decide\n#eval squareOrDouble 2 -- expected: 4\n\n/-- Test odd positive: 2 * 3 = 6 -/\nexample : squareOrDouble 3 = 6 := by native_decide\n#eval squareOrDouble 3 -- expected: 6\n\n/-- Test imperative even: 4\u00b2 = 16 -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4 -- expected: 16\n\n/-- Test imperative odd: 2 * 5 = 10 -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5 -- expected: 10\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 6,
      "score": 0.9333333333333333,
      "best_score": 0.9333333333333333,
      "is_new_best": true,
      "feedback": "The original code passed compilation and unit tests. We use a LLM judge to score the semantic equivalence between the golden reference and the generated Lean 4 code. Rationale from the LLM judge: The agent's implementation is semantically very similar to the gold standard, with a few key differences:\n\n1. Core Functionality Match:\n- Both implement the same core logic (square for even numbers, double for odd)\n- Both have functional and imperative implementations\n- Both handle edge cases like 0 cor",
      "lean_code": "/-!\n# SquareOrDouble Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\n\nEdge cases:\n- Works for zero (returns 0)\n- Takes only natural number inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nMain implementation of squareOrDouble.\nReturns the square of n if n is even, otherwise returns double of n.\n\n## Examples\n#eval squareOrDouble 4 -- expected: 16\n#eval squareOrDouble 5 -- expected: 10\n#eval squareOrDouble 0 -- expected: 0\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-!\n# Tests\n-/\n\n/-- Basic test: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4 -- expected: 16\n\n/-- Basic test: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5 -- expected: 10\n\n/-!\n# Edge Case Tests\n-/\n\n/-- Edge test: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0 -- expected: 0\n\n/-!\n# Property Tests\n-/\n\n/-- Test: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6 -- expected: 36\n\n/-- Test: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7 -- expected: 14\n\n/-!\n# Negative Tests\n-/\n\n/-- Negative test: 4\u00b2 \u2260 8 -/\nexample : \u00ac(squareOrDouble 4 = 8) := by native_decide\n#eval decide (squareOrDouble 4 = 8) -- expected: false\n\n/-- Negative test: 2 * 3 \u2260 9 -/\nexample : \u00ac(squareOrDouble 3 = 9) := by native_decide\n#eval decide (squareOrDouble 3 = 9) -- expected: false\n\n/-!\n# Properties and Theorems\n-/\n\n/-- Pre-condition: input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Result is even for even inputs property -/\ndef result_is_even_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Monotonicity property: output grows with input -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n < m \u2192 squareOrDouble n < squareOrDouble m\n\n/-- Even result is square property -/\ndef even_result_square_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd result is double property -/\ndef odd_result_double_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Zero property -/\ndef zero_prop : Prop := squareOrDouble 0 = 0\n\n/-- Post-condition combining all properties -/\ndef Post_prop (n : Nat) : Prop :=\n  result_is_even_prop n \u2227\n  (\u2200 m, monotonicity_prop n m) \u2227\n  even_result_square_prop n \u2227\n  odd_result_double_prop n \u2227\n  zero_prop\n\n/-- Even case theorem -/\ntheorem even_case (n : Nat) (h : n % 2 = 0) : \n  squareOrDouble n = n * n := sorry\n\n/-- Odd case theorem -/\ntheorem odd_case (n : Nat) (h : n % 2 \u2260 0) : \n  squareOrDouble n = 2 * n := sorry\n\n/-- Zero case theorem -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Result is even for even inputs theorem -/\ntheorem even_result (n : Nat) (h : n % 2 = 0) : \n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Monotonicity theorem -/\ntheorem monotonicity (n m : Nat) (h : n < m) :\n  squareOrDouble n < squareOrDouble m := sorry\n\n/-- Growth property theorem -/\ntheorem growth (n : Nat) (h1 : n > 0) (h2 : n % 2 = 0) : \n  squareOrDouble n > 2 * n := sorry\n\n/-- Correctness theorem -/\ntheorem correctness (n : Nat) (h : Pre n) : Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state.\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := n + n\n    return result\n\n/-!\n# Imperative Tests\n-/\n\n/-- Test imperative even: 4\u00b2 = 16 -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4 -- expected: 16\n\n/-- Test imperative odd: 2 * 5 = 10 -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5 -- expected: 10\n\n/-- Test imperative zero case -/\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0 -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "best_lean_code": "/-!\n# SquareOrDouble Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\n\nEdge cases:\n- Works for zero (returns 0)\n- Takes only natural number inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nMain implementation of squareOrDouble.\nReturns the square of n if n is even, otherwise returns double of n.\n\n## Examples\n#eval squareOrDouble 4 -- expected: 16\n#eval squareOrDouble 5 -- expected: 10\n#eval squareOrDouble 0 -- expected: 0\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-!\n# Tests\n-/\n\n/-- Basic test: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4 -- expected: 16\n\n/-- Basic test: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5 -- expected: 10\n\n/-!\n# Edge Case Tests\n-/\n\n/-- Edge test: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0 -- expected: 0\n\n/-!\n# Property Tests\n-/\n\n/-- Test: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6 -- expected: 36\n\n/-- Test: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7 -- expected: 14\n\n/-!\n# Negative Tests\n-/\n\n/-- Negative test: 4\u00b2 \u2260 8 -/\nexample : \u00ac(squareOrDouble 4 = 8) := by native_decide\n#eval decide (squareOrDouble 4 = 8) -- expected: false\n\n/-- Negative test: 2 * 3 \u2260 9 -/\nexample : \u00ac(squareOrDouble 3 = 9) := by native_decide\n#eval decide (squareOrDouble 3 = 9) -- expected: false\n\n/-!\n# Properties and Theorems\n-/\n\n/-- Pre-condition: input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Result is even for even inputs property -/\ndef result_is_even_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Monotonicity property: output grows with input -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n < m \u2192 squareOrDouble n < squareOrDouble m\n\n/-- Even result is square property -/\ndef even_result_square_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd result is double property -/\ndef odd_result_double_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Zero property -/\ndef zero_prop : Prop := squareOrDouble 0 = 0\n\n/-- Post-condition combining all properties -/\ndef Post_prop (n : Nat) : Prop :=\n  result_is_even_prop n \u2227\n  (\u2200 m, monotonicity_prop n m) \u2227\n  even_result_square_prop n \u2227\n  odd_result_double_prop n \u2227\n  zero_prop\n\n/-- Even case theorem -/\ntheorem even_case (n : Nat) (h : n % 2 = 0) : \n  squareOrDouble n = n * n := sorry\n\n/-- Odd case theorem -/\ntheorem odd_case (n : Nat) (h : n % 2 \u2260 0) : \n  squareOrDouble n = 2 * n := sorry\n\n/-- Zero case theorem -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Result is even for even inputs theorem -/\ntheorem even_result (n : Nat) (h : n % 2 = 0) : \n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Monotonicity theorem -/\ntheorem monotonicity (n m : Nat) (h : n < m) :\n  squareOrDouble n < squareOrDouble m := sorry\n\n/-- Growth property theorem -/\ntheorem growth (n : Nat) (h1 : n > 0) (h2 : n % 2 = 0) : \n  squareOrDouble n > 2 * n := sorry\n\n/-- Correctness theorem -/\ntheorem correctness (n : Nat) (h : Pre n) : Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state.\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := n + n\n    return result\n\n/-!\n# Imperative Tests\n-/\n\n/-- Test imperative even: 4\u00b2 = 16 -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4 -- expected: 16\n\n/-- Test imperative odd: 2 * 5 = 10 -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5 -- expected: 10\n\n/-- Test imperative zero case -/\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0 -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 7,
      "score": 0.92,
      "best_score": 0.9333333333333333,
      "is_new_best": false,
      "feedback": "The original code passed compilation and unit tests. We use a LLM judge to score the semantic equivalence between the golden reference and the generated Lean 4 code. Rationale from the LLM judge: The agent's implementation is semantically similar to the gold standard but has some notable differences:\n\n1. Core Function:\n- Both implement the same logic (square for even, double for odd)\n- Both handle edge cases correctly (especially 0)\n\n2. Properties and Theorems:\n- The agent is missing some key pr",
      "lean_code": "/-!\n# Square or Double Function\n\nIf n is even return n^2 else return 2n, for natural number n.\n\nEdge cases:\n- Works for zero\n- Takes only natural number inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\n## Examples\n#eval squareOrDouble 4 -- expected: 16\n#eval squareOrDouble 5 -- expected: 10\n#eval squareOrDouble 0 -- expected: 0\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-!\n# Tests\n-/\n\n/-- Basic test: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4 -- expected: 16\n\n/-- Basic test: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5 -- expected: 10\n\n/-!\n# Edge Case Tests\n-/\n\n/-- Edge test: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0 -- expected: 0\n\n/-!\n# Property Tests\n-/\n\n/-- Test: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6 -- expected: 36\n\n/-- Test: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7 -- expected: 14\n\n/-!\n# Negative Tests\n-/\n\n/-- Negative test: 4\u00b2 \u2260 8 -/\nexample : \u00ac(squareOrDouble 4 = 8) := by native_decide\n#eval decide (squareOrDouble 4 = 8) -- expected: false\n\n/-- Negative test: 2 * 3 \u2260 9 -/\nexample : \u00ac(squareOrDouble 3 = 9) := by native_decide\n#eval decide (squareOrDouble 3 = 9) -- expected: false\n\n/-!\n# Properties and Theorems\n-/\n\n/-- Pre-condition: input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Even input results in square property -/\ndef even_square_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd input results in double property -/\ndef odd_double_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Zero property -/\ndef zero_prop : Prop := squareOrDouble 0 = 0\n\n/-- Post-condition combining all properties -/\ndef Post_prop (n : Nat) : Prop :=\n  even_square_prop n \u2227\n  odd_double_prop n \u2227\n  zero_prop\n\n/-- Even case theorem -/\ntheorem even_case (n : Nat) (h : n % 2 = 0) : \n  squareOrDouble n = n * n := sorry\n\n/-- Odd case theorem -/\ntheorem odd_case (n : Nat) (h : n % 2 \u2260 0) : \n  squareOrDouble n = 2 * n := sorry\n\n/-- Zero case theorem -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Correctness theorem -/\ntheorem correctness (n : Nat) (h : Pre n) : Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state.\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := n + n\n    return result\n\n/-!\n# Imperative Tests\n-/\n\n/-- Test imperative even: 4\u00b2 = 16 -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4 -- expected: 16\n\n/-- Test imperative odd: 2 * 5 = 10 -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5 -- expected: 10\n\n/-- Test imperative zero case -/\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0 -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "best_lean_code": "/-!\n# SquareOrDouble Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\n\nEdge cases:\n- Works for zero (returns 0)\n- Takes only natural number inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nMain implementation of squareOrDouble.\nReturns the square of n if n is even, otherwise returns double of n.\n\n## Examples\n#eval squareOrDouble 4 -- expected: 16\n#eval squareOrDouble 5 -- expected: 10\n#eval squareOrDouble 0 -- expected: 0\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-!\n# Tests\n-/\n\n/-- Basic test: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4 -- expected: 16\n\n/-- Basic test: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5 -- expected: 10\n\n/-!\n# Edge Case Tests\n-/\n\n/-- Edge test: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0 -- expected: 0\n\n/-!\n# Property Tests\n-/\n\n/-- Test: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6 -- expected: 36\n\n/-- Test: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7 -- expected: 14\n\n/-!\n# Negative Tests\n-/\n\n/-- Negative test: 4\u00b2 \u2260 8 -/\nexample : \u00ac(squareOrDouble 4 = 8) := by native_decide\n#eval decide (squareOrDouble 4 = 8) -- expected: false\n\n/-- Negative test: 2 * 3 \u2260 9 -/\nexample : \u00ac(squareOrDouble 3 = 9) := by native_decide\n#eval decide (squareOrDouble 3 = 9) -- expected: false\n\n/-!\n# Properties and Theorems\n-/\n\n/-- Pre-condition: input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Result is even for even inputs property -/\ndef result_is_even_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Monotonicity property: output grows with input -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n < m \u2192 squareOrDouble n < squareOrDouble m\n\n/-- Even result is square property -/\ndef even_result_square_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd result is double property -/\ndef odd_result_double_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Zero property -/\ndef zero_prop : Prop := squareOrDouble 0 = 0\n\n/-- Post-condition combining all properties -/\ndef Post_prop (n : Nat) : Prop :=\n  result_is_even_prop n \u2227\n  (\u2200 m, monotonicity_prop n m) \u2227\n  even_result_square_prop n \u2227\n  odd_result_double_prop n \u2227\n  zero_prop\n\n/-- Even case theorem -/\ntheorem even_case (n : Nat) (h : n % 2 = 0) : \n  squareOrDouble n = n * n := sorry\n\n/-- Odd case theorem -/\ntheorem odd_case (n : Nat) (h : n % 2 \u2260 0) : \n  squareOrDouble n = 2 * n := sorry\n\n/-- Zero case theorem -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Result is even for even inputs theorem -/\ntheorem even_result (n : Nat) (h : n % 2 = 0) : \n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Monotonicity theorem -/\ntheorem monotonicity (n m : Nat) (h : n < m) :\n  squareOrDouble n < squareOrDouble m := sorry\n\n/-- Growth property theorem -/\ntheorem growth (n : Nat) (h1 : n > 0) (h2 : n % 2 = 0) : \n  squareOrDouble n > 2 * n := sorry\n\n/-- Correctness theorem -/\ntheorem correctness (n : Nat) (h : Pre n) : Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state.\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := n + n\n    return result\n\n/-!\n# Imperative Tests\n-/\n\n/-- Test imperative even: 4\u00b2 = 16 -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4 -- expected: 16\n\n/-- Test imperative odd: 2 * 5 = 10 -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5 -- expected: 10\n\n/-- Test imperative zero case -/\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0 -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 8,
      "score": 0.9733333333333334,
      "best_score": 0.9733333333333334,
      "is_new_best": true,
      "feedback": "The original code passed compilation and unit tests. We use a LLM judge to score the semantic equivalence between the golden reference and the generated Lean 4 code. Rationale from the LLM judge: The agent's implementation is semantically equivalent to the gold standard with some minor differences:\n\n1. Core functionality matches:\n- Both implement the same square-or-double logic\n- Both handle even/odd cases correctly\n- Both handle edge cases (0) correctly\n\n2. Key differences:\n- Different namespac",
      "lean_code": "/-!\n# Square or Double Function\n\nIf n is even return n^2 else return 2n, for natural number n.\n\nEdge cases:\n- Works for zero\n- Takes only natural number inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\n## Examples\n#eval squareOrDouble 4 -- expected: 16\n#eval squareOrDouble 5 -- expected: 10\n#eval squareOrDouble 0 -- expected: 0\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-!\n# Tests\n-/\n\n/-- Basic test: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4 -- expected: 16\n\n/-- Basic test: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5 -- expected: 10\n\n/-!\n# Edge Case Tests\n-/\n\n/-- Edge test: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0 -- expected: 0\n\n/-!\n# Property Tests\n-/\n\n/-- Test: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6 -- expected: 36\n\n/-- Test: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7 -- expected: 14\n\n/-- Test: 8\u00b2 = 64 -/\nexample : squareOrDouble 8 = 64 := by native_decide\n#eval squareOrDouble 8 -- expected: 64\n\n/-- Test: 2 * 9 = 18 -/\nexample : squareOrDouble 9 = 18 := by native_decide\n#eval squareOrDouble 9 -- expected: 18\n\n/-!\n# Negative Tests\n-/\n\n/-- Negative test: 4\u00b2 \u2260 8 -/\nexample : \u00ac(squareOrDouble 4 = 8) := by native_decide\n#eval decide (squareOrDouble 4 = 8) -- expected: false\n\n/-- Negative test: 2 * 3 \u2260 9 -/\nexample : \u00ac(squareOrDouble 3 = 9) := by native_decide\n#eval decide (squareOrDouble 3 = 9) -- expected: false\n\n/-!\n# Properties and Theorems\n-/\n\n/-- Pre-condition: input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Even input results in square property -/\ndef even_square_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd input results in double property -/\ndef odd_double_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Zero property -/\ndef zero_prop : Prop := squareOrDouble 0 = 0\n\n/-- Result is even for even inputs property -/\ndef result_is_even_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Monotonicity property -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n \u2264 m \u2192 squareOrDouble n \u2264 squareOrDouble m\n\n/-- Post-condition combining all properties -/\ndef Post_prop (n : Nat) : Prop :=\n  even_square_prop n \u2227\n  odd_double_prop n \u2227\n  zero_prop \u2227\n  result_is_even_prop n \u2227\n  \u2200 m, monotonicity_prop n m\n\n/-- Even case theorem -/\ntheorem even_case (n : Nat) (h : n % 2 = 0) : \n  squareOrDouble n = n * n := sorry\n\n/-- Odd case theorem -/\ntheorem odd_case (n : Nat) (h : n % 2 \u2260 0) : \n  squareOrDouble n = 2 * n := sorry\n\n/-- Zero case theorem -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Even result theorem -/\ntheorem even_result (n : Nat) (h : n % 2 = 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Monotonicity theorem -/\ntheorem monotonic (n m : Nat) (h : n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-- Correctness theorem -/\ntheorem correctness (n : Nat) (h : Pre n) : Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state.\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := n + n\n    return result\n\n/-!\n# Imperative Tests\n-/\n\n/-- Test imperative even: 4\u00b2 = 16 -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4 -- expected: 16\n\n/-- Test imperative odd: 2 * 5 = 10 -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5 -- expected: 10\n\n/-- Test imperative zero case -/\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0 -- expected: 0\n\n/-- Test imperative larger even: 8\u00b2 = 64 -/\nexample : squareOrDoubleImp 8 = 64 := by native_decide\n#eval squareOrDoubleImp 8 -- expected: 64\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "best_lean_code": "/-!\n# Square or Double Function\n\nIf n is even return n^2 else return 2n, for natural number n.\n\nEdge cases:\n- Works for zero\n- Takes only natural number inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\n## Examples\n#eval squareOrDouble 4 -- expected: 16\n#eval squareOrDouble 5 -- expected: 10\n#eval squareOrDouble 0 -- expected: 0\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-!\n# Tests\n-/\n\n/-- Basic test: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4 -- expected: 16\n\n/-- Basic test: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5 -- expected: 10\n\n/-!\n# Edge Case Tests\n-/\n\n/-- Edge test: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0 -- expected: 0\n\n/-!\n# Property Tests\n-/\n\n/-- Test: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6 -- expected: 36\n\n/-- Test: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7 -- expected: 14\n\n/-- Test: 8\u00b2 = 64 -/\nexample : squareOrDouble 8 = 64 := by native_decide\n#eval squareOrDouble 8 -- expected: 64\n\n/-- Test: 2 * 9 = 18 -/\nexample : squareOrDouble 9 = 18 := by native_decide\n#eval squareOrDouble 9 -- expected: 18\n\n/-!\n# Negative Tests\n-/\n\n/-- Negative test: 4\u00b2 \u2260 8 -/\nexample : \u00ac(squareOrDouble 4 = 8) := by native_decide\n#eval decide (squareOrDouble 4 = 8) -- expected: false\n\n/-- Negative test: 2 * 3 \u2260 9 -/\nexample : \u00ac(squareOrDouble 3 = 9) := by native_decide\n#eval decide (squareOrDouble 3 = 9) -- expected: false\n\n/-!\n# Properties and Theorems\n-/\n\n/-- Pre-condition: input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Even input results in square property -/\ndef even_square_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd input results in double property -/\ndef odd_double_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Zero property -/\ndef zero_prop : Prop := squareOrDouble 0 = 0\n\n/-- Result is even for even inputs property -/\ndef result_is_even_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Monotonicity property -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n \u2264 m \u2192 squareOrDouble n \u2264 squareOrDouble m\n\n/-- Post-condition combining all properties -/\ndef Post_prop (n : Nat) : Prop :=\n  even_square_prop n \u2227\n  odd_double_prop n \u2227\n  zero_prop \u2227\n  result_is_even_prop n \u2227\n  \u2200 m, monotonicity_prop n m\n\n/-- Even case theorem -/\ntheorem even_case (n : Nat) (h : n % 2 = 0) : \n  squareOrDouble n = n * n := sorry\n\n/-- Odd case theorem -/\ntheorem odd_case (n : Nat) (h : n % 2 \u2260 0) : \n  squareOrDouble n = 2 * n := sorry\n\n/-- Zero case theorem -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Even result theorem -/\ntheorem even_result (n : Nat) (h : n % 2 = 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Monotonicity theorem -/\ntheorem monotonic (n m : Nat) (h : n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-- Correctness theorem -/\ntheorem correctness (n : Nat) (h : Pre n) : Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state.\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := n + n\n    return result\n\n/-!\n# Imperative Tests\n-/\n\n/-- Test imperative even: 4\u00b2 = 16 -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4 -- expected: 16\n\n/-- Test imperative odd: 2 * 5 = 10 -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5 -- expected: 10\n\n/-- Test imperative zero case -/\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0 -- expected: 0\n\n/-- Test imperative larger even: 8\u00b2 = 64 -/\nexample : squareOrDoubleImp 8 = 64 := by native_decide\n#eval squareOrDoubleImp 8 -- expected: 64\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 9,
      "score": 0.9733333333333334,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "feedback": "The original code passed compilation and unit tests. We use a LLM judge to score the semantic equivalence between the golden reference and the generated Lean 4 code. Rationale from the LLM judge: The agent's implementation is semantically equivalent to the gold standard, with both correctly implementing the square-or-double functionality. Key observations:\n\n1. Core Function:\n- Both implement the same logic (square if even, double if odd)\n- Both handle edge cases correctly (especially 0)\n\n2. Prop",
      "lean_code": "/-!\n# Square or Double Function\n\nIf n is even return n^2 else return 2n, for natural number n.\n\nEdge cases:\n- Works for zero\n- Takes only natural number inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\nEdge cases:\n- Works for zero\n- Only accepts natural numbers\n\n## Examples\n#eval squareOrDouble 4 -- expected: 16\n#eval squareOrDouble 5 -- expected: 10\n#eval squareOrDouble 0 -- expected: 0\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-!\n# Basic Tests\n-/\n\n/-- Basic test: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4 -- expected: 16\n\n/-- Basic test: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5 -- expected: 10\n\n/-!\n# Edge Case Tests\n-/\n\n/-- Edge test: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0 -- expected: 0\n\n/-!\n# Additional Test Cases\n-/\n\n/-- Test: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6 -- expected: 36\n\n/-- Test: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7 -- expected: 14\n\n/-- Test: 8\u00b2 = 64 -/\nexample : squareOrDouble 8 = 64 := by native_decide\n#eval squareOrDouble 8 -- expected: 64\n\n/-!\n# Negative Tests\n-/\n\n/-- Negative test: 4\u00b2 \u2260 8 -/\nexample : \u00ac(squareOrDouble 4 = 8) := by native_decide\n#eval decide (squareOrDouble 4 = 8) -- expected: false\n\n/-- Negative test: 2 * 3 \u2260 9 -/\nexample : \u00ac(squareOrDouble 3 = 9) := by native_decide\n#eval decide (squareOrDouble 3 = 9) -- expected: false\n\n/-!\n# Properties and Theorems\n-/\n\n/-- Pre-condition: input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Even input results in square property -/\ndef even_square_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd input results in double property -/\ndef odd_double_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Zero property -/\ndef zero_prop : Prop := squareOrDouble 0 = 0\n\n/-- Result is even for even inputs property -/\ndef result_is_even_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Post-condition combining all properties -/\ndef Post_prop (n : Nat) : Prop :=\n  even_square_prop n \u2227\n  odd_double_prop n \u2227\n  zero_prop \u2227\n  result_is_even_prop n\n\n/-- Even case theorem -/\ntheorem even_case (n : Nat) (h : n % 2 = 0) : \n  squareOrDouble n = n * n := sorry\n\n/-- Odd case theorem -/\ntheorem odd_case (n : Nat) (h : n % 2 \u2260 0) : \n  squareOrDouble n = 2 * n := sorry\n\n/-- Zero case theorem -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Even result theorem -/\ntheorem even_result (n : Nat) (h : n % 2 = 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness (n : Nat) (h : Pre n) : Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state.\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-!\n# Imperative Tests\n-/\n\n/-- Test imperative even: 4\u00b2 = 16 -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4 -- expected: 16\n\n/-- Test imperative odd: 2 * 5 = 10 -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5 -- expected: 10\n\n/-- Test imperative zero case -/\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0 -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "best_lean_code": "/-!\n# Square or Double Function\n\nIf n is even return n^2 else return 2n, for natural number n.\n\nEdge cases:\n- Works for zero\n- Takes only natural number inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\n## Examples\n#eval squareOrDouble 4 -- expected: 16\n#eval squareOrDouble 5 -- expected: 10\n#eval squareOrDouble 0 -- expected: 0\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-!\n# Tests\n-/\n\n/-- Basic test: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4 -- expected: 16\n\n/-- Basic test: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5 -- expected: 10\n\n/-!\n# Edge Case Tests\n-/\n\n/-- Edge test: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0 -- expected: 0\n\n/-!\n# Property Tests\n-/\n\n/-- Test: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6 -- expected: 36\n\n/-- Test: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7 -- expected: 14\n\n/-- Test: 8\u00b2 = 64 -/\nexample : squareOrDouble 8 = 64 := by native_decide\n#eval squareOrDouble 8 -- expected: 64\n\n/-- Test: 2 * 9 = 18 -/\nexample : squareOrDouble 9 = 18 := by native_decide\n#eval squareOrDouble 9 -- expected: 18\n\n/-!\n# Negative Tests\n-/\n\n/-- Negative test: 4\u00b2 \u2260 8 -/\nexample : \u00ac(squareOrDouble 4 = 8) := by native_decide\n#eval decide (squareOrDouble 4 = 8) -- expected: false\n\n/-- Negative test: 2 * 3 \u2260 9 -/\nexample : \u00ac(squareOrDouble 3 = 9) := by native_decide\n#eval decide (squareOrDouble 3 = 9) -- expected: false\n\n/-!\n# Properties and Theorems\n-/\n\n/-- Pre-condition: input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Even input results in square property -/\ndef even_square_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd input results in double property -/\ndef odd_double_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Zero property -/\ndef zero_prop : Prop := squareOrDouble 0 = 0\n\n/-- Result is even for even inputs property -/\ndef result_is_even_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Monotonicity property -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n \u2264 m \u2192 squareOrDouble n \u2264 squareOrDouble m\n\n/-- Post-condition combining all properties -/\ndef Post_prop (n : Nat) : Prop :=\n  even_square_prop n \u2227\n  odd_double_prop n \u2227\n  zero_prop \u2227\n  result_is_even_prop n \u2227\n  \u2200 m, monotonicity_prop n m\n\n/-- Even case theorem -/\ntheorem even_case (n : Nat) (h : n % 2 = 0) : \n  squareOrDouble n = n * n := sorry\n\n/-- Odd case theorem -/\ntheorem odd_case (n : Nat) (h : n % 2 \u2260 0) : \n  squareOrDouble n = 2 * n := sorry\n\n/-- Zero case theorem -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Even result theorem -/\ntheorem even_result (n : Nat) (h : n % 2 = 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Monotonicity theorem -/\ntheorem monotonic (n m : Nat) (h : n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-- Correctness theorem -/\ntheorem correctness (n : Nat) (h : Pre n) : Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state.\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := n + n\n    return result\n\n/-!\n# Imperative Tests\n-/\n\n/-- Test imperative even: 4\u00b2 = 16 -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4 -- expected: 16\n\n/-- Test imperative odd: 2 * 5 = 10 -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5 -- expected: 10\n\n/-- Test imperative zero case -/\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0 -- expected: 0\n\n/-- Test imperative larger even: 8\u00b2 = 64 -/\nexample : squareOrDoubleImp 8 = 64 := by native_decide\n#eval squareOrDoubleImp 8 -- expected: 64\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 10,
      "score": 0.9733333333333334,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "feedback": "The original code passed compilation and unit tests. We use a LLM judge to score the semantic equivalence between the golden reference and the generated Lean 4 code. Rationale from the LLM judge: The agent's implementation is semantically equivalent to the gold standard with some minor differences:\n\n1. Core functionality matches:\n- Both implement the same square-or-double logic\n- Both handle edge cases correctly (especially 0)\n- Both use the same basic approach (if-then-else on n % 2)\n\n2. Proper",
      "lean_code": "/-!\n# Square or Double Function\n\nIf n is even return n^2 else return 2n, for natural number n.\n\nEdge cases:\n- Works for zero\n- Takes only natural number inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\nEdge cases:\n- Works for zero\n- Only accepts natural numbers\n\n## Examples\n#eval squareOrDouble 4 -- expected: 16\n#eval squareOrDouble 5 -- expected: 10\n#eval squareOrDouble 0 -- expected: 0\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-!\n# Basic Tests\n-/\n\n/-- Basic test: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4 -- expected: 16\n\n/-- Basic test: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5 -- expected: 10\n\n/-!\n# Edge Case Tests\n-/\n\n/-- Edge test: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0 -- expected: 0\n\n/-!\n# Additional Test Cases\n-/\n\n/-- Test: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6 -- expected: 36\n\n/-- Test: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7 -- expected: 14\n\n/-- Test: 8\u00b2 = 64 -/\nexample : squareOrDouble 8 = 64 := by native_decide\n#eval squareOrDouble 8 -- expected: 64\n\n/-!\n# Negative Tests\n-/\n\n/-- Negative test: 4\u00b2 \u2260 8 -/\nexample : \u00ac(squareOrDouble 4 = 8) := by native_decide\n#eval decide (squareOrDouble 4 = 8) -- expected: false\n\n/-- Negative test: 2 * 3 \u2260 9 -/\nexample : \u00ac(squareOrDouble 3 = 9) := by native_decide\n#eval decide (squareOrDouble 3 = 9) -- expected: false\n\n/-!\n# Properties and Theorems\n-/\n\n/-- Pre-condition: input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Even input results in square property -/\ndef even_square_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd input results in double property -/\ndef odd_double_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Zero property -/\ndef zero_prop : Prop := squareOrDouble 0 = 0\n\n/-- Result is even for even inputs property -/\ndef result_is_even_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Post-condition combining all properties -/\ndef Post_prop (n : Nat) : Prop :=\n  even_square_prop n \u2227\n  odd_double_prop n \u2227\n  zero_prop \u2227\n  result_is_even_prop n\n\n/-- Even case theorem -/\ntheorem even_case (n : Nat) (h : n % 2 = 0) : \n  squareOrDouble n = n * n := sorry\n\n/-- Odd case theorem -/\ntheorem odd_case (n : Nat) (h : n % 2 \u2260 0) : \n  squareOrDouble n = 2 * n := sorry\n\n/-- Zero case theorem -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Even result theorem -/\ntheorem even_result (n : Nat) (h : n % 2 = 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness (n : Nat) (h : Pre n) : Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state.\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-!\n# Imperative Tests\n-/\n\n/-- Test imperative even: 4\u00b2 = 16 -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4 -- expected: 16\n\n/-- Test imperative odd: 2 * 5 = 10 -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5 -- expected: 10\n\n/-- Test imperative zero case -/\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0 -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "best_lean_code": "/-!\n# Square or Double Function\n\nIf n is even return n^2 else return 2n, for natural number n.\n\nEdge cases:\n- Works for zero\n- Takes only natural number inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\n## Examples\n#eval squareOrDouble 4 -- expected: 16\n#eval squareOrDouble 5 -- expected: 10\n#eval squareOrDouble 0 -- expected: 0\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-!\n# Tests\n-/\n\n/-- Basic test: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4 -- expected: 16\n\n/-- Basic test: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5 -- expected: 10\n\n/-!\n# Edge Case Tests\n-/\n\n/-- Edge test: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0 -- expected: 0\n\n/-!\n# Property Tests\n-/\n\n/-- Test: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6 -- expected: 36\n\n/-- Test: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7 -- expected: 14\n\n/-- Test: 8\u00b2 = 64 -/\nexample : squareOrDouble 8 = 64 := by native_decide\n#eval squareOrDouble 8 -- expected: 64\n\n/-- Test: 2 * 9 = 18 -/\nexample : squareOrDouble 9 = 18 := by native_decide\n#eval squareOrDouble 9 -- expected: 18\n\n/-!\n# Negative Tests\n-/\n\n/-- Negative test: 4\u00b2 \u2260 8 -/\nexample : \u00ac(squareOrDouble 4 = 8) := by native_decide\n#eval decide (squareOrDouble 4 = 8) -- expected: false\n\n/-- Negative test: 2 * 3 \u2260 9 -/\nexample : \u00ac(squareOrDouble 3 = 9) := by native_decide\n#eval decide (squareOrDouble 3 = 9) -- expected: false\n\n/-!\n# Properties and Theorems\n-/\n\n/-- Pre-condition: input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Even input results in square property -/\ndef even_square_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd input results in double property -/\ndef odd_double_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Zero property -/\ndef zero_prop : Prop := squareOrDouble 0 = 0\n\n/-- Result is even for even inputs property -/\ndef result_is_even_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Monotonicity property -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n \u2264 m \u2192 squareOrDouble n \u2264 squareOrDouble m\n\n/-- Post-condition combining all properties -/\ndef Post_prop (n : Nat) : Prop :=\n  even_square_prop n \u2227\n  odd_double_prop n \u2227\n  zero_prop \u2227\n  result_is_even_prop n \u2227\n  \u2200 m, monotonicity_prop n m\n\n/-- Even case theorem -/\ntheorem even_case (n : Nat) (h : n % 2 = 0) : \n  squareOrDouble n = n * n := sorry\n\n/-- Odd case theorem -/\ntheorem odd_case (n : Nat) (h : n % 2 \u2260 0) : \n  squareOrDouble n = 2 * n := sorry\n\n/-- Zero case theorem -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Even result theorem -/\ntheorem even_result (n : Nat) (h : n % 2 = 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Monotonicity theorem -/\ntheorem monotonic (n m : Nat) (h : n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-- Correctness theorem -/\ntheorem correctness (n : Nat) (h : Pre n) : Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state.\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := n + n\n    return result\n\n/-!\n# Imperative Tests\n-/\n\n/-- Test imperative even: 4\u00b2 = 16 -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4 -- expected: 16\n\n/-- Test imperative odd: 2 * 5 = 10 -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5 -- expected: 10\n\n/-- Test imperative zero case -/\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0 -- expected: 0\n\n/-- Test imperative larger even: 8\u00b2 = 64 -/\nexample : squareOrDoubleImp 8 = 64 := by native_decide\n#eval squareOrDoubleImp 8 -- expected: 64\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 11,
      "score": 1.0,
      "best_score": 1.0,
      "is_new_best": true,
      "feedback": "The original code passed compilation and unit tests. We use a LLM judge to score the semantic equivalence between the golden reference and the generated Lean 4 code. Rationale from the LLM judge: The agent's implementation is semantically equivalent to the gold standard, with both correctly implementing the square-or-double functionality. Key observations:\n\n1. Core Function:\n- Both implement the same logic (square if even, double if odd)\n- Both handle edge cases correctly (especially 0)\n- Both u",
      "lean_code": "/-!\n# Square or Double Function\n\nIf n is even return n^2 else return 2n, for natural number n.\n\nEdge cases:\n- Works for zero.\n- Takes only natural number inputs (invalid inputs not possible due to Nat type)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\nEdge cases:\n- Works for zero\n- Only accepts natural numbers (enforced by type system)\n- Non-integer inputs are invalid (handled by Lean type system)\n\n## Examples\n#eval squareOrDouble 4 -- expected: 16\n#eval squareOrDouble 5 -- expected: 10\n#eval squareOrDouble 0 -- expected: 0\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-!\n# Basic Tests\n-/\n\n/-- Basic test: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4 -- expected: 16\n\n/-- Basic test: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5 -- expected: 10\n\n/-!\n# Edge Case Tests\n-/\n\n/-- Edge test: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0 -- expected: 0\n\n/-!\n# Additional Test Cases\n-/\n\n/-- Test: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6 -- expected: 36\n\n/-- Test: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7 -- expected: 14\n\n/-- Test: 8\u00b2 = 64 -/\nexample : squareOrDouble 8 = 64 := by native_decide\n#eval squareOrDouble 8 -- expected: 64\n\n/-- Test: 2 * 3 = 6 -/\nexample : squareOrDouble 3 = 6 := by native_decide\n#eval squareOrDouble 3 -- expected: 6\n\n/-- Test: 2\u00b2 = 4 -/\nexample : squareOrDouble 2 = 4 := by native_decide\n#eval squareOrDouble 2 -- expected: 4\n\n/-!\n# Negative Tests\n-/\n\n/-- Negative test: 4\u00b2 \u2260 8 -/\nexample : \u00ac(squareOrDouble 4 = 8) := by native_decide\n#eval decide (squareOrDouble 4 = 8) -- expected: false\n\n/-- Negative test: 2 * 3 \u2260 9 -/\nexample : \u00ac(squareOrDouble 3 = 9) := by native_decide\n#eval decide (squareOrDouble 3 = 9) -- expected: false\n\n/-- Negative test: 2 * 5 \u2260 25 -/\nexample : \u00ac(squareOrDouble 5 = 25) := by native_decide\n#eval decide (squareOrDouble 5 = 25) -- expected: false\n\n/-!\n# Properties and Theorems\n-/\n\n/-- Pre-condition: input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Even input results in square property -/\ndef even_square_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd input results in double property -/\ndef odd_double_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Zero property -/\ndef zero_prop : Prop := squareOrDouble 0 = 0\n\n/-- Result is even for even inputs property -/\ndef result_is_even_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Result is greater than input for non-zero even inputs -/\ndef growth_prop (n : Nat) : Prop :=\n  n > 0 \u2227 n % 2 = 0 \u2192 squareOrDouble n > n\n\n/-- Post-condition combining all properties -/\ndef Post_prop (n : Nat) : Prop :=\n  even_square_prop n \u2227\n  odd_double_prop n \u2227\n  zero_prop \u2227\n  result_is_even_prop n \u2227\n  growth_prop n\n\n/-- Even case theorem -/\ntheorem even_case (n : Nat) (h : n % 2 = 0) : \n  squareOrDouble n = n * n := sorry\n\n/-- Odd case theorem -/\ntheorem odd_case (n : Nat) (h : n % 2 \u2260 0) : \n  squareOrDouble n = 2 * n := sorry\n\n/-- Zero case theorem -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Even result theorem -/\ntheorem even_result (n : Nat) (h : n % 2 = 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Growth theorem -/\ntheorem growth (n : Nat) (h1 : n > 0) (h2 : n % 2 = 0) :\n  squareOrDouble n > n := sorry\n\n/-- Correctness theorem -/\ntheorem correctness (n : Nat) (h : Pre n) : Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state.\nReturns n\u00b2 for even n, 2n for odd n.\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-!\n# Imperative Tests\n-/\n\n/-- Test imperative even: 4\u00b2 = 16 -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4 -- expected: 16\n\n/-- Test imperative odd: 2 * 5 = 10 -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5 -- expected: 10\n\n/-- Test imperative zero case -/\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0 -- expected: 0\n\n/-- Test imperative even: 6\u00b2 = 36 -/\nexample : squareOrDoubleImp 6 = 36 := by native_decide\n#eval squareOrDoubleImp 6 -- expected: 36\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "best_lean_code": "/-!\n# Square or Double Function\n\nIf n is even return n^2 else return 2n, for natural number n.\n\nEdge cases:\n- Works for zero.\n- Takes only natural number inputs (invalid inputs not possible due to Nat type)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\nEdge cases:\n- Works for zero\n- Only accepts natural numbers (enforced by type system)\n- Non-integer inputs are invalid (handled by Lean type system)\n\n## Examples\n#eval squareOrDouble 4 -- expected: 16\n#eval squareOrDouble 5 -- expected: 10\n#eval squareOrDouble 0 -- expected: 0\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-!\n# Basic Tests\n-/\n\n/-- Basic test: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4 -- expected: 16\n\n/-- Basic test: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5 -- expected: 10\n\n/-!\n# Edge Case Tests\n-/\n\n/-- Edge test: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0 -- expected: 0\n\n/-!\n# Additional Test Cases\n-/\n\n/-- Test: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6 -- expected: 36\n\n/-- Test: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7 -- expected: 14\n\n/-- Test: 8\u00b2 = 64 -/\nexample : squareOrDouble 8 = 64 := by native_decide\n#eval squareOrDouble 8 -- expected: 64\n\n/-- Test: 2 * 3 = 6 -/\nexample : squareOrDouble 3 = 6 := by native_decide\n#eval squareOrDouble 3 -- expected: 6\n\n/-- Test: 2\u00b2 = 4 -/\nexample : squareOrDouble 2 = 4 := by native_decide\n#eval squareOrDouble 2 -- expected: 4\n\n/-!\n# Negative Tests\n-/\n\n/-- Negative test: 4\u00b2 \u2260 8 -/\nexample : \u00ac(squareOrDouble 4 = 8) := by native_decide\n#eval decide (squareOrDouble 4 = 8) -- expected: false\n\n/-- Negative test: 2 * 3 \u2260 9 -/\nexample : \u00ac(squareOrDouble 3 = 9) := by native_decide\n#eval decide (squareOrDouble 3 = 9) -- expected: false\n\n/-- Negative test: 2 * 5 \u2260 25 -/\nexample : \u00ac(squareOrDouble 5 = 25) := by native_decide\n#eval decide (squareOrDouble 5 = 25) -- expected: false\n\n/-!\n# Properties and Theorems\n-/\n\n/-- Pre-condition: input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Even input results in square property -/\ndef even_square_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Odd input results in double property -/\ndef odd_double_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Zero property -/\ndef zero_prop : Prop := squareOrDouble 0 = 0\n\n/-- Result is even for even inputs property -/\ndef result_is_even_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Result is greater than input for non-zero even inputs -/\ndef growth_prop (n : Nat) : Prop :=\n  n > 0 \u2227 n % 2 = 0 \u2192 squareOrDouble n > n\n\n/-- Post-condition combining all properties -/\ndef Post_prop (n : Nat) : Prop :=\n  even_square_prop n \u2227\n  odd_double_prop n \u2227\n  zero_prop \u2227\n  result_is_even_prop n \u2227\n  growth_prop n\n\n/-- Even case theorem -/\ntheorem even_case (n : Nat) (h : n % 2 = 0) : \n  squareOrDouble n = n * n := sorry\n\n/-- Odd case theorem -/\ntheorem odd_case (n : Nat) (h : n % 2 \u2260 0) : \n  squareOrDouble n = 2 * n := sorry\n\n/-- Zero case theorem -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Even result theorem -/\ntheorem even_result (n : Nat) (h : n % 2 = 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Growth theorem -/\ntheorem growth (n : Nat) (h1 : n > 0) (h2 : n % 2 = 0) :\n  squareOrDouble n > n := sorry\n\n/-- Correctness theorem -/\ntheorem correctness (n : Nat) (h : Pre n) : Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state.\nReturns n\u00b2 for even n, 2n for odd n.\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := 0\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-!\n# Imperative Tests\n-/\n\n/-- Test imperative even: 4\u00b2 = 16 -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4 -- expected: 16\n\n/-- Test imperative odd: 2 * 5 = 10 -/\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5 -- expected: 10\n\n/-- Test imperative zero case -/\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0 -- expected: 0\n\n/-- Test imperative even: 6\u00b2 = 36 -/\nexample : squareOrDoubleImp 6 = 36 := by native_decide\n#eval squareOrDoubleImp 6 -- expected: 36\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    }
  ],
  "settings": {
    "model": "anthropic/claude-3.5-sonnet",
    "max_attempts": 50
  }
}