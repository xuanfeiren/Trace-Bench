{
  "task_idx": 33,
  "task_id": 33,
  "success": false,
  "final_score": 0.84,
  "num_metric_calls": 50,
  "success_at_metric_call": null,
  "best_lean_code": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive",
  "duration_seconds": 1063.443202972412,
  "history": [
    {
      "attempt": 1,
      "score": 0.0,
      "best_score": 0.0,
      "is_new_best": false,
      "iteration_found": 1,
      "best_lean_program": "-- No code generated yet"
    },
    {
      "attempt": 2,
      "score": 0.0,
      "best_score": 0.0,
      "is_new_best": false,
      "iteration_found": 2,
      "best_lean_program": "-- No code generated yet"
    },
    {
      "attempt": 3,
      "score": 0.0,
      "best_score": 0.0,
      "is_new_best": false,
      "iteration_found": 3,
      "best_lean_program": "-- No code generated yet"
    },
    {
      "attempt": 4,
      "score": 0.0,
      "best_score": 0.0,
      "is_new_best": false,
      "iteration_found": 4,
      "best_lean_program": "-- No code generated yet"
    },
    {
      "attempt": 5,
      "score": 0.0,
      "best_score": 0.0,
      "is_new_best": false,
      "iteration_found": 5,
      "best_lean_program": "-- No code generated yet"
    },
    {
      "attempt": 6,
      "score": 0.0,
      "best_score": 0.0,
      "is_new_best": false,
      "iteration_found": 6,
      "best_lean_program": "-- No code generated yet"
    },
    {
      "attempt": 7,
      "score": 0.0,
      "best_score": 0.0,
      "is_new_best": false,
      "iteration_found": 7,
      "best_lean_program": "-- No code generated yet"
    },
    {
      "attempt": 8,
      "score": 0.0,
      "best_score": 0.0,
      "is_new_best": false,
      "iteration_found": 8,
      "best_lean_program": "-- No code generated yet"
    },
    {
      "attempt": 9,
      "score": 0.0,
      "best_score": 0.0,
      "is_new_best": false,
      "iteration_found": 9,
      "best_lean_program": "-- No code generated yet"
    },
    {
      "attempt": 10,
      "score": 0.0,
      "best_score": 0.0,
      "is_new_best": false,
      "iteration_found": 10,
      "best_lean_program": "-- No code generated yet"
    },
    {
      "attempt": 11,
      "score": 0.0,
      "best_score": 0.0,
      "is_new_best": false,
      "iteration_found": 11,
      "best_lean_program": "-- No code generated yet"
    },
    {
      "attempt": 12,
      "score": 0.0,
      "best_score": 0.0,
      "is_new_best": false,
      "iteration_found": 12,
      "best_lean_program": "-- No code generated yet"
    },
    {
      "attempt": 13,
      "score": 0.0,
      "best_score": 0.0,
      "is_new_best": false,
      "iteration_found": 13,
      "best_lean_program": "-- No code generated yet"
    },
    {
      "attempt": 14,
      "score": 0.0,
      "best_score": 0.0,
      "is_new_best": false,
      "iteration_found": 14,
      "best_lean_program": "-- No code generated yet"
    },
    {
      "attempt": 15,
      "score": 0.0,
      "best_score": 0.0,
      "is_new_best": false,
      "iteration_found": 15,
      "best_lean_program": "-- No code generated yet"
    },
    {
      "attempt": 16,
      "score": 0.0,
      "best_score": 0.0,
      "is_new_best": false,
      "iteration_found": 16,
      "best_lean_program": "-- No code generated yet"
    },
    {
      "attempt": 17,
      "score": 0.0,
      "best_score": 0.0,
      "is_new_best": false,
      "iteration_found": 17,
      "best_lean_program": "-- No code generated yet"
    },
    {
      "attempt": 18,
      "score": 0.0,
      "best_score": 0.0,
      "is_new_best": false,
      "iteration_found": 18,
      "best_lean_program": "-- No code generated yet"
    },
    {
      "attempt": 19,
      "score": 0.0,
      "best_score": 0.0,
      "is_new_best": false,
      "iteration_found": 19,
      "best_lean_program": "-- No code generated yet"
    },
    {
      "attempt": 20,
      "score": 0.0,
      "best_score": 0.0,
      "is_new_best": false,
      "iteration_found": 20,
      "best_lean_program": "-- No code generated yet"
    },
    {
      "attempt": 21,
      "score": 0.0,
      "best_score": 0.0,
      "is_new_best": false,
      "iteration_found": 21,
      "best_lean_program": "-- No code generated yet"
    },
    {
      "attempt": 22,
      "score": 0.84,
      "best_score": 0.84,
      "is_new_best": true,
      "iteration_found": 22,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 23,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 23,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 24,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 24,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 25,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 25,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 26,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 26,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 27,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 27,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 28,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 28,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 29,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 29,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 30,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 30,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 31,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 31,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 32,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 32,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 33,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 33,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 34,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 34,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 35,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 35,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 36,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 36,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 37,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 37,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 38,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 38,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 39,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 39,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 40,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 40,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 41,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 41,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 42,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 42,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 43,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 43,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 44,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 44,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 45,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 45,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 46,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 46,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 47,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 47,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 48,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 48,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 49,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 49,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    },
    {
      "attempt": 50,
      "score": 0.0,
      "best_score": 0.84,
      "is_new_best": false,
      "iteration_found": 50,
      "best_lean_program": "/-!\n# Perfect Square or Add Five\n\nReturns n if it's a perfect square, otherwise returns n + 5.\n\nEdge cases:\n- 0 and 1 return themselves\n- Only works on natural numbers (Nat type ensures non-negative)\n-/\n\nnamespace PerfectSquareOrAddFive\n\n/--\nReturns true if the input number is a perfect square by checking numbers up to its square root.\nUses bounded recursion to ensure termination.\n-/\ndef isPerfectSquare (n : Nat) : Bool :=\n  match n with\n  | 0 => true  -- 0 is a perfect square\n  | 1 => true  -- 1 is a perfect square\n  | n + 2 =>    -- For n \u2265 2\n    let rec check (i : Nat) (fuel : Nat) : Bool :=\n      match fuel with\n      | 0 => false  -- Exceeded search bound\n      | fuel + 1 =>\n        let square := i * i\n        if square > n then \n          false\n        else if square = n then \n          true\n        else \n          check (i + 1) fuel\n    -- Start search with sufficient fuel (sqrt(n) iterations needed at most)\n    check 1 (n/2 + 1)\n\n/--\nMain function that returns n if it's a perfect square, otherwise returns n + 5.\n\nExamples:\n- perfectSquareOrAddFive 16 = 16 (perfect square)\n- perfectSquareOrAddFive 18 = 23 (not perfect square)\n- perfectSquareOrAddFive 0 = 0 (edge case)\n- perfectSquareOrAddFive 1 = 1 (edge case)\n-/\ndef perfectSquareOrAddFive (n : Nat) : Nat :=\n  if isPerfectSquare n then n else n + 5\n\n/-! Unit Tests -/\n\ndef test1 : Bool := perfectSquareOrAddFive 16 = 16\n#eval test1  -- expected: true\n\ndef test2 : Bool := perfectSquareOrAddFive 18 = 23\n#eval test2  -- expected: true\n\ndef test3 : Bool := perfectSquareOrAddFive 0 = 0\n#eval test3  -- expected: true\n\ndef test4 : Bool := perfectSquareOrAddFive 1 = 1\n#eval test4  -- expected: true\n\ndef test5 : Bool := perfectSquareOrAddFive 4 = 4\n#eval test5  -- expected: true\n\ndef test6 : Bool := perfectSquareOrAddFive 7 = 12\n#eval test6  -- expected: true\n\ndef test7 : Bool := perfectSquareOrAddFive 9 = 9\n#eval test7  -- expected: true\n\ndef test8 : Bool := perfectSquareOrAddFive 10 = 15\n#eval test8  -- expected: true\n\n/-! Properties and Theorems -/\n\n/-- Pre-condition: input is already guaranteed non-negative by Nat type -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: result is either equal to input (if perfect square) or input + 5 -/\ndef Post (n result : Nat) : Prop :=\n  result = n \u2228 result = n + 5\n\n/-- Perfect squares return themselves -/\ntheorem perfect_square_thm {n : Nat} (h : isPerfectSquare n = true) :\n  perfectSquareOrAddFive n = n := sorry\n\n/-- Non-perfect squares return n + 5 -/\ntheorem non_perfect_square_thm {n : Nat} (h : isPerfectSquare n = false) :\n  perfectSquareOrAddFive n = n + 5 := sorry\n\n/-- Correctness theorem -/\ntheorem correctness_thm (n : Nat) : Post n (perfectSquareOrAddFive n) := sorry\n\nend PerfectSquareOrAddFive"
    }
  ],
  "metrics": {
    "combined_score": 0.84
  },
  "settings": {
    "model": "claude-3.5-sonnet",
    "max_iterations": 50,
    "evolution_strategy": "full_rewrite",
    "population_size": 50
  }
}