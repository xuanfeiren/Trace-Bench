{
  "task_idx": 44,
  "task_id": 44,
  "success": false,
  "early_stopped": false,
  "final_score": 0.92,
  "num_metric_calls": 51,
  "num_iterations_total": 28,
  "num_candidates_discovered": 5,
  "success_at_metric_call": null,
  "best_lean_code": "/-!\n# Square or Double Function\n\nThis function takes an integer n and:\n- Returns n\u00b2 if n is even \n- Returns 2n if n is odd\n- Works for zero\n- Only accepts integer inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\nExamples:\n- squareOrDouble 4 = 16  \n- squareOrDouble 5 = 10\n- squareOrDouble 0 = 0\n\nRequires: Input must be an integer\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! \n# Basic Tests\n-/\n\n/-- Basic test case: even number -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test case: odd number -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Additional test cases -/\nexample : squareOrDouble 2 = 4 := by native_decide\nexample : squareOrDouble 3 = 6 := by native_decide\nexample : squareOrDouble 6 = 36 := by native_decide\nexample : squareOrDouble 7 = 14 := by native_decide\n\n/-!\n# Pre/Post Conditions\n-/\n\n/-- Pre-condition: Input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: Result follows square/double rule and maintains properties -/\ndef Post_prop (n : Nat) : Prop :=\n  let result := squareOrDouble n\n  (if n % 2 = 0 then result = n * n else result = 2 * n) \u2227  -- core behavior\n  result \u2265 0 \u2227                                              -- non-negativity\n  (n = 0 \u2192 result = 0) \u2227                                    -- zero case\n  (n \u2265 1 \u2192 result \u2265 n) \u2227                                    -- growth property\n  (n % 2 = 0 \u2192 result % 2 = 0)                             -- even output for even input\n\n/-!\n# Properties\n-/\n\n/-- Property: result is always non-negative -/\ndef nonNegativeOutput_prop (n : Nat) : Prop :=\n  squareOrDouble n \u2265 0\n\n/-- Property: for even numbers, result is perfect square -/\ndef evenCase_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Property: for odd numbers, result is double -/\ndef oddCase_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Property: result is always even when input is even -/\ndef evenResult_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Property: zero maps to zero -/\ndef zero_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-- Property: function is monotonically increasing -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n \u2264 m \u2192 squareOrDouble n \u2264 squareOrDouble m\n\n/-- Property: result is at least as large as input for n \u2265 1 -/\ndef growth_prop (n : Nat) : Prop :=\n  n \u2265 1 \u2192 squareOrDouble n \u2265 n\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: outputs are always non-negative -/\ntheorem nonNegativeOutput_thm (n : Nat) : nonNegativeOutput_prop n := sorry\n\n/-- Theorem: even numbers are squared correctly -/\ntheorem evenCase_thm (n : Nat) : evenCase_prop n := sorry\n\n/-- Theorem: odd numbers are doubled correctly -/\ntheorem oddCase_thm (n : Nat) : oddCase_prop n := sorry\n\n/-- Theorem: zero case works correctly -/\ntheorem zero_thm : zero_prop := sorry\n\n/-- Theorem: result is even for even inputs -/\ntheorem evenResult_thm (n : Nat) : evenResult_prop n := sorry\n\n/-- Theorem: function preserves ordering -/\ntheorem monotonicity_thm (n m : Nat) : monotonicity_prop n m := sorry\n\n/-- Theorem: function grows at least linearly for n \u2265 1 -/\ntheorem growth_thm (n : Nat) : growth_prop n := sorry\n\n/-!\n# Correctness Theorem\n-/\n\n/-- Main correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness_thm (n : Nat) (h : Pre n) :\n  Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := n\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-- Test imperative implementation -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\nexample : squareOrDoubleImp 5 = 10 := by native_decide\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
  "duration_seconds": 860.4395117759705,
  "initial_seed_score": 0.0,
  "iteration_history": [
    {
      "iteration": 1,
      "score": 0.0,
      "best_score_so_far": 0.0,
      "num_metric_calls_so_far": 3,
      "calls_this_iter": 2,
      "accepted_new_candidate": false,
      "new_candidate_score": null,
      "best_lean_program": "-- This is initial placeholder. Generate complete Lean 4 code based on the Python program.",
      "test_score": 0.0
    },
    {
      "iteration": 2,
      "score": 0.0,
      "best_score_so_far": 0.0,
      "num_metric_calls_so_far": 5,
      "calls_this_iter": 2,
      "accepted_new_candidate": false,
      "new_candidate_score": null,
      "best_lean_program": "-- This is initial placeholder. Generate complete Lean 4 code based on the Python program.",
      "test_score": 0.0
    },
    {
      "iteration": 3,
      "score": 0.0,
      "best_score_so_far": 0.0,
      "num_metric_calls_so_far": 7,
      "calls_this_iter": 2,
      "accepted_new_candidate": false,
      "new_candidate_score": null,
      "best_lean_program": "-- This is initial placeholder. Generate complete Lean 4 code based on the Python program.",
      "test_score": 0.0
    },
    {
      "iteration": 4,
      "score": 0.76,
      "best_score_so_far": 0.76,
      "num_metric_calls_so_far": 10,
      "calls_this_iter": 3,
      "accepted_new_candidate": true,
      "new_candidate_score": 0.76,
      "best_lean_program": "/-!\n# Square or Double Function\n\nThis function takes an integer n and:\n- Returns n\u00b2 if n is even\n- Returns 2n if n is odd\n- Works for zero\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\nExamples:\n- square_or_double 4 = 16\n- square_or_double 5 = 10\n- square_or_double 0 = 0\n-/\ndef squareOrDouble (n : Int) : Int :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! \n# Tests\n-/\n\n/-- Basic test case: even number -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test case: odd number -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-!\n# Properties\n-/\n\n/-- Property: result is non-negative for non-negative inputs -/\ndef nonNegativeOutput_prop (n : Int) : Prop :=\n  n \u2265 0 \u2192 squareOrDouble n \u2265 0\n\n/-- Property: for even numbers, result is perfect square -/\ndef evenCase_prop (n : Int) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Property: for odd numbers, result is double -/\ndef oddCase_prop (n : Int) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: non-negative inputs produce non-negative outputs -/\ntheorem nonNegativeOutput_thm (n : Int) : nonNegativeOutput_prop n := sorry\n\n/-- Theorem: even numbers are squared -/\ntheorem evenCase_thm (n : Int) : evenCase_prop n := sorry\n\n/-- Theorem: odd numbers are doubled -/\ntheorem oddCase_thm (n : Int) : oddCase_prop n := sorry\n\nend SquareOrDouble",
      "test_score": 0.76
    },
    {
      "iteration": 5,
      "score": 0.76,
      "best_score_so_far": 0.76,
      "num_metric_calls_so_far": 12,
      "calls_this_iter": 2,
      "accepted_new_candidate": false,
      "new_candidate_score": null,
      "best_lean_program": "/-!\n# Square or Double Function\n\nThis function takes an integer n and:\n- Returns n\u00b2 if n is even\n- Returns 2n if n is odd\n- Works for zero\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\nExamples:\n- square_or_double 4 = 16\n- square_or_double 5 = 10\n- square_or_double 0 = 0\n-/\ndef squareOrDouble (n : Int) : Int :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! \n# Tests\n-/\n\n/-- Basic test case: even number -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test case: odd number -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-!\n# Properties\n-/\n\n/-- Property: result is non-negative for non-negative inputs -/\ndef nonNegativeOutput_prop (n : Int) : Prop :=\n  n \u2265 0 \u2192 squareOrDouble n \u2265 0\n\n/-- Property: for even numbers, result is perfect square -/\ndef evenCase_prop (n : Int) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Property: for odd numbers, result is double -/\ndef oddCase_prop (n : Int) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: non-negative inputs produce non-negative outputs -/\ntheorem nonNegativeOutput_thm (n : Int) : nonNegativeOutput_prop n := sorry\n\n/-- Theorem: even numbers are squared -/\ntheorem evenCase_thm (n : Int) : evenCase_prop n := sorry\n\n/-- Theorem: odd numbers are doubled -/\ntheorem oddCase_thm (n : Int) : oddCase_prop n := sorry\n\nend SquareOrDouble",
      "test_score": 0.76
    },
    {
      "iteration": 6,
      "score": 0.8933333333333333,
      "best_score_so_far": 0.8933333333333333,
      "num_metric_calls_so_far": 15,
      "calls_this_iter": 3,
      "accepted_new_candidate": true,
      "new_candidate_score": 0.8933333333333333,
      "best_lean_program": "/-!\n# Square or Double Function\n\nThis function takes an integer n and:\n- Returns n\u00b2 if n is even \n- Returns 2n if n is odd\n- Works for zero\n- Only accepts integer inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\nExamples:\n- squareOrDouble 4 = 16  \n- squareOrDouble 5 = 10\n- squareOrDouble 0 = 0\n\nRequires: Input must be an integer\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! \n# Basic Tests\n-/\n\n/-- Basic test case: even number -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test case: odd number -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-!\n# Pre/Post Conditions\n-/\n\n/-- Pre-condition: Input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: Result is natural number and follows square/double rule -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  if n % 2 = 0 then\n    result = n * n\n  else\n    result = 2 * n\n\n/-!\n# Properties\n-/\n\n/-- Property: result is always non-negative -/\ndef nonNegativeOutput_prop (n : Nat) : Prop :=\n  squareOrDouble n \u2265 0\n\n/-- Property: for even numbers, result is perfect square -/\ndef evenCase_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Property: for odd numbers, result is double -/\ndef oddCase_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Property: result is always even when input is even -/\ndef evenResult_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Property: zero maps to zero -/\ndef zero_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: outputs are always non-negative -/\ntheorem nonNegativeOutput_thm (n : Nat) : nonNegativeOutput_prop n := sorry\n\n/-- Theorem: even numbers are squared correctly -/\ntheorem evenCase_thm (n : Nat) : evenCase_prop n := sorry\n\n/-- Theorem: odd numbers are doubled correctly -/\ntheorem oddCase_thm (n : Nat) : oddCase_prop n := sorry\n\n/-- Theorem: zero case works correctly -/\ntheorem zero_thm : zero_prop := sorry\n\n/-- Theorem: result is even for even inputs -/\ntheorem evenResult_thm (n : Nat) : evenResult_prop n := sorry\n\n/-!\n# Correctness Theorem\n-/\n\n/-- Main correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness_thm (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      return n * n\n    else\n      return 2 * n\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "test_score": 0.8666666666666667
    },
    {
      "iteration": 7,
      "score": 0.92,
      "best_score_so_far": 0.92,
      "num_metric_calls_so_far": 17,
      "calls_this_iter": 2,
      "accepted_new_candidate": false,
      "new_candidate_score": null,
      "best_lean_program": "/-!\n# Square or Double Function\n\nThis function takes an integer n and:\n- Returns n\u00b2 if n is even \n- Returns 2n if n is odd\n- Works for zero\n- Only accepts integer inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\nExamples:\n- squareOrDouble 4 = 16  \n- squareOrDouble 5 = 10\n- squareOrDouble 0 = 0\n\nRequires: Input must be an integer\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! \n# Basic Tests\n-/\n\n/-- Basic test case: even number -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test case: odd number -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-!\n# Pre/Post Conditions\n-/\n\n/-- Pre-condition: Input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: Result is natural number and follows square/double rule -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  if n % 2 = 0 then\n    result = n * n\n  else\n    result = 2 * n\n\n/-!\n# Properties\n-/\n\n/-- Property: result is always non-negative -/\ndef nonNegativeOutput_prop (n : Nat) : Prop :=\n  squareOrDouble n \u2265 0\n\n/-- Property: for even numbers, result is perfect square -/\ndef evenCase_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Property: for odd numbers, result is double -/\ndef oddCase_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Property: result is always even when input is even -/\ndef evenResult_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Property: zero maps to zero -/\ndef zero_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: outputs are always non-negative -/\ntheorem nonNegativeOutput_thm (n : Nat) : nonNegativeOutput_prop n := sorry\n\n/-- Theorem: even numbers are squared correctly -/\ntheorem evenCase_thm (n : Nat) : evenCase_prop n := sorry\n\n/-- Theorem: odd numbers are doubled correctly -/\ntheorem oddCase_thm (n : Nat) : oddCase_prop n := sorry\n\n/-- Theorem: zero case works correctly -/\ntheorem zero_thm : zero_prop := sorry\n\n/-- Theorem: result is even for even inputs -/\ntheorem evenResult_thm (n : Nat) : evenResult_prop n := sorry\n\n/-!\n# Correctness Theorem\n-/\n\n/-- Main correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness_thm (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      return n * n\n    else\n      return 2 * n\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "test_score": 0.8666666666666667
    },
    {
      "iteration": 8,
      "score": 0.92,
      "best_score_so_far": 0.92,
      "num_metric_calls_so_far": 20,
      "calls_this_iter": 3,
      "accepted_new_candidate": true,
      "new_candidate_score": 0.92,
      "best_lean_program": "/-!\n# Square or Double Function\n\nThis function takes an integer n and:\n- Returns n\u00b2 if n is even \n- Returns 2n if n is odd\n- Works for zero\n- Only accepts integer inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\nExamples:\n- squareOrDouble 4 = 16  \n- squareOrDouble 5 = 10\n- squareOrDouble 0 = 0\n\nRequires: Input must be an integer\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! \n# Basic Tests\n-/\n\n/-- Basic test case: even number -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test case: odd number -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Additional test cases -/\nexample : squareOrDouble 2 = 4 := by native_decide\nexample : squareOrDouble 3 = 6 := by native_decide\nexample : squareOrDouble 6 = 36 := by native_decide\nexample : squareOrDouble 7 = 14 := by native_decide\n\n/-!\n# Pre/Post Conditions\n-/\n\n/-- Pre-condition: Input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: Result follows square/double rule and maintains properties -/\ndef Post_prop (n : Nat) : Prop :=\n  let result := squareOrDouble n\n  (if n % 2 = 0 then result = n * n else result = 2 * n) \u2227  -- core behavior\n  result \u2265 0 \u2227                                              -- non-negativity\n  (n = 0 \u2192 result = 0) \u2227                                    -- zero case\n  (n \u2265 1 \u2192 result \u2265 n) \u2227                                    -- growth property\n  (n % 2 = 0 \u2192 result % 2 = 0)                             -- even output for even input\n\n/-!\n# Properties\n-/\n\n/-- Property: result is always non-negative -/\ndef nonNegativeOutput_prop (n : Nat) : Prop :=\n  squareOrDouble n \u2265 0\n\n/-- Property: for even numbers, result is perfect square -/\ndef evenCase_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Property: for odd numbers, result is double -/\ndef oddCase_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Property: result is always even when input is even -/\ndef evenResult_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Property: zero maps to zero -/\ndef zero_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-- Property: function is monotonically increasing -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n \u2264 m \u2192 squareOrDouble n \u2264 squareOrDouble m\n\n/-- Property: result is at least as large as input for n \u2265 1 -/\ndef growth_prop (n : Nat) : Prop :=\n  n \u2265 1 \u2192 squareOrDouble n \u2265 n\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: outputs are always non-negative -/\ntheorem nonNegativeOutput_thm (n : Nat) : nonNegativeOutput_prop n := sorry\n\n/-- Theorem: even numbers are squared correctly -/\ntheorem evenCase_thm (n : Nat) : evenCase_prop n := sorry\n\n/-- Theorem: odd numbers are doubled correctly -/\ntheorem oddCase_thm (n : Nat) : oddCase_prop n := sorry\n\n/-- Theorem: zero case works correctly -/\ntheorem zero_thm : zero_prop := sorry\n\n/-- Theorem: result is even for even inputs -/\ntheorem evenResult_thm (n : Nat) : evenResult_prop n := sorry\n\n/-- Theorem: function preserves ordering -/\ntheorem monotonicity_thm (n m : Nat) : monotonicity_prop n m := sorry\n\n/-- Theorem: function grows at least linearly for n \u2265 1 -/\ntheorem growth_thm (n : Nat) : growth_prop n := sorry\n\n/-!\n# Correctness Theorem\n-/\n\n/-- Main correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness_thm (n : Nat) (h : Pre n) :\n  Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := n\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-- Test imperative implementation -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\nexample : squareOrDoubleImp 5 = 10 := by native_decide\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "test_score": 0.9333333333333333
    },
    {
      "iteration": 9,
      "score": 0.9733333333333334,
      "best_score_so_far": 0.9733333333333334,
      "num_metric_calls_so_far": 22,
      "calls_this_iter": 2,
      "accepted_new_candidate": false,
      "new_candidate_score": null,
      "best_lean_program": "/-!\n# Square or Double Function\n\nThis function takes an integer n and:\n- Returns n\u00b2 if n is even \n- Returns 2n if n is odd\n- Works for zero\n- Only accepts integer inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\nExamples:\n- squareOrDouble 4 = 16  \n- squareOrDouble 5 = 10\n- squareOrDouble 0 = 0\n\nRequires: Input must be an integer\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! \n# Basic Tests\n-/\n\n/-- Basic test case: even number -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test case: odd number -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Additional test cases -/\nexample : squareOrDouble 2 = 4 := by native_decide\nexample : squareOrDouble 3 = 6 := by native_decide\nexample : squareOrDouble 6 = 36 := by native_decide\nexample : squareOrDouble 7 = 14 := by native_decide\n\n/-!\n# Pre/Post Conditions\n-/\n\n/-- Pre-condition: Input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: Result follows square/double rule and maintains properties -/\ndef Post_prop (n : Nat) : Prop :=\n  let result := squareOrDouble n\n  (if n % 2 = 0 then result = n * n else result = 2 * n) \u2227  -- core behavior\n  result \u2265 0 \u2227                                              -- non-negativity\n  (n = 0 \u2192 result = 0) \u2227                                    -- zero case\n  (n \u2265 1 \u2192 result \u2265 n) \u2227                                    -- growth property\n  (n % 2 = 0 \u2192 result % 2 = 0)                             -- even output for even input\n\n/-!\n# Properties\n-/\n\n/-- Property: result is always non-negative -/\ndef nonNegativeOutput_prop (n : Nat) : Prop :=\n  squareOrDouble n \u2265 0\n\n/-- Property: for even numbers, result is perfect square -/\ndef evenCase_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Property: for odd numbers, result is double -/\ndef oddCase_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Property: result is always even when input is even -/\ndef evenResult_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Property: zero maps to zero -/\ndef zero_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-- Property: function is monotonically increasing -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n \u2264 m \u2192 squareOrDouble n \u2264 squareOrDouble m\n\n/-- Property: result is at least as large as input for n \u2265 1 -/\ndef growth_prop (n : Nat) : Prop :=\n  n \u2265 1 \u2192 squareOrDouble n \u2265 n\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: outputs are always non-negative -/\ntheorem nonNegativeOutput_thm (n : Nat) : nonNegativeOutput_prop n := sorry\n\n/-- Theorem: even numbers are squared correctly -/\ntheorem evenCase_thm (n : Nat) : evenCase_prop n := sorry\n\n/-- Theorem: odd numbers are doubled correctly -/\ntheorem oddCase_thm (n : Nat) : oddCase_prop n := sorry\n\n/-- Theorem: zero case works correctly -/\ntheorem zero_thm : zero_prop := sorry\n\n/-- Theorem: result is even for even inputs -/\ntheorem evenResult_thm (n : Nat) : evenResult_prop n := sorry\n\n/-- Theorem: function preserves ordering -/\ntheorem monotonicity_thm (n m : Nat) : monotonicity_prop n m := sorry\n\n/-- Theorem: function grows at least linearly for n \u2265 1 -/\ntheorem growth_thm (n : Nat) : growth_prop n := sorry\n\n/-!\n# Correctness Theorem\n-/\n\n/-- Main correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness_thm (n : Nat) (h : Pre n) :\n  Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := n\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-- Test imperative implementation -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\nexample : squareOrDoubleImp 5 = 10 := by native_decide\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "test_score": 0.9333333333333333
    },
    {
      "iteration": 10,
      "score": 0.8933333333333333,
      "best_score_so_far": 0.9733333333333334,
      "num_metric_calls_so_far": 24,
      "calls_this_iter": 2,
      "accepted_new_candidate": false,
      "new_candidate_score": null,
      "best_lean_program": "/-!\n# Square or Double Function\n\nThis function takes an integer n and:\n- Returns n\u00b2 if n is even \n- Returns 2n if n is odd\n- Works for zero\n- Only accepts integer inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\nExamples:\n- squareOrDouble 4 = 16  \n- squareOrDouble 5 = 10\n- squareOrDouble 0 = 0\n\nRequires: Input must be an integer\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! \n# Basic Tests\n-/\n\n/-- Basic test case: even number -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test case: odd number -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Additional test cases -/\nexample : squareOrDouble 2 = 4 := by native_decide\nexample : squareOrDouble 3 = 6 := by native_decide\nexample : squareOrDouble 6 = 36 := by native_decide\nexample : squareOrDouble 7 = 14 := by native_decide\n\n/-!\n# Pre/Post Conditions\n-/\n\n/-- Pre-condition: Input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: Result follows square/double rule and maintains properties -/\ndef Post_prop (n : Nat) : Prop :=\n  let result := squareOrDouble n\n  (if n % 2 = 0 then result = n * n else result = 2 * n) \u2227  -- core behavior\n  result \u2265 0 \u2227                                              -- non-negativity\n  (n = 0 \u2192 result = 0) \u2227                                    -- zero case\n  (n \u2265 1 \u2192 result \u2265 n) \u2227                                    -- growth property\n  (n % 2 = 0 \u2192 result % 2 = 0)                             -- even output for even input\n\n/-!\n# Properties\n-/\n\n/-- Property: result is always non-negative -/\ndef nonNegativeOutput_prop (n : Nat) : Prop :=\n  squareOrDouble n \u2265 0\n\n/-- Property: for even numbers, result is perfect square -/\ndef evenCase_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Property: for odd numbers, result is double -/\ndef oddCase_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Property: result is always even when input is even -/\ndef evenResult_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Property: zero maps to zero -/\ndef zero_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-- Property: function is monotonically increasing -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n \u2264 m \u2192 squareOrDouble n \u2264 squareOrDouble m\n\n/-- Property: result is at least as large as input for n \u2265 1 -/\ndef growth_prop (n : Nat) : Prop :=\n  n \u2265 1 \u2192 squareOrDouble n \u2265 n\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: outputs are always non-negative -/\ntheorem nonNegativeOutput_thm (n : Nat) : nonNegativeOutput_prop n := sorry\n\n/-- Theorem: even numbers are squared correctly -/\ntheorem evenCase_thm (n : Nat) : evenCase_prop n := sorry\n\n/-- Theorem: odd numbers are doubled correctly -/\ntheorem oddCase_thm (n : Nat) : oddCase_prop n := sorry\n\n/-- Theorem: zero case works correctly -/\ntheorem zero_thm : zero_prop := sorry\n\n/-- Theorem: result is even for even inputs -/\ntheorem evenResult_thm (n : Nat) : evenResult_prop n := sorry\n\n/-- Theorem: function preserves ordering -/\ntheorem monotonicity_thm (n m : Nat) : monotonicity_prop n m := sorry\n\n/-- Theorem: function grows at least linearly for n \u2265 1 -/\ntheorem growth_thm (n : Nat) : growth_prop n := sorry\n\n/-!\n# Correctness Theorem\n-/\n\n/-- Main correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness_thm (n : Nat) (h : Pre n) :\n  Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := n\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-- Test imperative implementation -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\nexample : squareOrDoubleImp 5 = 10 := by native_decide\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "test_score": 0.9333333333333333
    },
    {
      "iteration": 11,
      "score": 0.9733333333333334,
      "best_score_so_far": 0.9733333333333334,
      "num_metric_calls_so_far": 26,
      "calls_this_iter": 2,
      "accepted_new_candidate": false,
      "new_candidate_score": null,
      "best_lean_program": "/-!\n# Square or Double Function\n\nThis function takes an integer n and:\n- Returns n\u00b2 if n is even \n- Returns 2n if n is odd\n- Works for zero\n- Only accepts integer inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\nExamples:\n- squareOrDouble 4 = 16  \n- squareOrDouble 5 = 10\n- squareOrDouble 0 = 0\n\nRequires: Input must be an integer\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! \n# Basic Tests\n-/\n\n/-- Basic test case: even number -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test case: odd number -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Additional test cases -/\nexample : squareOrDouble 2 = 4 := by native_decide\nexample : squareOrDouble 3 = 6 := by native_decide\nexample : squareOrDouble 6 = 36 := by native_decide\nexample : squareOrDouble 7 = 14 := by native_decide\n\n/-!\n# Pre/Post Conditions\n-/\n\n/-- Pre-condition: Input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: Result follows square/double rule and maintains properties -/\ndef Post_prop (n : Nat) : Prop :=\n  let result := squareOrDouble n\n  (if n % 2 = 0 then result = n * n else result = 2 * n) \u2227  -- core behavior\n  result \u2265 0 \u2227                                              -- non-negativity\n  (n = 0 \u2192 result = 0) \u2227                                    -- zero case\n  (n \u2265 1 \u2192 result \u2265 n) \u2227                                    -- growth property\n  (n % 2 = 0 \u2192 result % 2 = 0)                             -- even output for even input\n\n/-!\n# Properties\n-/\n\n/-- Property: result is always non-negative -/\ndef nonNegativeOutput_prop (n : Nat) : Prop :=\n  squareOrDouble n \u2265 0\n\n/-- Property: for even numbers, result is perfect square -/\ndef evenCase_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Property: for odd numbers, result is double -/\ndef oddCase_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Property: result is always even when input is even -/\ndef evenResult_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Property: zero maps to zero -/\ndef zero_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-- Property: function is monotonically increasing -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n \u2264 m \u2192 squareOrDouble n \u2264 squareOrDouble m\n\n/-- Property: result is at least as large as input for n \u2265 1 -/\ndef growth_prop (n : Nat) : Prop :=\n  n \u2265 1 \u2192 squareOrDouble n \u2265 n\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: outputs are always non-negative -/\ntheorem nonNegativeOutput_thm (n : Nat) : nonNegativeOutput_prop n := sorry\n\n/-- Theorem: even numbers are squared correctly -/\ntheorem evenCase_thm (n : Nat) : evenCase_prop n := sorry\n\n/-- Theorem: odd numbers are doubled correctly -/\ntheorem oddCase_thm (n : Nat) : oddCase_prop n := sorry\n\n/-- Theorem: zero case works correctly -/\ntheorem zero_thm : zero_prop := sorry\n\n/-- Theorem: result is even for even inputs -/\ntheorem evenResult_thm (n : Nat) : evenResult_prop n := sorry\n\n/-- Theorem: function preserves ordering -/\ntheorem monotonicity_thm (n m : Nat) : monotonicity_prop n m := sorry\n\n/-- Theorem: function grows at least linearly for n \u2265 1 -/\ntheorem growth_thm (n : Nat) : growth_prop n := sorry\n\n/-!\n# Correctness Theorem\n-/\n\n/-- Main correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness_thm (n : Nat) (h : Pre n) :\n  Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := n\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-- Test imperative implementation -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\nexample : squareOrDoubleImp 5 = 10 := by native_decide\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "test_score": 0.9333333333333333
    },
    {
      "iteration": 12,
      "score": 0.92,
      "best_score_so_far": 0.9733333333333334,
      "num_metric_calls_so_far": 28,
      "calls_this_iter": 2,
      "accepted_new_candidate": false,
      "new_candidate_score": null,
      "best_lean_program": "/-!\n# Square or Double Function\n\nThis function takes an integer n and:\n- Returns n\u00b2 if n is even \n- Returns 2n if n is odd\n- Works for zero\n- Only accepts integer inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\nExamples:\n- squareOrDouble 4 = 16  \n- squareOrDouble 5 = 10\n- squareOrDouble 0 = 0\n\nRequires: Input must be an integer\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! \n# Basic Tests\n-/\n\n/-- Basic test case: even number -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test case: odd number -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Additional test cases -/\nexample : squareOrDouble 2 = 4 := by native_decide\nexample : squareOrDouble 3 = 6 := by native_decide\nexample : squareOrDouble 6 = 36 := by native_decide\nexample : squareOrDouble 7 = 14 := by native_decide\n\n/-!\n# Pre/Post Conditions\n-/\n\n/-- Pre-condition: Input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: Result follows square/double rule and maintains properties -/\ndef Post_prop (n : Nat) : Prop :=\n  let result := squareOrDouble n\n  (if n % 2 = 0 then result = n * n else result = 2 * n) \u2227  -- core behavior\n  result \u2265 0 \u2227                                              -- non-negativity\n  (n = 0 \u2192 result = 0) \u2227                                    -- zero case\n  (n \u2265 1 \u2192 result \u2265 n) \u2227                                    -- growth property\n  (n % 2 = 0 \u2192 result % 2 = 0)                             -- even output for even input\n\n/-!\n# Properties\n-/\n\n/-- Property: result is always non-negative -/\ndef nonNegativeOutput_prop (n : Nat) : Prop :=\n  squareOrDouble n \u2265 0\n\n/-- Property: for even numbers, result is perfect square -/\ndef evenCase_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Property: for odd numbers, result is double -/\ndef oddCase_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Property: result is always even when input is even -/\ndef evenResult_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Property: zero maps to zero -/\ndef zero_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-- Property: function is monotonically increasing -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n \u2264 m \u2192 squareOrDouble n \u2264 squareOrDouble m\n\n/-- Property: result is at least as large as input for n \u2265 1 -/\ndef growth_prop (n : Nat) : Prop :=\n  n \u2265 1 \u2192 squareOrDouble n \u2265 n\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: outputs are always non-negative -/\ntheorem nonNegativeOutput_thm (n : Nat) : nonNegativeOutput_prop n := sorry\n\n/-- Theorem: even numbers are squared correctly -/\ntheorem evenCase_thm (n : Nat) : evenCase_prop n := sorry\n\n/-- Theorem: odd numbers are doubled correctly -/\ntheorem oddCase_thm (n : Nat) : oddCase_prop n := sorry\n\n/-- Theorem: zero case works correctly -/\ntheorem zero_thm : zero_prop := sorry\n\n/-- Theorem: result is even for even inputs -/\ntheorem evenResult_thm (n : Nat) : evenResult_prop n := sorry\n\n/-- Theorem: function preserves ordering -/\ntheorem monotonicity_thm (n m : Nat) : monotonicity_prop n m := sorry\n\n/-- Theorem: function grows at least linearly for n \u2265 1 -/\ntheorem growth_thm (n : Nat) : growth_prop n := sorry\n\n/-!\n# Correctness Theorem\n-/\n\n/-- Main correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness_thm (n : Nat) (h : Pre n) :\n  Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := n\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-- Test imperative implementation -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\nexample : squareOrDoubleImp 5 = 10 := by native_decide\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "test_score": 0.9333333333333333
    },
    {
      "iteration": 13,
      "score": 0.8666666666666667,
      "best_score_so_far": 0.9733333333333334,
      "num_metric_calls_so_far": 31,
      "calls_this_iter": 3,
      "accepted_new_candidate": true,
      "new_candidate_score": 0.8666666666666667,
      "best_lean_program": "/-!\n# Square or Double Function\n\nThis function takes an integer n and:\n- Returns n\u00b2 if n is even \n- Returns 2n if n is odd\n- Works for zero\n- Only accepts integer inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\nExamples:\n- squareOrDouble 4 = 16  \n- squareOrDouble 5 = 10\n- squareOrDouble 0 = 0\n\nRequires: Input must be an integer\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! \n# Basic Tests\n-/\n\n/-- Basic test case: even number -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test case: odd number -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Additional test cases -/\nexample : squareOrDouble 2 = 4 := by native_decide\nexample : squareOrDouble 3 = 6 := by native_decide\nexample : squareOrDouble 6 = 36 := by native_decide\nexample : squareOrDouble 7 = 14 := by native_decide\n\n/-!\n# Pre/Post Conditions\n-/\n\n/-- Pre-condition: Input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: Result follows square/double rule and maintains properties -/\ndef Post_prop (n : Nat) : Prop :=\n  let result := squareOrDouble n\n  (if n % 2 = 0 then result = n * n else result = 2 * n) \u2227  -- core behavior\n  result \u2265 0 \u2227                                              -- non-negativity\n  (n = 0 \u2192 result = 0) \u2227                                    -- zero case\n  (n \u2265 1 \u2192 result \u2265 n) \u2227                                    -- growth property\n  (n % 2 = 0 \u2192 result % 2 = 0)                             -- even output for even input\n\n/-!\n# Properties\n-/\n\n/-- Property: result is always non-negative -/\ndef nonNegativeOutput_prop (n : Nat) : Prop :=\n  squareOrDouble n \u2265 0\n\n/-- Property: for even numbers, result is perfect square -/\ndef evenCase_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Property: for odd numbers, result is double -/\ndef oddCase_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Property: result is always even when input is even -/\ndef evenResult_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Property: zero maps to zero -/\ndef zero_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-- Property: function is monotonically increasing -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n \u2264 m \u2192 squareOrDouble n \u2264 squareOrDouble m\n\n/-- Property: result is at least as large as input for n \u2265 1 -/\ndef growth_prop (n : Nat) : Prop :=\n  n \u2265 1 \u2192 squareOrDouble n \u2265 n\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: outputs are always non-negative -/\ntheorem nonNegativeOutput_thm (n : Nat) : nonNegativeOutput_prop n := sorry\n\n/-- Theorem: even numbers are squared correctly -/\ntheorem evenCase_thm (n : Nat) : evenCase_prop n := sorry\n\n/-- Theorem: odd numbers are doubled correctly -/\ntheorem oddCase_thm (n : Nat) : oddCase_prop n := sorry\n\n/-- Theorem: zero case works correctly -/\ntheorem zero_thm : zero_prop := sorry\n\n/-- Theorem: result is even for even inputs -/\ntheorem evenResult_thm (n : Nat) : evenResult_prop n := sorry\n\n/-- Theorem: function preserves ordering -/\ntheorem monotonicity_thm (n m : Nat) : monotonicity_prop n m := sorry\n\n/-- Theorem: function grows at least linearly for n \u2265 1 -/\ntheorem growth_thm (n : Nat) : growth_prop n := sorry\n\n/-!\n# Correctness Theorem\n-/\n\n/-- Main correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness_thm (n : Nat) (h : Pre n) :\n  Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := n\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-- Test imperative implementation -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\nexample : squareOrDoubleImp 5 = 10 := by native_decide\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "test_score": 0.9333333333333333
    },
    {
      "iteration": 14,
      "score": 0.9333333333333333,
      "best_score_so_far": 0.9733333333333334,
      "num_metric_calls_so_far": 33,
      "calls_this_iter": 2,
      "accepted_new_candidate": false,
      "new_candidate_score": null,
      "best_lean_program": "/-!\n# Square or Double Function\n\nThis function takes an integer n and:\n- Returns n\u00b2 if n is even \n- Returns 2n if n is odd\n- Works for zero\n- Only accepts integer inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\nExamples:\n- squareOrDouble 4 = 16  \n- squareOrDouble 5 = 10\n- squareOrDouble 0 = 0\n\nRequires: Input must be an integer\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! \n# Basic Tests\n-/\n\n/-- Basic test case: even number -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test case: odd number -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Additional test cases -/\nexample : squareOrDouble 2 = 4 := by native_decide\nexample : squareOrDouble 3 = 6 := by native_decide\nexample : squareOrDouble 6 = 36 := by native_decide\nexample : squareOrDouble 7 = 14 := by native_decide\n\n/-!\n# Pre/Post Conditions\n-/\n\n/-- Pre-condition: Input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: Result follows square/double rule and maintains properties -/\ndef Post_prop (n : Nat) : Prop :=\n  let result := squareOrDouble n\n  (if n % 2 = 0 then result = n * n else result = 2 * n) \u2227  -- core behavior\n  result \u2265 0 \u2227                                              -- non-negativity\n  (n = 0 \u2192 result = 0) \u2227                                    -- zero case\n  (n \u2265 1 \u2192 result \u2265 n) \u2227                                    -- growth property\n  (n % 2 = 0 \u2192 result % 2 = 0)                             -- even output for even input\n\n/-!\n# Properties\n-/\n\n/-- Property: result is always non-negative -/\ndef nonNegativeOutput_prop (n : Nat) : Prop :=\n  squareOrDouble n \u2265 0\n\n/-- Property: for even numbers, result is perfect square -/\ndef evenCase_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Property: for odd numbers, result is double -/\ndef oddCase_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Property: result is always even when input is even -/\ndef evenResult_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Property: zero maps to zero -/\ndef zero_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-- Property: function is monotonically increasing -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n \u2264 m \u2192 squareOrDouble n \u2264 squareOrDouble m\n\n/-- Property: result is at least as large as input for n \u2265 1 -/\ndef growth_prop (n : Nat) : Prop :=\n  n \u2265 1 \u2192 squareOrDouble n \u2265 n\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: outputs are always non-negative -/\ntheorem nonNegativeOutput_thm (n : Nat) : nonNegativeOutput_prop n := sorry\n\n/-- Theorem: even numbers are squared correctly -/\ntheorem evenCase_thm (n : Nat) : evenCase_prop n := sorry\n\n/-- Theorem: odd numbers are doubled correctly -/\ntheorem oddCase_thm (n : Nat) : oddCase_prop n := sorry\n\n/-- Theorem: zero case works correctly -/\ntheorem zero_thm : zero_prop := sorry\n\n/-- Theorem: result is even for even inputs -/\ntheorem evenResult_thm (n : Nat) : evenResult_prop n := sorry\n\n/-- Theorem: function preserves ordering -/\ntheorem monotonicity_thm (n m : Nat) : monotonicity_prop n m := sorry\n\n/-- Theorem: function grows at least linearly for n \u2265 1 -/\ntheorem growth_thm (n : Nat) : growth_prop n := sorry\n\n/-!\n# Correctness Theorem\n-/\n\n/-- Main correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness_thm (n : Nat) (h : Pre n) :\n  Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := n\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-- Test imperative implementation -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\nexample : squareOrDoubleImp 5 = 10 := by native_decide\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "test_score": 0.9333333333333333
    },
    {
      "iteration": 15,
      "score": 0.92,
      "best_score_so_far": 0.9733333333333334,
      "num_metric_calls_so_far": 35,
      "calls_this_iter": 2,
      "accepted_new_candidate": false,
      "new_candidate_score": null,
      "best_lean_program": "/-!\n# Square or Double Function\n\nThis function takes an integer n and:\n- Returns n\u00b2 if n is even \n- Returns 2n if n is odd\n- Works for zero\n- Only accepts integer inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\nExamples:\n- squareOrDouble 4 = 16  \n- squareOrDouble 5 = 10\n- squareOrDouble 0 = 0\n\nRequires: Input must be an integer\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! \n# Basic Tests\n-/\n\n/-- Basic test case: even number -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test case: odd number -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Additional test cases -/\nexample : squareOrDouble 2 = 4 := by native_decide\nexample : squareOrDouble 3 = 6 := by native_decide\nexample : squareOrDouble 6 = 36 := by native_decide\nexample : squareOrDouble 7 = 14 := by native_decide\n\n/-!\n# Pre/Post Conditions\n-/\n\n/-- Pre-condition: Input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: Result follows square/double rule and maintains properties -/\ndef Post_prop (n : Nat) : Prop :=\n  let result := squareOrDouble n\n  (if n % 2 = 0 then result = n * n else result = 2 * n) \u2227  -- core behavior\n  result \u2265 0 \u2227                                              -- non-negativity\n  (n = 0 \u2192 result = 0) \u2227                                    -- zero case\n  (n \u2265 1 \u2192 result \u2265 n) \u2227                                    -- growth property\n  (n % 2 = 0 \u2192 result % 2 = 0)                             -- even output for even input\n\n/-!\n# Properties\n-/\n\n/-- Property: result is always non-negative -/\ndef nonNegativeOutput_prop (n : Nat) : Prop :=\n  squareOrDouble n \u2265 0\n\n/-- Property: for even numbers, result is perfect square -/\ndef evenCase_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Property: for odd numbers, result is double -/\ndef oddCase_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Property: result is always even when input is even -/\ndef evenResult_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Property: zero maps to zero -/\ndef zero_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-- Property: function is monotonically increasing -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n \u2264 m \u2192 squareOrDouble n \u2264 squareOrDouble m\n\n/-- Property: result is at least as large as input for n \u2265 1 -/\ndef growth_prop (n : Nat) : Prop :=\n  n \u2265 1 \u2192 squareOrDouble n \u2265 n\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: outputs are always non-negative -/\ntheorem nonNegativeOutput_thm (n : Nat) : nonNegativeOutput_prop n := sorry\n\n/-- Theorem: even numbers are squared correctly -/\ntheorem evenCase_thm (n : Nat) : evenCase_prop n := sorry\n\n/-- Theorem: odd numbers are doubled correctly -/\ntheorem oddCase_thm (n : Nat) : oddCase_prop n := sorry\n\n/-- Theorem: zero case works correctly -/\ntheorem zero_thm : zero_prop := sorry\n\n/-- Theorem: result is even for even inputs -/\ntheorem evenResult_thm (n : Nat) : evenResult_prop n := sorry\n\n/-- Theorem: function preserves ordering -/\ntheorem monotonicity_thm (n m : Nat) : monotonicity_prop n m := sorry\n\n/-- Theorem: function grows at least linearly for n \u2265 1 -/\ntheorem growth_thm (n : Nat) : growth_prop n := sorry\n\n/-!\n# Correctness Theorem\n-/\n\n/-- Main correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness_thm (n : Nat) (h : Pre n) :\n  Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := n\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-- Test imperative implementation -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\nexample : squareOrDoubleImp 5 = 10 := by native_decide\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "test_score": 0.9333333333333333
    },
    {
      "iteration": 16,
      "score": 0.92,
      "best_score_so_far": 0.9733333333333334,
      "num_metric_calls_so_far": 37,
      "calls_this_iter": 2,
      "accepted_new_candidate": false,
      "new_candidate_score": null,
      "best_lean_program": "/-!\n# Square or Double Function\n\nThis function takes an integer n and:\n- Returns n\u00b2 if n is even \n- Returns 2n if n is odd\n- Works for zero\n- Only accepts integer inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\nExamples:\n- squareOrDouble 4 = 16  \n- squareOrDouble 5 = 10\n- squareOrDouble 0 = 0\n\nRequires: Input must be an integer\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! \n# Basic Tests\n-/\n\n/-- Basic test case: even number -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test case: odd number -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Additional test cases -/\nexample : squareOrDouble 2 = 4 := by native_decide\nexample : squareOrDouble 3 = 6 := by native_decide\nexample : squareOrDouble 6 = 36 := by native_decide\nexample : squareOrDouble 7 = 14 := by native_decide\n\n/-!\n# Pre/Post Conditions\n-/\n\n/-- Pre-condition: Input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: Result follows square/double rule and maintains properties -/\ndef Post_prop (n : Nat) : Prop :=\n  let result := squareOrDouble n\n  (if n % 2 = 0 then result = n * n else result = 2 * n) \u2227  -- core behavior\n  result \u2265 0 \u2227                                              -- non-negativity\n  (n = 0 \u2192 result = 0) \u2227                                    -- zero case\n  (n \u2265 1 \u2192 result \u2265 n) \u2227                                    -- growth property\n  (n % 2 = 0 \u2192 result % 2 = 0)                             -- even output for even input\n\n/-!\n# Properties\n-/\n\n/-- Property: result is always non-negative -/\ndef nonNegativeOutput_prop (n : Nat) : Prop :=\n  squareOrDouble n \u2265 0\n\n/-- Property: for even numbers, result is perfect square -/\ndef evenCase_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Property: for odd numbers, result is double -/\ndef oddCase_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Property: result is always even when input is even -/\ndef evenResult_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Property: zero maps to zero -/\ndef zero_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-- Property: function is monotonically increasing -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n \u2264 m \u2192 squareOrDouble n \u2264 squareOrDouble m\n\n/-- Property: result is at least as large as input for n \u2265 1 -/\ndef growth_prop (n : Nat) : Prop :=\n  n \u2265 1 \u2192 squareOrDouble n \u2265 n\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: outputs are always non-negative -/\ntheorem nonNegativeOutput_thm (n : Nat) : nonNegativeOutput_prop n := sorry\n\n/-- Theorem: even numbers are squared correctly -/\ntheorem evenCase_thm (n : Nat) : evenCase_prop n := sorry\n\n/-- Theorem: odd numbers are doubled correctly -/\ntheorem oddCase_thm (n : Nat) : oddCase_prop n := sorry\n\n/-- Theorem: zero case works correctly -/\ntheorem zero_thm : zero_prop := sorry\n\n/-- Theorem: result is even for even inputs -/\ntheorem evenResult_thm (n : Nat) : evenResult_prop n := sorry\n\n/-- Theorem: function preserves ordering -/\ntheorem monotonicity_thm (n m : Nat) : monotonicity_prop n m := sorry\n\n/-- Theorem: function grows at least linearly for n \u2265 1 -/\ntheorem growth_thm (n : Nat) : growth_prop n := sorry\n\n/-!\n# Correctness Theorem\n-/\n\n/-- Main correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness_thm (n : Nat) (h : Pre n) :\n  Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := n\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-- Test imperative implementation -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\nexample : squareOrDoubleImp 5 = 10 := by native_decide\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "test_score": 0.9333333333333333
    },
    {
      "iteration": 17,
      "score": 0.9733333333333334,
      "best_score_so_far": 0.9733333333333334,
      "num_metric_calls_so_far": 39,
      "calls_this_iter": 2,
      "accepted_new_candidate": false,
      "new_candidate_score": null,
      "best_lean_program": "/-!\n# Square or Double Function\n\nThis function takes an integer n and:\n- Returns n\u00b2 if n is even \n- Returns 2n if n is odd\n- Works for zero\n- Only accepts integer inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\nExamples:\n- squareOrDouble 4 = 16  \n- squareOrDouble 5 = 10\n- squareOrDouble 0 = 0\n\nRequires: Input must be an integer\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! \n# Basic Tests\n-/\n\n/-- Basic test case: even number -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test case: odd number -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Additional test cases -/\nexample : squareOrDouble 2 = 4 := by native_decide\nexample : squareOrDouble 3 = 6 := by native_decide\nexample : squareOrDouble 6 = 36 := by native_decide\nexample : squareOrDouble 7 = 14 := by native_decide\n\n/-!\n# Pre/Post Conditions\n-/\n\n/-- Pre-condition: Input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: Result follows square/double rule and maintains properties -/\ndef Post_prop (n : Nat) : Prop :=\n  let result := squareOrDouble n\n  (if n % 2 = 0 then result = n * n else result = 2 * n) \u2227  -- core behavior\n  result \u2265 0 \u2227                                              -- non-negativity\n  (n = 0 \u2192 result = 0) \u2227                                    -- zero case\n  (n \u2265 1 \u2192 result \u2265 n) \u2227                                    -- growth property\n  (n % 2 = 0 \u2192 result % 2 = 0)                             -- even output for even input\n\n/-!\n# Properties\n-/\n\n/-- Property: result is always non-negative -/\ndef nonNegativeOutput_prop (n : Nat) : Prop :=\n  squareOrDouble n \u2265 0\n\n/-- Property: for even numbers, result is perfect square -/\ndef evenCase_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Property: for odd numbers, result is double -/\ndef oddCase_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Property: result is always even when input is even -/\ndef evenResult_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Property: zero maps to zero -/\ndef zero_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-- Property: function is monotonically increasing -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n \u2264 m \u2192 squareOrDouble n \u2264 squareOrDouble m\n\n/-- Property: result is at least as large as input for n \u2265 1 -/\ndef growth_prop (n : Nat) : Prop :=\n  n \u2265 1 \u2192 squareOrDouble n \u2265 n\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: outputs are always non-negative -/\ntheorem nonNegativeOutput_thm (n : Nat) : nonNegativeOutput_prop n := sorry\n\n/-- Theorem: even numbers are squared correctly -/\ntheorem evenCase_thm (n : Nat) : evenCase_prop n := sorry\n\n/-- Theorem: odd numbers are doubled correctly -/\ntheorem oddCase_thm (n : Nat) : oddCase_prop n := sorry\n\n/-- Theorem: zero case works correctly -/\ntheorem zero_thm : zero_prop := sorry\n\n/-- Theorem: result is even for even inputs -/\ntheorem evenResult_thm (n : Nat) : evenResult_prop n := sorry\n\n/-- Theorem: function preserves ordering -/\ntheorem monotonicity_thm (n m : Nat) : monotonicity_prop n m := sorry\n\n/-- Theorem: function grows at least linearly for n \u2265 1 -/\ntheorem growth_thm (n : Nat) : growth_prop n := sorry\n\n/-!\n# Correctness Theorem\n-/\n\n/-- Main correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness_thm (n : Nat) (h : Pre n) :\n  Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := n\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-- Test imperative implementation -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\nexample : squareOrDoubleImp 5 = 10 := by native_decide\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "test_score": 0.9333333333333333
    },
    {
      "iteration": 18,
      "score": 0.9733333333333334,
      "best_score_so_far": 0.9733333333333334,
      "num_metric_calls_so_far": 41,
      "calls_this_iter": 2,
      "accepted_new_candidate": false,
      "new_candidate_score": null,
      "best_lean_program": "/-!\n# Square or Double Function\n\nThis function takes an integer n and:\n- Returns n\u00b2 if n is even \n- Returns 2n if n is odd\n- Works for zero\n- Only accepts integer inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\nExamples:\n- squareOrDouble 4 = 16  \n- squareOrDouble 5 = 10\n- squareOrDouble 0 = 0\n\nRequires: Input must be an integer\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! \n# Basic Tests\n-/\n\n/-- Basic test case: even number -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test case: odd number -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Additional test cases -/\nexample : squareOrDouble 2 = 4 := by native_decide\nexample : squareOrDouble 3 = 6 := by native_decide\nexample : squareOrDouble 6 = 36 := by native_decide\nexample : squareOrDouble 7 = 14 := by native_decide\n\n/-!\n# Pre/Post Conditions\n-/\n\n/-- Pre-condition: Input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: Result follows square/double rule and maintains properties -/\ndef Post_prop (n : Nat) : Prop :=\n  let result := squareOrDouble n\n  (if n % 2 = 0 then result = n * n else result = 2 * n) \u2227  -- core behavior\n  result \u2265 0 \u2227                                              -- non-negativity\n  (n = 0 \u2192 result = 0) \u2227                                    -- zero case\n  (n \u2265 1 \u2192 result \u2265 n) \u2227                                    -- growth property\n  (n % 2 = 0 \u2192 result % 2 = 0)                             -- even output for even input\n\n/-!\n# Properties\n-/\n\n/-- Property: result is always non-negative -/\ndef nonNegativeOutput_prop (n : Nat) : Prop :=\n  squareOrDouble n \u2265 0\n\n/-- Property: for even numbers, result is perfect square -/\ndef evenCase_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Property: for odd numbers, result is double -/\ndef oddCase_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Property: result is always even when input is even -/\ndef evenResult_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Property: zero maps to zero -/\ndef zero_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-- Property: function is monotonically increasing -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n \u2264 m \u2192 squareOrDouble n \u2264 squareOrDouble m\n\n/-- Property: result is at least as large as input for n \u2265 1 -/\ndef growth_prop (n : Nat) : Prop :=\n  n \u2265 1 \u2192 squareOrDouble n \u2265 n\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: outputs are always non-negative -/\ntheorem nonNegativeOutput_thm (n : Nat) : nonNegativeOutput_prop n := sorry\n\n/-- Theorem: even numbers are squared correctly -/\ntheorem evenCase_thm (n : Nat) : evenCase_prop n := sorry\n\n/-- Theorem: odd numbers are doubled correctly -/\ntheorem oddCase_thm (n : Nat) : oddCase_prop n := sorry\n\n/-- Theorem: zero case works correctly -/\ntheorem zero_thm : zero_prop := sorry\n\n/-- Theorem: result is even for even inputs -/\ntheorem evenResult_thm (n : Nat) : evenResult_prop n := sorry\n\n/-- Theorem: function preserves ordering -/\ntheorem monotonicity_thm (n m : Nat) : monotonicity_prop n m := sorry\n\n/-- Theorem: function grows at least linearly for n \u2265 1 -/\ntheorem growth_thm (n : Nat) : growth_prop n := sorry\n\n/-!\n# Correctness Theorem\n-/\n\n/-- Main correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness_thm (n : Nat) (h : Pre n) :\n  Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := n\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-- Test imperative implementation -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\nexample : squareOrDoubleImp 5 = 10 := by native_decide\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "test_score": 0.9333333333333333
    },
    {
      "iteration": 19,
      "score": 0.9333333333333333,
      "best_score_so_far": 0.9733333333333334,
      "num_metric_calls_so_far": 43,
      "calls_this_iter": 2,
      "accepted_new_candidate": false,
      "new_candidate_score": null,
      "best_lean_program": "/-!\n# Square or Double Function\n\nThis function takes an integer n and:\n- Returns n\u00b2 if n is even \n- Returns 2n if n is odd\n- Works for zero\n- Only accepts integer inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\nExamples:\n- squareOrDouble 4 = 16  \n- squareOrDouble 5 = 10\n- squareOrDouble 0 = 0\n\nRequires: Input must be an integer\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! \n# Basic Tests\n-/\n\n/-- Basic test case: even number -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test case: odd number -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Additional test cases -/\nexample : squareOrDouble 2 = 4 := by native_decide\nexample : squareOrDouble 3 = 6 := by native_decide\nexample : squareOrDouble 6 = 36 := by native_decide\nexample : squareOrDouble 7 = 14 := by native_decide\n\n/-!\n# Pre/Post Conditions\n-/\n\n/-- Pre-condition: Input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: Result follows square/double rule and maintains properties -/\ndef Post_prop (n : Nat) : Prop :=\n  let result := squareOrDouble n\n  (if n % 2 = 0 then result = n * n else result = 2 * n) \u2227  -- core behavior\n  result \u2265 0 \u2227                                              -- non-negativity\n  (n = 0 \u2192 result = 0) \u2227                                    -- zero case\n  (n \u2265 1 \u2192 result \u2265 n) \u2227                                    -- growth property\n  (n % 2 = 0 \u2192 result % 2 = 0)                             -- even output for even input\n\n/-!\n# Properties\n-/\n\n/-- Property: result is always non-negative -/\ndef nonNegativeOutput_prop (n : Nat) : Prop :=\n  squareOrDouble n \u2265 0\n\n/-- Property: for even numbers, result is perfect square -/\ndef evenCase_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Property: for odd numbers, result is double -/\ndef oddCase_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Property: result is always even when input is even -/\ndef evenResult_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Property: zero maps to zero -/\ndef zero_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-- Property: function is monotonically increasing -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n \u2264 m \u2192 squareOrDouble n \u2264 squareOrDouble m\n\n/-- Property: result is at least as large as input for n \u2265 1 -/\ndef growth_prop (n : Nat) : Prop :=\n  n \u2265 1 \u2192 squareOrDouble n \u2265 n\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: outputs are always non-negative -/\ntheorem nonNegativeOutput_thm (n : Nat) : nonNegativeOutput_prop n := sorry\n\n/-- Theorem: even numbers are squared correctly -/\ntheorem evenCase_thm (n : Nat) : evenCase_prop n := sorry\n\n/-- Theorem: odd numbers are doubled correctly -/\ntheorem oddCase_thm (n : Nat) : oddCase_prop n := sorry\n\n/-- Theorem: zero case works correctly -/\ntheorem zero_thm : zero_prop := sorry\n\n/-- Theorem: result is even for even inputs -/\ntheorem evenResult_thm (n : Nat) : evenResult_prop n := sorry\n\n/-- Theorem: function preserves ordering -/\ntheorem monotonicity_thm (n m : Nat) : monotonicity_prop n m := sorry\n\n/-- Theorem: function grows at least linearly for n \u2265 1 -/\ntheorem growth_thm (n : Nat) : growth_prop n := sorry\n\n/-!\n# Correctness Theorem\n-/\n\n/-- Main correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness_thm (n : Nat) (h : Pre n) :\n  Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := n\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-- Test imperative implementation -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\nexample : squareOrDoubleImp 5 = 10 := by native_decide\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "test_score": 0.9333333333333333
    },
    {
      "iteration": 20,
      "score": 0.8933333333333333,
      "best_score_so_far": 0.9733333333333334,
      "num_metric_calls_so_far": 45,
      "calls_this_iter": 2,
      "accepted_new_candidate": false,
      "new_candidate_score": null,
      "best_lean_program": "/-!\n# Square or Double Function\n\nThis function takes an integer n and:\n- Returns n\u00b2 if n is even \n- Returns 2n if n is odd\n- Works for zero\n- Only accepts integer inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\nExamples:\n- squareOrDouble 4 = 16  \n- squareOrDouble 5 = 10\n- squareOrDouble 0 = 0\n\nRequires: Input must be an integer\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! \n# Basic Tests\n-/\n\n/-- Basic test case: even number -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test case: odd number -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Additional test cases -/\nexample : squareOrDouble 2 = 4 := by native_decide\nexample : squareOrDouble 3 = 6 := by native_decide\nexample : squareOrDouble 6 = 36 := by native_decide\nexample : squareOrDouble 7 = 14 := by native_decide\n\n/-!\n# Pre/Post Conditions\n-/\n\n/-- Pre-condition: Input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: Result follows square/double rule and maintains properties -/\ndef Post_prop (n : Nat) : Prop :=\n  let result := squareOrDouble n\n  (if n % 2 = 0 then result = n * n else result = 2 * n) \u2227  -- core behavior\n  result \u2265 0 \u2227                                              -- non-negativity\n  (n = 0 \u2192 result = 0) \u2227                                    -- zero case\n  (n \u2265 1 \u2192 result \u2265 n) \u2227                                    -- growth property\n  (n % 2 = 0 \u2192 result % 2 = 0)                             -- even output for even input\n\n/-!\n# Properties\n-/\n\n/-- Property: result is always non-negative -/\ndef nonNegativeOutput_prop (n : Nat) : Prop :=\n  squareOrDouble n \u2265 0\n\n/-- Property: for even numbers, result is perfect square -/\ndef evenCase_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Property: for odd numbers, result is double -/\ndef oddCase_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Property: result is always even when input is even -/\ndef evenResult_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Property: zero maps to zero -/\ndef zero_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-- Property: function is monotonically increasing -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n \u2264 m \u2192 squareOrDouble n \u2264 squareOrDouble m\n\n/-- Property: result is at least as large as input for n \u2265 1 -/\ndef growth_prop (n : Nat) : Prop :=\n  n \u2265 1 \u2192 squareOrDouble n \u2265 n\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: outputs are always non-negative -/\ntheorem nonNegativeOutput_thm (n : Nat) : nonNegativeOutput_prop n := sorry\n\n/-- Theorem: even numbers are squared correctly -/\ntheorem evenCase_thm (n : Nat) : evenCase_prop n := sorry\n\n/-- Theorem: odd numbers are doubled correctly -/\ntheorem oddCase_thm (n : Nat) : oddCase_prop n := sorry\n\n/-- Theorem: zero case works correctly -/\ntheorem zero_thm : zero_prop := sorry\n\n/-- Theorem: result is even for even inputs -/\ntheorem evenResult_thm (n : Nat) : evenResult_prop n := sorry\n\n/-- Theorem: function preserves ordering -/\ntheorem monotonicity_thm (n m : Nat) : monotonicity_prop n m := sorry\n\n/-- Theorem: function grows at least linearly for n \u2265 1 -/\ntheorem growth_thm (n : Nat) : growth_prop n := sorry\n\n/-!\n# Correctness Theorem\n-/\n\n/-- Main correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness_thm (n : Nat) (h : Pre n) :\n  Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := n\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-- Test imperative implementation -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\nexample : squareOrDoubleImp 5 = 10 := by native_decide\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "test_score": 0.9333333333333333
    },
    {
      "iteration": 21,
      "score": 0.92,
      "best_score_so_far": 0.9733333333333334,
      "num_metric_calls_so_far": 47,
      "calls_this_iter": 2,
      "accepted_new_candidate": false,
      "new_candidate_score": null,
      "best_lean_program": "/-!\n# Square or Double Function\n\nThis function takes an integer n and:\n- Returns n\u00b2 if n is even \n- Returns 2n if n is odd\n- Works for zero\n- Only accepts integer inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\nExamples:\n- squareOrDouble 4 = 16  \n- squareOrDouble 5 = 10\n- squareOrDouble 0 = 0\n\nRequires: Input must be an integer\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! \n# Basic Tests\n-/\n\n/-- Basic test case: even number -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test case: odd number -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Additional test cases -/\nexample : squareOrDouble 2 = 4 := by native_decide\nexample : squareOrDouble 3 = 6 := by native_decide\nexample : squareOrDouble 6 = 36 := by native_decide\nexample : squareOrDouble 7 = 14 := by native_decide\n\n/-!\n# Pre/Post Conditions\n-/\n\n/-- Pre-condition: Input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: Result follows square/double rule and maintains properties -/\ndef Post_prop (n : Nat) : Prop :=\n  let result := squareOrDouble n\n  (if n % 2 = 0 then result = n * n else result = 2 * n) \u2227  -- core behavior\n  result \u2265 0 \u2227                                              -- non-negativity\n  (n = 0 \u2192 result = 0) \u2227                                    -- zero case\n  (n \u2265 1 \u2192 result \u2265 n) \u2227                                    -- growth property\n  (n % 2 = 0 \u2192 result % 2 = 0)                             -- even output for even input\n\n/-!\n# Properties\n-/\n\n/-- Property: result is always non-negative -/\ndef nonNegativeOutput_prop (n : Nat) : Prop :=\n  squareOrDouble n \u2265 0\n\n/-- Property: for even numbers, result is perfect square -/\ndef evenCase_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Property: for odd numbers, result is double -/\ndef oddCase_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Property: result is always even when input is even -/\ndef evenResult_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Property: zero maps to zero -/\ndef zero_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-- Property: function is monotonically increasing -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n \u2264 m \u2192 squareOrDouble n \u2264 squareOrDouble m\n\n/-- Property: result is at least as large as input for n \u2265 1 -/\ndef growth_prop (n : Nat) : Prop :=\n  n \u2265 1 \u2192 squareOrDouble n \u2265 n\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: outputs are always non-negative -/\ntheorem nonNegativeOutput_thm (n : Nat) : nonNegativeOutput_prop n := sorry\n\n/-- Theorem: even numbers are squared correctly -/\ntheorem evenCase_thm (n : Nat) : evenCase_prop n := sorry\n\n/-- Theorem: odd numbers are doubled correctly -/\ntheorem oddCase_thm (n : Nat) : oddCase_prop n := sorry\n\n/-- Theorem: zero case works correctly -/\ntheorem zero_thm : zero_prop := sorry\n\n/-- Theorem: result is even for even inputs -/\ntheorem evenResult_thm (n : Nat) : evenResult_prop n := sorry\n\n/-- Theorem: function preserves ordering -/\ntheorem monotonicity_thm (n m : Nat) : monotonicity_prop n m := sorry\n\n/-- Theorem: function grows at least linearly for n \u2265 1 -/\ntheorem growth_thm (n : Nat) : growth_prop n := sorry\n\n/-!\n# Correctness Theorem\n-/\n\n/-- Main correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness_thm (n : Nat) (h : Pre n) :\n  Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := n\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-- Test imperative implementation -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\nexample : squareOrDoubleImp 5 = 10 := by native_decide\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "test_score": 0.9333333333333333
    },
    {
      "iteration": 22,
      "score": 0.9733333333333334,
      "best_score_so_far": 0.9733333333333334,
      "num_metric_calls_so_far": 49,
      "calls_this_iter": 2,
      "accepted_new_candidate": false,
      "new_candidate_score": null,
      "best_lean_program": "/-!\n# Square or Double Function\n\nThis function takes an integer n and:\n- Returns n\u00b2 if n is even \n- Returns 2n if n is odd\n- Works for zero\n- Only accepts integer inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\nExamples:\n- squareOrDouble 4 = 16  \n- squareOrDouble 5 = 10\n- squareOrDouble 0 = 0\n\nRequires: Input must be an integer\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! \n# Basic Tests\n-/\n\n/-- Basic test case: even number -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test case: odd number -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Additional test cases -/\nexample : squareOrDouble 2 = 4 := by native_decide\nexample : squareOrDouble 3 = 6 := by native_decide\nexample : squareOrDouble 6 = 36 := by native_decide\nexample : squareOrDouble 7 = 14 := by native_decide\n\n/-!\n# Pre/Post Conditions\n-/\n\n/-- Pre-condition: Input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: Result follows square/double rule and maintains properties -/\ndef Post_prop (n : Nat) : Prop :=\n  let result := squareOrDouble n\n  (if n % 2 = 0 then result = n * n else result = 2 * n) \u2227  -- core behavior\n  result \u2265 0 \u2227                                              -- non-negativity\n  (n = 0 \u2192 result = 0) \u2227                                    -- zero case\n  (n \u2265 1 \u2192 result \u2265 n) \u2227                                    -- growth property\n  (n % 2 = 0 \u2192 result % 2 = 0)                             -- even output for even input\n\n/-!\n# Properties\n-/\n\n/-- Property: result is always non-negative -/\ndef nonNegativeOutput_prop (n : Nat) : Prop :=\n  squareOrDouble n \u2265 0\n\n/-- Property: for even numbers, result is perfect square -/\ndef evenCase_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Property: for odd numbers, result is double -/\ndef oddCase_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Property: result is always even when input is even -/\ndef evenResult_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Property: zero maps to zero -/\ndef zero_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-- Property: function is monotonically increasing -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n \u2264 m \u2192 squareOrDouble n \u2264 squareOrDouble m\n\n/-- Property: result is at least as large as input for n \u2265 1 -/\ndef growth_prop (n : Nat) : Prop :=\n  n \u2265 1 \u2192 squareOrDouble n \u2265 n\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: outputs are always non-negative -/\ntheorem nonNegativeOutput_thm (n : Nat) : nonNegativeOutput_prop n := sorry\n\n/-- Theorem: even numbers are squared correctly -/\ntheorem evenCase_thm (n : Nat) : evenCase_prop n := sorry\n\n/-- Theorem: odd numbers are doubled correctly -/\ntheorem oddCase_thm (n : Nat) : oddCase_prop n := sorry\n\n/-- Theorem: zero case works correctly -/\ntheorem zero_thm : zero_prop := sorry\n\n/-- Theorem: result is even for even inputs -/\ntheorem evenResult_thm (n : Nat) : evenResult_prop n := sorry\n\n/-- Theorem: function preserves ordering -/\ntheorem monotonicity_thm (n m : Nat) : monotonicity_prop n m := sorry\n\n/-- Theorem: function grows at least linearly for n \u2265 1 -/\ntheorem growth_thm (n : Nat) : growth_prop n := sorry\n\n/-!\n# Correctness Theorem\n-/\n\n/-- Main correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness_thm (n : Nat) (h : Pre n) :\n  Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := n\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-- Test imperative implementation -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\nexample : squareOrDoubleImp 5 = 10 := by native_decide\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "test_score": 0.9333333333333333
    },
    {
      "iteration": 23,
      "score": 0.96,
      "best_score_so_far": 0.9733333333333334,
      "num_metric_calls_so_far": 51,
      "calls_this_iter": 2,
      "accepted_new_candidate": false,
      "new_candidate_score": null,
      "best_lean_program": "/-!\n# Square or Double Function\n\nThis function takes an integer n and:\n- Returns n\u00b2 if n is even \n- Returns 2n if n is odd\n- Works for zero\n- Only accepts integer inputs\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturn n squared if n is even, otherwise return 2 times n.\n\nExamples:\n- squareOrDouble 4 = 16  \n- squareOrDouble 5 = 10\n- squareOrDouble 0 = 0\n\nRequires: Input must be an integer\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! \n# Basic Tests\n-/\n\n/-- Basic test case: even number -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Basic test case: odd number -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Edge case: zero -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Additional test cases -/\nexample : squareOrDouble 2 = 4 := by native_decide\nexample : squareOrDouble 3 = 6 := by native_decide\nexample : squareOrDouble 6 = 36 := by native_decide\nexample : squareOrDouble 7 = 14 := by native_decide\n\n/-!\n# Pre/Post Conditions\n-/\n\n/-- Pre-condition: Input must be a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Post-condition: Result follows square/double rule and maintains properties -/\ndef Post_prop (n : Nat) : Prop :=\n  let result := squareOrDouble n\n  (if n % 2 = 0 then result = n * n else result = 2 * n) \u2227  -- core behavior\n  result \u2265 0 \u2227                                              -- non-negativity\n  (n = 0 \u2192 result = 0) \u2227                                    -- zero case\n  (n \u2265 1 \u2192 result \u2265 n) \u2227                                    -- growth property\n  (n % 2 = 0 \u2192 result % 2 = 0)                             -- even output for even input\n\n/-!\n# Properties\n-/\n\n/-- Property: result is always non-negative -/\ndef nonNegativeOutput_prop (n : Nat) : Prop :=\n  squareOrDouble n \u2265 0\n\n/-- Property: for even numbers, result is perfect square -/\ndef evenCase_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n = n * n\n\n/-- Property: for odd numbers, result is double -/\ndef oddCase_prop (n : Nat) : Prop :=\n  n % 2 \u2260 0 \u2192 squareOrDouble n = 2 * n\n\n/-- Property: result is always even when input is even -/\ndef evenResult_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 (squareOrDouble n) % 2 = 0\n\n/-- Property: zero maps to zero -/\ndef zero_prop : Prop :=\n  squareOrDouble 0 = 0\n\n/-- Property: function is monotonically increasing -/\ndef monotonicity_prop (n m : Nat) : Prop :=\n  n \u2264 m \u2192 squareOrDouble n \u2264 squareOrDouble m\n\n/-- Property: result is at least as large as input for n \u2265 1 -/\ndef growth_prop (n : Nat) : Prop :=\n  n \u2265 1 \u2192 squareOrDouble n \u2265 n\n\n/-!\n# Theorems\n-/\n\n/-- Theorem: outputs are always non-negative -/\ntheorem nonNegativeOutput_thm (n : Nat) : nonNegativeOutput_prop n := sorry\n\n/-- Theorem: even numbers are squared correctly -/\ntheorem evenCase_thm (n : Nat) : evenCase_prop n := sorry\n\n/-- Theorem: odd numbers are doubled correctly -/\ntheorem oddCase_thm (n : Nat) : oddCase_prop n := sorry\n\n/-- Theorem: zero case works correctly -/\ntheorem zero_thm : zero_prop := sorry\n\n/-- Theorem: result is even for even inputs -/\ntheorem evenResult_thm (n : Nat) : evenResult_prop n := sorry\n\n/-- Theorem: function preserves ordering -/\ntheorem monotonicity_thm (n m : Nat) : monotonicity_prop n m := sorry\n\n/-- Theorem: function grows at least linearly for n \u2265 1 -/\ntheorem growth_thm (n : Nat) : growth_prop n := sorry\n\n/-!\n# Correctness Theorem\n-/\n\n/-- Main correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness_thm (n : Nat) (h : Pre n) :\n  Post_prop n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    let mut result := n\n    if n % 2 = 0 then\n      result := n * n\n    else\n      result := 2 * n\n    return result\n\n/-- Test imperative implementation -/\nexample : squareOrDoubleImp 4 = 16 := by native_decide\nexample : squareOrDoubleImp 5 = 10 := by native_decide\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
      "test_score": 0.9333333333333333
    },
    {
      "iteration": 1,
      "score": 0.0,
      "best_score_so_far": 0.9733333333333334,
      "num_metric_calls_so_far": 0,
      "is_new_best": false,
      "accepted_new_candidate": true,
      "new_candidate_score": 0.0,
      "best_lean_program": "-- No code yet"
    },
    {
      "iteration": 2,
      "score": 0.76,
      "best_score_so_far": 0.9733333333333334,
      "num_metric_calls_so_far": 9,
      "is_new_best": false,
      "accepted_new_candidate": true,
      "new_candidate_score": 0.76,
      "best_lean_program": "-- No code yet"
    },
    {
      "iteration": 3,
      "score": 0.8933333333333333,
      "best_score_so_far": 0.9733333333333334,
      "num_metric_calls_so_far": 14,
      "is_new_best": false,
      "accepted_new_candidate": true,
      "new_candidate_score": 0.8933333333333333,
      "best_lean_program": "-- No code yet"
    },
    {
      "iteration": 4,
      "score": 0.92,
      "best_score_so_far": 0.9733333333333334,
      "num_metric_calls_so_far": 19,
      "is_new_best": false,
      "accepted_new_candidate": true,
      "new_candidate_score": 0.92,
      "best_lean_program": "-- No code yet"
    },
    {
      "iteration": 5,
      "score": 0.8666666666666667,
      "best_score_so_far": 0.9733333333333334,
      "num_metric_calls_so_far": 30,
      "is_new_best": false,
      "accepted_new_candidate": true,
      "new_candidate_score": 0.8666666666666667,
      "best_lean_program": "-- No code yet"
    }
  ],
  "val_aggregate_scores": [
    0.0,
    0.76,
    0.8933333333333333,
    0.92,
    0.8666666666666667
  ],
  "settings": {
    "model": "anthropic/claude-3.5-sonnet",
    "max_iterations": null,
    "max_metric_calls_budget": 50,
    "reflection_minibatch_size": 1,
    "perfect_score_stopping_enabled": true,
    "mode": "direct_code_evolution"
  }
}