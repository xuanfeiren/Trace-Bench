{
  "task_idx": 44,
  "task_id": 44,
  "success": false,
  "final_score": 0.9733333333333334,
  "num_metric_calls": 50,
  "success_at_metric_call": null,
  "best_lean_code": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble",
  "duration_seconds": 1292.621579170227,
  "history": [
    {
      "attempt": 1,
      "score": 0.76,
      "best_score": 0.76,
      "is_new_best": true,
      "iteration_found": 1,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n, for integer n.\n\nEdge cases:\n- Works for zero\n- Input must be an integer (handled implicitly by Lean's type system)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\n\nExamples:\n- square_or_double 4 = 16\n- square_or_double 5 = 10 \n- square_or_double 0 = 0\n-/\ndef squareOrDouble (n : Int) : Int :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! \n# Unit Tests\n-/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4 -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5 -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0 -- expected: 0\n\n/-- Test negative even number: (-2)\u00b2 = 4 -/\nexample : squareOrDouble (-2) = 4 := by native_decide\n#eval squareOrDouble (-2) -- expected: 4\n\n/-- Test negative odd number: 2 * (-3) = -6 -/\nexample : squareOrDouble (-3) = -6 := by native_decide\n#eval squareOrDouble (-3) -- expected: -6\n\n/-!\n# Properties\n-/\n\n/-- Property: Result is non-negative for even non-negative inputs -/\ntheorem even_nonneg_output (n : Int) (h1: n % 2 = 0) (h2: n \u2265 0) : \n  squareOrDouble n \u2265 0 := sorry\n\n/-- Property: For odd numbers, output has same sign as input -/\ntheorem odd_preserves_sign (n : Int) (h: n % 2 \u2260 0) :\n  (squareOrDouble n > 0) = (n > 0) := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_maps_to_zero :\n  squareOrDouble 0 = 0 := by native_decide\n\nend SquareOrDouble"
    },
    {
      "attempt": 2,
      "score": 0.76,
      "best_score": 0.76,
      "is_new_best": false,
      "iteration_found": 2,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n, for integer n.\n\nEdge cases:\n- Works for zero\n- Input must be an integer (handled implicitly by Lean's type system)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\n\nExamples:\n- square_or_double 4 = 16\n- square_or_double 5 = 10 \n- square_or_double 0 = 0\n-/\ndef squareOrDouble (n : Int) : Int :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! \n# Unit Tests\n-/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4 -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5 -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0 -- expected: 0\n\n/-- Test negative even number: (-2)\u00b2 = 4 -/\nexample : squareOrDouble (-2) = 4 := by native_decide\n#eval squareOrDouble (-2) -- expected: 4\n\n/-- Test negative odd number: 2 * (-3) = -6 -/\nexample : squareOrDouble (-3) = -6 := by native_decide\n#eval squareOrDouble (-3) -- expected: -6\n\n/-!\n# Properties\n-/\n\n/-- Property: Result is non-negative for even non-negative inputs -/\ntheorem even_nonneg_output (n : Int) (h1: n % 2 = 0) (h2: n \u2265 0) : \n  squareOrDouble n \u2265 0 := sorry\n\n/-- Property: For odd numbers, output has same sign as input -/\ntheorem odd_preserves_sign (n : Int) (h: n % 2 \u2260 0) :\n  (squareOrDouble n > 0) = (n > 0) := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_maps_to_zero :\n  squareOrDouble 0 = 0 := by native_decide\n\nend SquareOrDouble"
    },
    {
      "attempt": 3,
      "score": 0.8666666666666667,
      "best_score": 0.8666666666666667,
      "is_new_best": true,
      "iteration_found": 3,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n, for natural number n.\n\nEdge cases:\n- Works for zero\n- Input must be a natural number (handled by Lean's type system)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\n\nExamples:\n- square_or_double 4 = 16 (even case)\n- square_or_double 5 = 10 (odd case)\n- square_or_double 0 = 0 (edge case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then\n    n * n\n  else\n    2 * n\n\n/-! \n# Unit Tests\n-/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4 -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5 -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0 -- expected: 0\n\n/-!\n# Properties and Theorems\n-/\n\n/-- Pre-condition: Input is a natural number (always true by type system) -/\ndef Pre (n : Nat) : Prop := True\n\n/-- Property: Result is even when input is even -/\ndef result_is_even_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 squareOrDouble n % 2 = 0\n\n/-- Property: Input is even implies output is a perfect square -/\ndef even_input_prop (n : Nat) : Prop :=\n  n % 2 = 0 \u2192 \u2203 k, squareOrDouble n = k * k\n\n/-- Property: Input is odd implies output is even -/\ndef odd_input_prop (n : Nat) : Prop :=\n  n % 2 = 1 \u2192 squareOrDouble n % 2 = 0\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) : Prop :=\n  result_is_even_prop n \u2227\n  even_input_prop n \u2227\n  odd_input_prop n\n\n/-!\n# Correctness Theorems\n-/\n\n/-- Theorem: Pre-condition implies post-condition -/\ntheorem correctness_thm (n : Nat) (h : Pre n) : Post n := sorry\n\n/-!\n# Imperative Implementation\n-/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := n\n      result := result * n\n      return result\n    else\n      return 2 * n\n\n/-!\n# Implementation Equivalence\n-/\n\n/-- Theorem: Functional and imperative implementations are equivalent -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 4,
      "score": 0.92,
      "best_score": 0.92,
      "is_new_best": true,
      "iteration_found": 4,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := sorry\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := sorry\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 5,
      "score": 0.0,
      "best_score": 0.92,
      "is_new_best": false,
      "iteration_found": 5,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := sorry\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := sorry\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 6,
      "score": 0.0,
      "best_score": 0.92,
      "is_new_best": false,
      "iteration_found": 6,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := sorry\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := sorry\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 7,
      "score": 0.9333333333333333,
      "best_score": 0.9333333333333333,
      "is_new_best": true,
      "iteration_found": 7,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := sorry\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 8,
      "score": 0.8666666666666667,
      "best_score": 0.9333333333333333,
      "is_new_best": false,
      "iteration_found": 8,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := sorry\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 9,
      "score": 0.0,
      "best_score": 0.9333333333333333,
      "is_new_best": false,
      "iteration_found": 9,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := sorry\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 10,
      "score": 0.0,
      "best_score": 0.9333333333333333,
      "is_new_best": false,
      "iteration_found": 10,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := sorry\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 11,
      "score": 0.0,
      "best_score": 0.9333333333333333,
      "is_new_best": false,
      "iteration_found": 11,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := sorry\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 12,
      "score": 0.0,
      "best_score": 0.9333333333333333,
      "is_new_best": false,
      "iteration_found": 12,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := sorry\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 13,
      "score": 0.0,
      "best_score": 0.9333333333333333,
      "is_new_best": false,
      "iteration_found": 13,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := sorry\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 14,
      "score": 0.9333333333333333,
      "best_score": 0.9333333333333333,
      "is_new_best": false,
      "iteration_found": 14,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := sorry\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 15,
      "score": 0.0,
      "best_score": 0.9333333333333333,
      "is_new_best": false,
      "iteration_found": 15,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := sorry\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 16,
      "score": 0.0,
      "best_score": 0.9333333333333333,
      "is_new_best": false,
      "iteration_found": 16,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := sorry\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 17,
      "score": 0.0,
      "best_score": 0.9333333333333333,
      "is_new_best": false,
      "iteration_found": 17,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := sorry\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 18,
      "score": 0.9733333333333334,
      "best_score": 0.9733333333333334,
      "is_new_best": true,
      "iteration_found": 18,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 19,
      "score": 0.0,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 19,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 20,
      "score": 0.0,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 20,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 21,
      "score": 0.92,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 21,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 22,
      "score": 0.9333333333333333,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 22,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 23,
      "score": 0.0,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 23,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 24,
      "score": 0.92,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 24,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 25,
      "score": 0.8666666666666667,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 25,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 26,
      "score": 0.0,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 26,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 27,
      "score": 0.8666666666666667,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 27,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 28,
      "score": 0.9333333333333333,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 28,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 29,
      "score": 0.0,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 29,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 30,
      "score": 0.0,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 30,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 31,
      "score": 0.0,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 31,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 32,
      "score": 0.0,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 32,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 33,
      "score": 0.9333333333333333,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 33,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 34,
      "score": 0.0,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 34,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 35,
      "score": 0.0,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 35,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 36,
      "score": 0.0,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 36,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 37,
      "score": 0.0,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 37,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 38,
      "score": 0.9733333333333334,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 38,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 39,
      "score": 0.92,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 39,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 40,
      "score": 0.0,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 40,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 41,
      "score": 0.0,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 41,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 42,
      "score": 0.8,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 42,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 43,
      "score": 0.0,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 43,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 44,
      "score": 0.92,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 44,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 45,
      "score": 0.0,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 45,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 46,
      "score": 0.0,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 46,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 47,
      "score": 0.0,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 47,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 48,
      "score": 0.0,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 48,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 49,
      "score": 0.0,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 49,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    },
    {
      "attempt": 50,
      "score": 0.8933333333333333,
      "best_score": 0.9733333333333334,
      "is_new_best": false,
      "iteration_found": 50,
      "best_lean_program": "/-!\n# Square or Double Function\n\nReturns n\u00b2 if n is even, otherwise returns 2n.\nWorks on natural numbers.\n\nEdge cases:\n- Works for zero (returns 0)\n-/\n\nnamespace SquareOrDouble\n\n/--\nReturns n\u00b2 if n is even, otherwise returns 2n.\nInput must be a natural number.\n\nExamples:\n- squareOrDouble 4 = 16  (even case)\n- squareOrDouble 5 = 10  (odd case)\n- squareOrDouble 0 = 0   (zero case)\n-/\ndef squareOrDouble (n : Nat) : Nat :=\n  if n % 2 = 0 then \n    n * n\n  else\n    2 * n\n\n/-! # Tests -/\n\n/-- Test even number: 4\u00b2 = 16 -/\nexample : squareOrDouble 4 = 16 := by native_decide\n#eval squareOrDouble 4  -- expected: 16\n\n/-- Test odd number: 2 * 5 = 10 -/\nexample : squareOrDouble 5 = 10 := by native_decide\n#eval squareOrDouble 5  -- expected: 10\n\n/-- Test zero: 0\u00b2 = 0 -/\nexample : squareOrDouble 0 = 0 := by native_decide\n#eval squareOrDouble 0  -- expected: 0\n\n/-- Test larger even number: 6\u00b2 = 36 -/\nexample : squareOrDouble 6 = 36 := by native_decide\n#eval squareOrDouble 6  -- expected: 36\n\n/-- Test larger odd number: 2 * 7 = 14 -/\nexample : squareOrDouble 7 = 14 := by native_decide\n#eval squareOrDouble 7  -- expected: 14\n\n/-! # Pre-Condition -/\n\n/-- Pre-condition: Input is a natural number (always true for Nat) -/\ndef Pre (n : Nat) : Prop := True\n\n/-! # Properties -/\n\n/-- Property: Result is always non-negative -/\ntheorem nonneg_output (n : Nat) : \n  squareOrDouble n \u2265 0 := by simp\n\n/-- Property: For even inputs, result is a perfect square -/\ntheorem even_perfect_square (n : Nat) (h: n % 2 = 0) :\n  \u2203 m, squareOrDouble n = m * m := by\n  exists n\n  simp [squareOrDouble, h]\n\n/-- Property: For odd inputs, result is even -/\ntheorem odd_gives_even (n : Nat) (h: n % 2 \u2260 0) :\n  (squareOrDouble n) % 2 = 0 := sorry\n\n/-- Property: Zero maps to zero -/\ntheorem zero_case : squareOrDouble 0 = 0 := by native_decide\n\n/-- Property: Result is at least as large as input -/\ntheorem result_geq_input (n : Nat) :\n  squareOrDouble n \u2265 n := sorry\n\n/-- Property: Result is monotonic for even numbers -/\ntheorem even_monotonic (n m : Nat) (h1: n % 2 = 0) (h2: m % 2 = 0) (h3: n \u2264 m) :\n  squareOrDouble n \u2264 squareOrDouble m := sorry\n\n/-! # Post-Condition -/\n\n/-- Post-condition: Conjunction of all desired properties -/\ndef Post (n : Nat) (result : Nat) : Prop :=\n  result \u2265 0 \u2227  -- non-negative output\n  result \u2265 n \u2227  -- result at least as large as input\n  (n % 2 = 0 \u2192 \u2203 m, result = m * m) \u2227  -- even case gives square\n  (n % 2 \u2260 0 \u2192 result % 2 = 0)  -- odd case gives even\n\n/-! # Correctness Theorem -/\n\n/-- Correctness theorem: Pre-condition implies Post-condition -/\ntheorem correctness (n : Nat) (h : Pre n) :\n  Post n (squareOrDouble n) := sorry\n\n/-! # Imperative Implementation -/\n\n/--\nImperative implementation using mutable state\n-/\ndef squareOrDoubleImp (n : Nat) : Nat :=\n  Id.run do\n    if n % 2 = 0 then\n      let mut result := 0\n      for _ in [:n] do\n        result := result + n\n      return result\n    else\n      return 2 * n\n\n/-! # Imperative Tests -/\n\nexample : squareOrDoubleImp 4 = 16 := by native_decide\n#eval squareOrDoubleImp 4  -- expected: 16\n\nexample : squareOrDoubleImp 5 = 10 := by native_decide\n#eval squareOrDoubleImp 5  -- expected: 10\n\nexample : squareOrDoubleImp 0 = 0 := by native_decide\n#eval squareOrDoubleImp 0  -- expected: 0\n\n/-- Equivalence theorem between functional and imperative implementations -/\ntheorem implementation_equivalence (n : Nat) :\n  squareOrDouble n = squareOrDoubleImp n := sorry\n\nend SquareOrDouble"
    }
  ],
  "metrics": {
    "combined_score": 0.9733333333333334
  },
  "settings": {
    "model": "claude-3.5-sonnet",
    "max_iterations": 50,
    "evolution_strategy": "full_rewrite",
    "population_size": 50
  }
}