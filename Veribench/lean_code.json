"/-!\n# Binary Search Implementation in Lean 4\n\nThis module implements binary search over a sorted list of natural numbers.\n\nEdge cases:\n- Empty list returns none\n- Type safety enforced by Lean's type system\n-/\n\nnamespace BinarySearch\n\n/--\nBinary search implementation that searches for a target value in a sorted list.\nReturns `some index` if found, `none` if not found.\n\n## Examples\n```lean\n#eval binarySearch [1, 2, 3, 4, 5] 3  -- expected: some 2\n#eval binarySearch [1, 2, 3, 4, 5] 6  -- expected: none\n#eval binarySearch [] 1               -- expected: none\n```\n-/\ndef binarySearch (arr : List Nat) (target : Nat) : Option Nat :=\n  if arr.isEmpty then\n    none\n  else\n    let rec search (left right : Nat) : Option Nat :=\n      if left > right then\n        none\n      else\n        let mid := (left + right) / 2\n        match arr.get? mid with\n        | none => none  \n        | some midVal =>\n          if midVal = target then\n            some mid\n          else if midVal < target then\n            search (mid + 1) right\n          else\n            search left (if mid = 0 then 0 else mid - 1)\n    termination_by search left right => right - left\n    \n    search 0 (arr.length - 1)\n\nsection Tests\n\n/-- Basic test cases -/\nexample : binarySearch [1, 2, 3, 4, 5] 3 = some 2 := by native_decide\nexample : binarySearch [1, 2, 3, 4, 5] 6 = none := by native_decide\nexample : binarySearch ([] : List Nat) 1 = none := by native_decide\nexample : binarySearch [5] 5 = some 0 := by native_decide\nexample : binarySearch [5] 3 = none := by native_decide\n\n/-- Tests with larger arrays -/\nexample : binarySearch [1, 3, 5, 7, 9] 3 = some 1 := by native_decide\nexample : binarySearch [1, 3, 5, 7, 9] 7 = some 3 := by native_decide\nexample : binarySearch [1, 3, 5, 7, 9] 4 = none := by native_decide\nexample : binarySearch [10, 20, 30, 40, 50] 50 = some 4 := by native_decide\nexample : binarySearch [10, 20, 30, 40, 50] 10 = some 0 := by native_decide\n\n/-- Tests with two-element arrays -/\nexample : binarySearch [1, 2] 1 = some 0 := by native_decide\nexample : binarySearch [1, 2] 2 = some 1 := by native_decide\nexample : binarySearch [1, 2] 3 = none := by native_decide\n\nend Tests\n\n/-!\n# Theorems\n-/\n\n/-- Property: if target is found, the index must be valid -/\ntheorem found_index_valid {arr : List Nat} {target idx : Nat} \n  (h : binarySearch arr target = some idx) : \n  idx < arr.length := sorry\n\n/-- Property: if target is found, it must be at the returned index -/\ntheorem found_value_correct {arr : List Nat} {target idx : Nat}\n  (h : binarySearch arr target = some idx) :\n  arr.get? idx = some target := sorry\n\n/-- Property: empty list always returns none -/\ntheorem empty_list_none : \n  \u2200 (target : Nat), binarySearch ([] : List Nat) target = none := by \n  intro target\n  native_decide\n\nend BinarySearch"